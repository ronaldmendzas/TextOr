"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/prosemirror-view";
exports.ids = ["vendor-chunks/prosemirror-view"];
exports.modules = {

/***/ "(ssr)/./node_modules/prosemirror-view/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/prosemirror-view/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Decoration: () => (/* binding */ Decoration),\n/* harmony export */   DecorationSet: () => (/* binding */ DecorationSet),\n/* harmony export */   EditorView: () => (/* binding */ EditorView),\n/* harmony export */   __endComposition: () => (/* binding */ __endComposition),\n/* harmony export */   __parseFromClipboard: () => (/* binding */ __parseFromClipboard)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-transform */ \"(ssr)/./node_modules/prosemirror-transform/dist/index.js\");\n\n\n\n\nconst domIndex = function (node) {\n    for (var index = 0;; index++) {\n        node = node.previousSibling;\n        if (!node)\n            return index;\n    }\n};\nconst parentNode = function (node) {\n    let parent = node.assignedSlot || node.parentNode;\n    return parent && parent.nodeType == 11 ? parent.host : parent;\n};\nlet reusedRange = null;\n// Note that this will always return the same range, because DOM range\n// objects are every expensive, and keep slowing down subsequent DOM\n// updates, for some reason.\nconst textRange = function (node, from, to) {\n    let range = reusedRange || (reusedRange = document.createRange());\n    range.setEnd(node, to == null ? node.nodeValue.length : to);\n    range.setStart(node, from || 0);\n    return range;\n};\nconst clearReusedRange = function () {\n    reusedRange = null;\n};\n// Scans forward and backward through DOM positions equivalent to the\n// given one to see if the two are in the same place (i.e. after a\n// text node vs at the end of that text node)\nconst isEquivalentPosition = function (node, off, targetNode, targetOff) {\n    return targetNode && (scanFor(node, off, targetNode, targetOff, -1) ||\n        scanFor(node, off, targetNode, targetOff, 1));\n};\nconst atomElements = /^(img|br|input|textarea|hr)$/i;\nfunction scanFor(node, off, targetNode, targetOff, dir) {\n    var _a;\n    for (;;) {\n        if (node == targetNode && off == targetOff)\n            return true;\n        if (off == (dir < 0 ? 0 : nodeSize(node))) {\n            let parent = node.parentNode;\n            if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) ||\n                node.contentEditable == \"false\")\n                return false;\n            off = domIndex(node) + (dir < 0 ? 0 : 1);\n            node = parent;\n        }\n        else if (node.nodeType == 1) {\n            let child = node.childNodes[off + (dir < 0 ? -1 : 0)];\n            if (child.nodeType == 1 && child.contentEditable == \"false\") {\n                if ((_a = child.pmViewDesc) === null || _a === void 0 ? void 0 : _a.ignoreForSelection)\n                    off += dir;\n                else\n                    return false;\n            }\n            else {\n                node = child;\n                off = dir < 0 ? nodeSize(node) : 0;\n            }\n        }\n        else {\n            return false;\n        }\n    }\n}\nfunction nodeSize(node) {\n    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nfunction textNodeBefore$1(node, offset) {\n    for (;;) {\n        if (node.nodeType == 3 && offset)\n            return node;\n        if (node.nodeType == 1 && offset > 0) {\n            if (node.contentEditable == \"false\")\n                return null;\n            node = node.childNodes[offset - 1];\n            offset = nodeSize(node);\n        }\n        else if (node.parentNode && !hasBlockDesc(node)) {\n            offset = domIndex(node);\n            node = node.parentNode;\n        }\n        else {\n            return null;\n        }\n    }\n}\nfunction textNodeAfter$1(node, offset) {\n    for (;;) {\n        if (node.nodeType == 3 && offset < node.nodeValue.length)\n            return node;\n        if (node.nodeType == 1 && offset < node.childNodes.length) {\n            if (node.contentEditable == \"false\")\n                return null;\n            node = node.childNodes[offset];\n            offset = 0;\n        }\n        else if (node.parentNode && !hasBlockDesc(node)) {\n            offset = domIndex(node) + 1;\n            node = node.parentNode;\n        }\n        else {\n            return null;\n        }\n    }\n}\nfunction isOnEdge(node, offset, parent) {\n    for (let atStart = offset == 0, atEnd = offset == nodeSize(node); atStart || atEnd;) {\n        if (node == parent)\n            return true;\n        let index = domIndex(node);\n        node = node.parentNode;\n        if (!node)\n            return false;\n        atStart = atStart && index == 0;\n        atEnd = atEnd && index == nodeSize(node);\n    }\n}\nfunction hasBlockDesc(dom) {\n    let desc;\n    for (let cur = dom; cur; cur = cur.parentNode)\n        if (desc = cur.pmViewDesc)\n            break;\n    return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);\n}\n// Work around Chrome issue https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n// (isCollapsed inappropriately returns true in shadow dom)\nconst selectionCollapsed = function (domSel) {\n    return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);\n};\nfunction keyEvent(keyCode, key) {\n    let event = document.createEvent(\"Event\");\n    event.initEvent(\"keydown\", true, true);\n    event.keyCode = keyCode;\n    event.key = event.code = key;\n    return event;\n}\nfunction deepActiveElement(doc) {\n    let elt = doc.activeElement;\n    while (elt && elt.shadowRoot)\n        elt = elt.shadowRoot.activeElement;\n    return elt;\n}\nfunction caretFromPoint(doc, x, y) {\n    if (doc.caretPositionFromPoint) {\n        try { // Firefox throws for this call in hard-to-predict circumstances (#994)\n            let pos = doc.caretPositionFromPoint(x, y);\n            // Clip the offset, because Chrome will return a text offset\n            // into <input> nodes, which can't be treated as a regular DOM\n            // offset\n            if (pos)\n                return { node: pos.offsetNode, offset: Math.min(nodeSize(pos.offsetNode), pos.offset) };\n        }\n        catch (_) { }\n    }\n    if (doc.caretRangeFromPoint) {\n        let range = doc.caretRangeFromPoint(x, y);\n        if (range)\n            return { node: range.startContainer, offset: Math.min(nodeSize(range.startContainer), range.startOffset) };\n    }\n}\n\nconst nav = typeof navigator != \"undefined\" ? navigator : null;\nconst doc = typeof document != \"undefined\" ? document : null;\nconst agent = (nav && nav.userAgent) || \"\";\nconst ie_edge = /Edge\\/(\\d+)/.exec(agent);\nconst ie_upto10 = /MSIE \\d/.exec(agent);\nconst ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(agent);\nconst ie = !!(ie_upto10 || ie_11up || ie_edge);\nconst ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;\nconst gecko = !ie && /gecko\\/(\\d+)/i.test(agent);\ngecko && +(/Firefox\\/(\\d+)/.exec(agent) || [0, 0])[1];\nconst _chrome = !ie && /Chrome\\/(\\d+)/.exec(agent);\nconst chrome = !!_chrome;\nconst chrome_version = _chrome ? +_chrome[1] : 0;\nconst safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);\n// Is true for both iOS and iPadOS for convenience\nconst ios = safari && (/Mobile\\/\\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);\nconst mac = ios || (nav ? /Mac/.test(nav.platform) : false);\nconst windows = nav ? /Win/.test(nav.platform) : false;\nconst android = /Android \\d/.test(agent);\nconst webkit = !!doc && \"webkitFontSmoothing\" in doc.documentElement.style;\nconst webkit_version = webkit ? +(/\\bAppleWebKit\\/(\\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;\n\nfunction windowRect(doc) {\n    let vp = doc.defaultView && doc.defaultView.visualViewport;\n    if (vp)\n        return {\n            left: 0, right: vp.width,\n            top: 0, bottom: vp.height\n        };\n    return { left: 0, right: doc.documentElement.clientWidth,\n        top: 0, bottom: doc.documentElement.clientHeight };\n}\nfunction getSide(value, side) {\n    return typeof value == \"number\" ? value : value[side];\n}\nfunction clientRect(node) {\n    let rect = node.getBoundingClientRect();\n    // Adjust for elements with style \"transform: scale()\"\n    let scaleX = (rect.width / node.offsetWidth) || 1;\n    let scaleY = (rect.height / node.offsetHeight) || 1;\n    // Make sure scrollbar width isn't included in the rectangle\n    return { left: rect.left, right: rect.left + node.clientWidth * scaleX,\n        top: rect.top, bottom: rect.top + node.clientHeight * scaleY };\n}\nfunction scrollRectIntoView(view, rect, startDOM) {\n    let scrollThreshold = view.someProp(\"scrollThreshold\") || 0, scrollMargin = view.someProp(\"scrollMargin\") || 5;\n    let doc = view.dom.ownerDocument;\n    for (let parent = startDOM || view.dom;;) {\n        if (!parent)\n            break;\n        if (parent.nodeType != 1) {\n            parent = parentNode(parent);\n            continue;\n        }\n        let elt = parent;\n        let atTop = elt == doc.body;\n        let bounding = atTop ? windowRect(doc) : clientRect(elt);\n        let moveX = 0, moveY = 0;\n        if (rect.top < bounding.top + getSide(scrollThreshold, \"top\"))\n            moveY = -(bounding.top - rect.top + getSide(scrollMargin, \"top\"));\n        else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, \"bottom\"))\n            moveY = rect.bottom - rect.top > bounding.bottom - bounding.top\n                ? rect.top + getSide(scrollMargin, \"top\") - bounding.top\n                : rect.bottom - bounding.bottom + getSide(scrollMargin, \"bottom\");\n        if (rect.left < bounding.left + getSide(scrollThreshold, \"left\"))\n            moveX = -(bounding.left - rect.left + getSide(scrollMargin, \"left\"));\n        else if (rect.right > bounding.right - getSide(scrollThreshold, \"right\"))\n            moveX = rect.right - bounding.right + getSide(scrollMargin, \"right\");\n        if (moveX || moveY) {\n            if (atTop) {\n                doc.defaultView.scrollBy(moveX, moveY);\n            }\n            else {\n                let startX = elt.scrollLeft, startY = elt.scrollTop;\n                if (moveY)\n                    elt.scrollTop += moveY;\n                if (moveX)\n                    elt.scrollLeft += moveX;\n                let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;\n                rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };\n            }\n        }\n        let pos = atTop ? \"fixed\" : getComputedStyle(parent).position;\n        if (/^(fixed|sticky)$/.test(pos))\n            break;\n        parent = pos == \"absolute\" ? parent.offsetParent : parentNode(parent);\n    }\n}\n// Store the scroll position of the editor's parent nodes, along with\n// the top position of an element near the top of the editor, which\n// will be used to make sure the visible viewport remains stable even\n// when the size of the content above changes.\nfunction storeScrollPos(view) {\n    let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);\n    let refDOM, refTop;\n    for (let x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {\n        let dom = view.root.elementFromPoint(x, y);\n        if (!dom || dom == view.dom || !view.dom.contains(dom))\n            continue;\n        let localRect = dom.getBoundingClientRect();\n        if (localRect.top >= startY - 20) {\n            refDOM = dom;\n            refTop = localRect.top;\n            break;\n        }\n    }\n    return { refDOM: refDOM, refTop: refTop, stack: scrollStack(view.dom) };\n}\nfunction scrollStack(dom) {\n    let stack = [], doc = dom.ownerDocument;\n    for (let cur = dom; cur; cur = parentNode(cur)) {\n        stack.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });\n        if (dom == doc)\n            break;\n    }\n    return stack;\n}\n// Reset the scroll position of the editor's parent nodes to that what\n// it was before, when storeScrollPos was called.\nfunction resetScrollPos({ refDOM, refTop, stack }) {\n    let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;\n    restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);\n}\nfunction restoreScrollStack(stack, dTop) {\n    for (let i = 0; i < stack.length; i++) {\n        let { dom, top, left } = stack[i];\n        if (dom.scrollTop != top + dTop)\n            dom.scrollTop = top + dTop;\n        if (dom.scrollLeft != left)\n            dom.scrollLeft = left;\n    }\n}\nlet preventScrollSupported = null;\n// Feature-detects support for .focus({preventScroll: true}), and uses\n// a fallback kludge when not supported.\nfunction focusPreventScroll(dom) {\n    if (dom.setActive)\n        return dom.setActive(); // in IE\n    if (preventScrollSupported)\n        return dom.focus(preventScrollSupported);\n    let stored = scrollStack(dom);\n    dom.focus(preventScrollSupported == null ? {\n        get preventScroll() {\n            preventScrollSupported = { preventScroll: true };\n            return true;\n        }\n    } : undefined);\n    if (!preventScrollSupported) {\n        preventScrollSupported = false;\n        restoreScrollStack(stored, 0);\n    }\n}\nfunction findOffsetInNode(node, coords) {\n    let closest, dxClosest = 2e8, coordsClosest, offset = 0;\n    let rowBot = coords.top, rowTop = coords.top;\n    let firstBelow, coordsBelow;\n    for (let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {\n        let rects;\n        if (child.nodeType == 1)\n            rects = child.getClientRects();\n        else if (child.nodeType == 3)\n            rects = textRange(child).getClientRects();\n        else\n            continue;\n        for (let i = 0; i < rects.length; i++) {\n            let rect = rects[i];\n            if (rect.top <= rowBot && rect.bottom >= rowTop) {\n                rowBot = Math.max(rect.bottom, rowBot);\n                rowTop = Math.min(rect.top, rowTop);\n                let dx = rect.left > coords.left ? rect.left - coords.left\n                    : rect.right < coords.left ? coords.left - rect.right : 0;\n                if (dx < dxClosest) {\n                    closest = child;\n                    dxClosest = dx;\n                    coordsClosest = dx && closest.nodeType == 3 ? {\n                        left: rect.right < coords.left ? rect.right : rect.left,\n                        top: coords.top\n                    } : coords;\n                    if (child.nodeType == 1 && dx)\n                        offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);\n                    continue;\n                }\n            }\n            else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {\n                firstBelow = child;\n                coordsBelow = { left: Math.max(rect.left, Math.min(rect.right, coords.left)), top: rect.top };\n            }\n            if (!closest && (coords.left >= rect.right && coords.top >= rect.top ||\n                coords.left >= rect.left && coords.top >= rect.bottom))\n                offset = childIndex + 1;\n        }\n    }\n    if (!closest && firstBelow) {\n        closest = firstBelow;\n        coordsClosest = coordsBelow;\n        dxClosest = 0;\n    }\n    if (closest && closest.nodeType == 3)\n        return findOffsetInText(closest, coordsClosest);\n    if (!closest || (dxClosest && closest.nodeType == 1))\n        return { node, offset };\n    return findOffsetInNode(closest, coordsClosest);\n}\nfunction findOffsetInText(node, coords) {\n    let len = node.nodeValue.length;\n    let range = document.createRange(), result;\n    for (let i = 0; i < len; i++) {\n        range.setEnd(node, i + 1);\n        range.setStart(node, i);\n        let rect = singleRect(range, 1);\n        if (rect.top == rect.bottom)\n            continue;\n        if (inRect(coords, rect)) {\n            result = { node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };\n            break;\n        }\n    }\n    range.detach();\n    return result || { node, offset: 0 };\n}\nfunction inRect(coords, rect) {\n    return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 &&\n        coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;\n}\nfunction targetKludge(dom, coords) {\n    let parent = dom.parentNode;\n    if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)\n        return parent;\n    return dom;\n}\nfunction posFromElement(view, elt, coords) {\n    let { node, offset } = findOffsetInNode(elt, coords), bias = -1;\n    if (node.nodeType == 1 && !node.firstChild) {\n        let rect = node.getBoundingClientRect();\n        bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;\n    }\n    return view.docView.posFromDOM(node, offset, bias);\n}\nfunction posFromCaret(view, node, offset, coords) {\n    // Browser (in caretPosition/RangeFromPoint) will agressively\n    // normalize towards nearby inline nodes. Since we are interested in\n    // positions between block nodes too, we first walk up the hierarchy\n    // of nodes to see if there are block nodes that the coordinates\n    // fall outside of. If so, we take the position before/after that\n    // block. If not, we call `posFromDOM` on the raw node/offset.\n    let outsideBlock = -1;\n    for (let cur = node, sawBlock = false;;) {\n        if (cur == view.dom)\n            break;\n        let desc = view.docView.nearestDesc(cur, true), rect;\n        if (!desc)\n            return null;\n        if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent || !desc.contentDOM) &&\n            // Ignore elements with zero-size bounding rectangles\n            ((rect = desc.dom.getBoundingClientRect()).width || rect.height)) {\n            if (desc.node.isBlock && desc.parent && !/^T(R|BODY|HEAD|FOOT)$/.test(desc.dom.nodeName)) {\n                // Only apply the horizontal test to the innermost block. Vertical for any parent.\n                if (!sawBlock && rect.left > coords.left || rect.top > coords.top)\n                    outsideBlock = desc.posBefore;\n                else if (!sawBlock && rect.right < coords.left || rect.bottom < coords.top)\n                    outsideBlock = desc.posAfter;\n                sawBlock = true;\n            }\n            if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {\n                // If we are inside a leaf, return the side of the leaf closer to the coords\n                let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2\n                    : coords.left < (rect.left + rect.right) / 2;\n                return before ? desc.posBefore : desc.posAfter;\n            }\n        }\n        cur = desc.dom.parentNode;\n    }\n    return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset, -1);\n}\nfunction elementFromPoint(element, coords, box) {\n    let len = element.childNodes.length;\n    if (len && box.top < box.bottom) {\n        for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI;;) {\n            let child = element.childNodes[i];\n            if (child.nodeType == 1) {\n                let rects = child.getClientRects();\n                for (let j = 0; j < rects.length; j++) {\n                    let rect = rects[j];\n                    if (inRect(coords, rect))\n                        return elementFromPoint(child, coords, rect);\n                }\n            }\n            if ((i = (i + 1) % len) == startI)\n                break;\n        }\n    }\n    return element;\n}\n// Given an x,y position on the editor, get the position in the document.\nfunction posAtCoords(view, coords) {\n    let doc = view.dom.ownerDocument, node, offset = 0;\n    let caret = caretFromPoint(doc, coords.left, coords.top);\n    if (caret)\n        ({ node, offset } = caret);\n    let elt = (view.root.elementFromPoint ? view.root : doc)\n        .elementFromPoint(coords.left, coords.top);\n    let pos;\n    if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {\n        let box = view.dom.getBoundingClientRect();\n        if (!inRect(coords, box))\n            return null;\n        elt = elementFromPoint(view.dom, coords, box);\n        if (!elt)\n            return null;\n    }\n    // Safari's caretRangeFromPoint returns nonsense when on a draggable element\n    if (safari) {\n        for (let p = elt; node && p; p = parentNode(p))\n            if (p.draggable)\n                node = undefined;\n    }\n    elt = targetKludge(elt, coords);\n    if (node) {\n        if (gecko && node.nodeType == 1) {\n            // Firefox will sometimes return offsets into <input> nodes, which\n            // have no actual children, from caretPositionFromPoint (#953)\n            offset = Math.min(offset, node.childNodes.length);\n            // It'll also move the returned position before image nodes,\n            // even if those are behind it.\n            if (offset < node.childNodes.length) {\n                let next = node.childNodes[offset], box;\n                if (next.nodeName == \"IMG\" && (box = next.getBoundingClientRect()).right <= coords.left &&\n                    box.bottom > coords.top)\n                    offset++;\n            }\n        }\n        let prev;\n        // When clicking above the right side of an uneditable node, Chrome will report a cursor position after that node.\n        if (webkit && offset && node.nodeType == 1 && (prev = node.childNodes[offset - 1]).nodeType == 1 &&\n            prev.contentEditable == \"false\" && prev.getBoundingClientRect().top >= coords.top)\n            offset--;\n        // Suspiciously specific kludge to work around caret*FromPoint\n        // never returning a position at the end of the document\n        if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 &&\n            coords.top > node.lastChild.getBoundingClientRect().bottom)\n            pos = view.state.doc.content.size;\n        // Ignore positions directly after a BR, since caret*FromPoint\n        // 'round up' positions that would be more accurately placed\n        // before the BR node.\n        else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != \"BR\")\n            pos = posFromCaret(view, node, offset, coords);\n    }\n    if (pos == null)\n        pos = posFromElement(view, elt, coords);\n    let desc = view.docView.nearestDesc(elt, true);\n    return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };\n}\nfunction nonZero(rect) {\n    return rect.top < rect.bottom || rect.left < rect.right;\n}\nfunction singleRect(target, bias) {\n    let rects = target.getClientRects();\n    if (rects.length) {\n        let first = rects[bias < 0 ? 0 : rects.length - 1];\n        if (nonZero(first))\n            return first;\n    }\n    return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();\n}\nconst BIDI = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n// Given a position in the document model, get a bounding box of the\n// character at that position, relative to the window.\nfunction coordsAtPos(view, pos, side) {\n    let { node, offset, atom } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);\n    let supportEmptyRange = webkit || gecko;\n    if (node.nodeType == 3) {\n        // These browsers support querying empty text ranges. Prefer that in\n        // bidi context or when at the end of a node.\n        if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {\n            let rect = singleRect(textRange(node, offset, offset), side);\n            // Firefox returns bad results (the position before the space)\n            // when querying a position directly after line-broken\n            // whitespace. Detect this situation and and kludge around it\n            if (gecko && offset && /\\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {\n                let rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1);\n                if (rectBefore.top == rect.top) {\n                    let rectAfter = singleRect(textRange(node, offset, offset + 1), -1);\n                    if (rectAfter.top != rect.top)\n                        return flattenV(rectAfter, rectAfter.left < rectBefore.left);\n                }\n            }\n            return rect;\n        }\n        else {\n            let from = offset, to = offset, takeSide = side < 0 ? 1 : -1;\n            if (side < 0 && !offset) {\n                to++;\n                takeSide = -1;\n            }\n            else if (side >= 0 && offset == node.nodeValue.length) {\n                from--;\n                takeSide = 1;\n            }\n            else if (side < 0) {\n                from--;\n            }\n            else {\n                to++;\n            }\n            return flattenV(singleRect(textRange(node, from, to), takeSide), takeSide < 0);\n        }\n    }\n    let $dom = view.state.doc.resolve(pos - (atom || 0));\n    // Return a horizontal line in block context\n    if (!$dom.parent.inlineContent) {\n        if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {\n            let before = node.childNodes[offset - 1];\n            if (before.nodeType == 1)\n                return flattenH(before.getBoundingClientRect(), false);\n        }\n        if (atom == null && offset < nodeSize(node)) {\n            let after = node.childNodes[offset];\n            if (after.nodeType == 1)\n                return flattenH(after.getBoundingClientRect(), true);\n        }\n        return flattenH(node.getBoundingClientRect(), side >= 0);\n    }\n    // Inline, not in text node (this is not Bidi-safe)\n    if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {\n        let before = node.childNodes[offset - 1];\n        let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1))\n            // BR nodes tend to only return the rectangle before them.\n            // Only use them if they are the last element in their parent\n            : before.nodeType == 1 && (before.nodeName != \"BR\" || !before.nextSibling) ? before : null;\n        if (target)\n            return flattenV(singleRect(target, 1), false);\n    }\n    if (atom == null && offset < nodeSize(node)) {\n        let after = node.childNodes[offset];\n        while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)\n            after = after.nextSibling;\n        let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, (supportEmptyRange ? 0 : 1))\n            : after.nodeType == 1 ? after : null;\n        if (target)\n            return flattenV(singleRect(target, -1), true);\n    }\n    // All else failed, just try to get a rectangle for the target node\n    return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);\n}\nfunction flattenV(rect, left) {\n    if (rect.width == 0)\n        return rect;\n    let x = left ? rect.left : rect.right;\n    return { top: rect.top, bottom: rect.bottom, left: x, right: x };\n}\nfunction flattenH(rect, top) {\n    if (rect.height == 0)\n        return rect;\n    let y = top ? rect.top : rect.bottom;\n    return { top: y, bottom: y, left: rect.left, right: rect.right };\n}\nfunction withFlushedState(view, state, f) {\n    let viewState = view.state, active = view.root.activeElement;\n    if (viewState != state)\n        view.updateState(state);\n    if (active != view.dom)\n        view.focus();\n    try {\n        return f();\n    }\n    finally {\n        if (viewState != state)\n            view.updateState(viewState);\n        if (active != view.dom && active)\n            active.focus();\n    }\n}\n// Whether vertical position motion in a given direction\n// from a position would leave a text block.\nfunction endOfTextblockVertical(view, state, dir) {\n    let sel = state.selection;\n    let $pos = dir == \"up\" ? sel.$from : sel.$to;\n    return withFlushedState(view, state, () => {\n        let { node: dom } = view.docView.domFromPos($pos.pos, dir == \"up\" ? -1 : 1);\n        for (;;) {\n            let nearest = view.docView.nearestDesc(dom, true);\n            if (!nearest)\n                break;\n            if (nearest.node.isBlock) {\n                dom = nearest.contentDOM || nearest.dom;\n                break;\n            }\n            dom = nearest.dom.parentNode;\n        }\n        let coords = coordsAtPos(view, $pos.pos, 1);\n        for (let child = dom.firstChild; child; child = child.nextSibling) {\n            let boxes;\n            if (child.nodeType == 1)\n                boxes = child.getClientRects();\n            else if (child.nodeType == 3)\n                boxes = textRange(child, 0, child.nodeValue.length).getClientRects();\n            else\n                continue;\n            for (let i = 0; i < boxes.length; i++) {\n                let box = boxes[i];\n                if (box.bottom > box.top + 1 &&\n                    (dir == \"up\" ? coords.top - box.top > (box.bottom - coords.top) * 2\n                        : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))\n                    return false;\n            }\n        }\n        return true;\n    });\n}\nconst maybeRTL = /[\\u0590-\\u08ac]/;\nfunction endOfTextblockHorizontal(view, state, dir) {\n    let { $head } = state.selection;\n    if (!$head.parent.isTextblock)\n        return false;\n    let offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size;\n    let sel = view.domSelection();\n    if (!sel)\n        return $head.pos == $head.start() || $head.pos == $head.end();\n    // If the textblock is all LTR, or the browser doesn't support\n    // Selection.modify (Edge), fall back to a primitive approach\n    if (!maybeRTL.test($head.parent.textContent) || !sel.modify)\n        return dir == \"left\" || dir == \"backward\" ? atStart : atEnd;\n    return withFlushedState(view, state, () => {\n        // This is a huge hack, but appears to be the best we can\n        // currently do: use `Selection.modify` to move the selection by\n        // one character, and see if that moves the cursor out of the\n        // textblock (or doesn't move it at all, when at the start/end of\n        // the document).\n        let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();\n        let oldBidiLevel = sel.caretBidiLevel // Only for Firefox\n        ;\n        sel.modify(\"move\", dir, \"character\");\n        let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;\n        let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();\n        let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) ||\n            (oldNode == newNode && oldOff == newOff);\n        // Restore the previous selection\n        try {\n            sel.collapse(anchorNode, anchorOffset);\n            if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)\n                sel.extend(oldNode, oldOff);\n        }\n        catch (_) { }\n        if (oldBidiLevel != null)\n            sel.caretBidiLevel = oldBidiLevel;\n        return result;\n    });\n}\nlet cachedState = null;\nlet cachedDir = null;\nlet cachedResult = false;\nfunction endOfTextblock(view, state, dir) {\n    if (cachedState == state && cachedDir == dir)\n        return cachedResult;\n    cachedState = state;\n    cachedDir = dir;\n    return cachedResult = dir == \"up\" || dir == \"down\"\n        ? endOfTextblockVertical(view, state, dir)\n        : endOfTextblockHorizontal(view, state, dir);\n}\n\n// View descriptions are data structures that describe the DOM that is\n// used to represent the editor's content. They are used for:\n//\n// - Incremental redrawing when the document changes\n//\n// - Figuring out what part of the document a given DOM position\n//   corresponds to\n//\n// - Wiring in custom implementations of the editing interface for a\n//   given node\n//\n// They form a doubly-linked mutable tree, starting at `view.docView`.\nconst NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;\n// Superclass for the various kinds of descriptions. Defines their\n// basic structure and shared methods.\nclass ViewDesc {\n    constructor(parent, children, dom, \n    // This is the node that holds the child views. It may be null for\n    // descs that don't have children.\n    contentDOM) {\n        this.parent = parent;\n        this.children = children;\n        this.dom = dom;\n        this.contentDOM = contentDOM;\n        this.dirty = NOT_DIRTY;\n        // An expando property on the DOM node provides a link back to its\n        // description.\n        dom.pmViewDesc = this;\n    }\n    // Used to check whether a given description corresponds to a\n    // widget/mark/node.\n    matchesWidget(widget) { return false; }\n    matchesMark(mark) { return false; }\n    matchesNode(node, outerDeco, innerDeco) { return false; }\n    matchesHack(nodeName) { return false; }\n    // When parsing in-editor content (in domchange.js), we allow\n    // descriptions to determine the parse rules that should be used to\n    // parse them.\n    parseRule() { return null; }\n    // Used by the editor's event handler to ignore events that come\n    // from certain descs.\n    stopEvent(event) { return false; }\n    // The size of the content represented by this desc.\n    get size() {\n        let size = 0;\n        for (let i = 0; i < this.children.length; i++)\n            size += this.children[i].size;\n        return size;\n    }\n    // For block nodes, this represents the space taken up by their\n    // start/end tokens.\n    get border() { return 0; }\n    destroy() {\n        this.parent = undefined;\n        if (this.dom.pmViewDesc == this)\n            this.dom.pmViewDesc = undefined;\n        for (let i = 0; i < this.children.length; i++)\n            this.children[i].destroy();\n    }\n    posBeforeChild(child) {\n        for (let i = 0, pos = this.posAtStart;; i++) {\n            let cur = this.children[i];\n            if (cur == child)\n                return pos;\n            pos += cur.size;\n        }\n    }\n    get posBefore() {\n        return this.parent.posBeforeChild(this);\n    }\n    get posAtStart() {\n        return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;\n    }\n    get posAfter() {\n        return this.posBefore + this.size;\n    }\n    get posAtEnd() {\n        return this.posAtStart + this.size - 2 * this.border;\n    }\n    localPosFromDOM(dom, offset, bias) {\n        // If the DOM position is in the content, use the child desc after\n        // it to figure out a position.\n        if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {\n            if (bias < 0) {\n                let domBefore, desc;\n                if (dom == this.contentDOM) {\n                    domBefore = dom.childNodes[offset - 1];\n                }\n                else {\n                    while (dom.parentNode != this.contentDOM)\n                        dom = dom.parentNode;\n                    domBefore = dom.previousSibling;\n                }\n                while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))\n                    domBefore = domBefore.previousSibling;\n                return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;\n            }\n            else {\n                let domAfter, desc;\n                if (dom == this.contentDOM) {\n                    domAfter = dom.childNodes[offset];\n                }\n                else {\n                    while (dom.parentNode != this.contentDOM)\n                        dom = dom.parentNode;\n                    domAfter = dom.nextSibling;\n                }\n                while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))\n                    domAfter = domAfter.nextSibling;\n                return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;\n            }\n        }\n        // Otherwise, use various heuristics, falling back on the bias\n        // parameter, to determine whether to return the position at the\n        // start or at the end of this view desc.\n        let atEnd;\n        if (dom == this.dom && this.contentDOM) {\n            atEnd = offset > domIndex(this.contentDOM);\n        }\n        else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {\n            atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;\n        }\n        else if (this.dom.firstChild) {\n            if (offset == 0)\n                for (let search = dom;; search = search.parentNode) {\n                    if (search == this.dom) {\n                        atEnd = false;\n                        break;\n                    }\n                    if (search.previousSibling)\n                        break;\n                }\n            if (atEnd == null && offset == dom.childNodes.length)\n                for (let search = dom;; search = search.parentNode) {\n                    if (search == this.dom) {\n                        atEnd = true;\n                        break;\n                    }\n                    if (search.nextSibling)\n                        break;\n                }\n        }\n        return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;\n    }\n    nearestDesc(dom, onlyNodes = false) {\n        for (let first = true, cur = dom; cur; cur = cur.parentNode) {\n            let desc = this.getDesc(cur), nodeDOM;\n            if (desc && (!onlyNodes || desc.node)) {\n                // If dom is outside of this desc's nodeDOM, don't count it.\n                if (first && (nodeDOM = desc.nodeDOM) &&\n                    !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))\n                    first = false;\n                else\n                    return desc;\n            }\n        }\n    }\n    getDesc(dom) {\n        let desc = dom.pmViewDesc;\n        for (let cur = desc; cur; cur = cur.parent)\n            if (cur == this)\n                return desc;\n    }\n    posFromDOM(dom, offset, bias) {\n        for (let scan = dom; scan; scan = scan.parentNode) {\n            let desc = this.getDesc(scan);\n            if (desc)\n                return desc.localPosFromDOM(dom, offset, bias);\n        }\n        return -1;\n    }\n    // Find the desc for the node after the given pos, if any. (When a\n    // parent node overrode rendering, there might not be one.)\n    descAt(pos) {\n        for (let i = 0, offset = 0; i < this.children.length; i++) {\n            let child = this.children[i], end = offset + child.size;\n            if (offset == pos && end != offset) {\n                while (!child.border && child.children.length) {\n                    for (let i = 0; i < child.children.length; i++) {\n                        let inner = child.children[i];\n                        if (inner.size) {\n                            child = inner;\n                            break;\n                        }\n                    }\n                }\n                return child;\n            }\n            if (pos < end)\n                return child.descAt(pos - offset - child.border);\n            offset = end;\n        }\n    }\n    domFromPos(pos, side) {\n        if (!this.contentDOM)\n            return { node: this.dom, offset: 0, atom: pos + 1 };\n        // First find the position in the child array\n        let i = 0, offset = 0;\n        for (let curPos = 0; i < this.children.length; i++) {\n            let child = this.children[i], end = curPos + child.size;\n            if (end > pos || child instanceof TrailingHackViewDesc) {\n                offset = pos - curPos;\n                break;\n            }\n            curPos = end;\n        }\n        // If this points into the middle of a child, call through\n        if (offset)\n            return this.children[i].domFromPos(offset - this.children[i].border, side);\n        // Go back if there were any zero-length widgets with side >= 0 before this point\n        for (let prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) { }\n        // Scan towards the first useable node\n        if (side <= 0) {\n            let prev, enter = true;\n            for (;; i--, enter = false) {\n                prev = i ? this.children[i - 1] : null;\n                if (!prev || prev.dom.parentNode == this.contentDOM)\n                    break;\n            }\n            if (prev && side && enter && !prev.border && !prev.domAtom)\n                return prev.domFromPos(prev.size, side);\n            return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };\n        }\n        else {\n            let next, enter = true;\n            for (;; i++, enter = false) {\n                next = i < this.children.length ? this.children[i] : null;\n                if (!next || next.dom.parentNode == this.contentDOM)\n                    break;\n            }\n            if (next && enter && !next.border && !next.domAtom)\n                return next.domFromPos(0, side);\n            return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };\n        }\n    }\n    // Used to find a DOM range in a single parent for a given changed\n    // range.\n    parseRange(from, to, base = 0) {\n        if (this.children.length == 0)\n            return { node: this.contentDOM, from, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };\n        let fromOffset = -1, toOffset = -1;\n        for (let offset = base, i = 0;; i++) {\n            let child = this.children[i], end = offset + child.size;\n            if (fromOffset == -1 && from <= end) {\n                let childBase = offset + child.border;\n                // FIXME maybe descend mark views to parse a narrower range?\n                if (from >= childBase && to <= end - child.border && child.node &&\n                    child.contentDOM && this.contentDOM.contains(child.contentDOM))\n                    return child.parseRange(from, to, childBase);\n                from = offset;\n                for (let j = i; j > 0; j--) {\n                    let prev = this.children[j - 1];\n                    if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {\n                        fromOffset = domIndex(prev.dom) + 1;\n                        break;\n                    }\n                    from -= prev.size;\n                }\n                if (fromOffset == -1)\n                    fromOffset = 0;\n            }\n            if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {\n                to = end;\n                for (let j = i + 1; j < this.children.length; j++) {\n                    let next = this.children[j];\n                    if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {\n                        toOffset = domIndex(next.dom);\n                        break;\n                    }\n                    to += next.size;\n                }\n                if (toOffset == -1)\n                    toOffset = this.contentDOM.childNodes.length;\n                break;\n            }\n            offset = end;\n        }\n        return { node: this.contentDOM, from, to, fromOffset, toOffset };\n    }\n    emptyChildAt(side) {\n        if (this.border || !this.contentDOM || !this.children.length)\n            return false;\n        let child = this.children[side < 0 ? 0 : this.children.length - 1];\n        return child.size == 0 || child.emptyChildAt(side);\n    }\n    domAfterPos(pos) {\n        let { node, offset } = this.domFromPos(pos, 0);\n        if (node.nodeType != 1 || offset == node.childNodes.length)\n            throw new RangeError(\"No node after pos \" + pos);\n        return node.childNodes[offset];\n    }\n    // View descs are responsible for setting any selection that falls\n    // entirely inside of them, so that custom implementations can do\n    // custom things with the selection. Note that this falls apart when\n    // a selection starts in such a node and ends in another, in which\n    // case we just use whatever domFromPos produces as a best effort.\n    setSelection(anchor, head, view, force = false) {\n        // If the selection falls entirely in a child, give it to that child\n        let from = Math.min(anchor, head), to = Math.max(anchor, head);\n        for (let i = 0, offset = 0; i < this.children.length; i++) {\n            let child = this.children[i], end = offset + child.size;\n            if (from > offset && to < end)\n                return child.setSelection(anchor - offset - child.border, head - offset - child.border, view, force);\n            offset = end;\n        }\n        let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);\n        let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);\n        let domSel = view.root.getSelection();\n        let selRange = view.domSelectionRange();\n        let brKludge = false;\n        // On Firefox, using Selection.collapse to put the cursor after a\n        // BR node for some reason doesn't always work (#1073). On Safari,\n        // the cursor sometimes inexplicable visually lags behind its\n        // reported position in such situations (#1092).\n        if ((gecko || safari) && anchor == head) {\n            let { node, offset } = anchorDOM;\n            if (node.nodeType == 3) {\n                brKludge = !!(offset && node.nodeValue[offset - 1] == \"\\n\");\n                // Issue #1128\n                if (brKludge && offset == node.nodeValue.length) {\n                    for (let scan = node, after; scan; scan = scan.parentNode) {\n                        if (after = scan.nextSibling) {\n                            if (after.nodeName == \"BR\")\n                                anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };\n                            break;\n                        }\n                        let desc = scan.pmViewDesc;\n                        if (desc && desc.node && desc.node.isBlock)\n                            break;\n                    }\n                }\n            }\n            else {\n                let prev = node.childNodes[offset - 1];\n                brKludge = prev && (prev.nodeName == \"BR\" || prev.contentEditable == \"false\");\n            }\n        }\n        // Firefox can act strangely when the selection is in front of an\n        // uneditable node. See #1163 and https://bugzilla.mozilla.org/show_bug.cgi?id=1709536\n        if (gecko && selRange.focusNode && selRange.focusNode != headDOM.node && selRange.focusNode.nodeType == 1) {\n            let after = selRange.focusNode.childNodes[selRange.focusOffset];\n            if (after && after.contentEditable == \"false\")\n                force = true;\n        }\n        if (!(force || brKludge && safari) &&\n            isEquivalentPosition(anchorDOM.node, anchorDOM.offset, selRange.anchorNode, selRange.anchorOffset) &&\n            isEquivalentPosition(headDOM.node, headDOM.offset, selRange.focusNode, selRange.focusOffset))\n            return;\n        // Selection.extend can be used to create an 'inverted' selection\n        // (one where the focus is before the anchor), but not all\n        // browsers support it yet.\n        let domSelExtended = false;\n        if ((domSel.extend || anchor == head) && !(brKludge && gecko)) {\n            domSel.collapse(anchorDOM.node, anchorDOM.offset);\n            try {\n                if (anchor != head)\n                    domSel.extend(headDOM.node, headDOM.offset);\n                domSelExtended = true;\n            }\n            catch (_) {\n                // In some cases with Chrome the selection is empty after calling\n                // collapse, even when it should be valid. This appears to be a bug, but\n                // it is difficult to isolate. If this happens fallback to the old path\n                // without using extend.\n                // Similarly, this could crash on Safari if the editor is hidden, and\n                // there was no selection.\n            }\n        }\n        if (!domSelExtended) {\n            if (anchor > head) {\n                let tmp = anchorDOM;\n                anchorDOM = headDOM;\n                headDOM = tmp;\n            }\n            let range = document.createRange();\n            range.setEnd(headDOM.node, headDOM.offset);\n            range.setStart(anchorDOM.node, anchorDOM.offset);\n            domSel.removeAllRanges();\n            domSel.addRange(range);\n        }\n    }\n    ignoreMutation(mutation) {\n        return !this.contentDOM && mutation.type != \"selection\";\n    }\n    get contentLost() {\n        return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);\n    }\n    // Remove a subtree of the element tree that has been touched\n    // by a DOM change, so that the next update will redraw it.\n    markDirty(from, to) {\n        for (let offset = 0, i = 0; i < this.children.length; i++) {\n            let child = this.children[i], end = offset + child.size;\n            if (offset == end ? from <= end && to >= offset : from < end && to > offset) {\n                let startInside = offset + child.border, endInside = end - child.border;\n                if (from >= startInside && to <= endInside) {\n                    this.dirty = from == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;\n                    if (from == startInside && to == endInside &&\n                        (child.contentLost || child.dom.parentNode != this.contentDOM))\n                        child.dirty = NODE_DIRTY;\n                    else\n                        child.markDirty(from - startInside, to - startInside);\n                    return;\n                }\n                else {\n                    child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length\n                        ? CONTENT_DIRTY : NODE_DIRTY;\n                }\n            }\n            offset = end;\n        }\n        this.dirty = CONTENT_DIRTY;\n    }\n    markParentsDirty() {\n        let level = 1;\n        for (let node = this.parent; node; node = node.parent, level++) {\n            let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;\n            if (node.dirty < dirty)\n                node.dirty = dirty;\n        }\n    }\n    get domAtom() { return false; }\n    get ignoreForCoords() { return false; }\n    get ignoreForSelection() { return false; }\n    isText(text) { return false; }\n}\n// A widget desc represents a widget decoration, which is a DOM node\n// drawn between the document nodes.\nclass WidgetViewDesc extends ViewDesc {\n    constructor(parent, widget, view, pos) {\n        let self, dom = widget.type.toDOM;\n        if (typeof dom == \"function\")\n            dom = dom(view, () => {\n                if (!self)\n                    return pos;\n                if (self.parent)\n                    return self.parent.posBeforeChild(self);\n            });\n        if (!widget.type.spec.raw) {\n            if (dom.nodeType != 1) {\n                let wrap = document.createElement(\"span\");\n                wrap.appendChild(dom);\n                dom = wrap;\n            }\n            dom.contentEditable = \"false\";\n            dom.classList.add(\"ProseMirror-widget\");\n        }\n        super(parent, [], dom, null);\n        this.widget = widget;\n        this.widget = widget;\n        self = this;\n    }\n    matchesWidget(widget) {\n        return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);\n    }\n    parseRule() { return { ignore: true }; }\n    stopEvent(event) {\n        let stop = this.widget.spec.stopEvent;\n        return stop ? stop(event) : false;\n    }\n    ignoreMutation(mutation) {\n        return mutation.type != \"selection\" || this.widget.spec.ignoreSelection;\n    }\n    destroy() {\n        this.widget.type.destroy(this.dom);\n        super.destroy();\n    }\n    get domAtom() { return true; }\n    get ignoreForSelection() { return !!this.widget.type.spec.relaxedSide; }\n    get side() { return this.widget.type.side; }\n}\nclass CompositionViewDesc extends ViewDesc {\n    constructor(parent, dom, textDOM, text) {\n        super(parent, [], dom, null);\n        this.textDOM = textDOM;\n        this.text = text;\n    }\n    get size() { return this.text.length; }\n    localPosFromDOM(dom, offset) {\n        if (dom != this.textDOM)\n            return this.posAtStart + (offset ? this.size : 0);\n        return this.posAtStart + offset;\n    }\n    domFromPos(pos) {\n        return { node: this.textDOM, offset: pos };\n    }\n    ignoreMutation(mut) {\n        return mut.type === 'characterData' && mut.target.nodeValue == mut.oldValue;\n    }\n}\n// A mark desc represents a mark. May have multiple children,\n// depending on how the mark is split. Note that marks are drawn using\n// a fixed nesting order, for simplicity and predictability, so in\n// some cases they will be split more often than would appear\n// necessary.\nclass MarkViewDesc extends ViewDesc {\n    constructor(parent, mark, dom, contentDOM, spec) {\n        super(parent, [], dom, contentDOM);\n        this.mark = mark;\n        this.spec = spec;\n    }\n    static create(parent, mark, inline, view) {\n        let custom = view.nodeViews[mark.type.name];\n        let spec = custom && custom(mark, view, inline);\n        if (!spec || !spec.dom)\n            spec = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline), null, mark.attrs);\n        return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom, spec);\n    }\n    parseRule() {\n        if ((this.dirty & NODE_DIRTY) || this.mark.type.spec.reparseInView)\n            return null;\n        return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };\n    }\n    matchesMark(mark) { return this.dirty != NODE_DIRTY && this.mark.eq(mark); }\n    markDirty(from, to) {\n        super.markDirty(from, to);\n        // Move dirty info to nearest node view\n        if (this.dirty != NOT_DIRTY) {\n            let parent = this.parent;\n            while (!parent.node)\n                parent = parent.parent;\n            if (parent.dirty < this.dirty)\n                parent.dirty = this.dirty;\n            this.dirty = NOT_DIRTY;\n        }\n    }\n    slice(from, to, view) {\n        let copy = MarkViewDesc.create(this.parent, this.mark, true, view);\n        let nodes = this.children, size = this.size;\n        if (to < size)\n            nodes = replaceNodes(nodes, to, size, view);\n        if (from > 0)\n            nodes = replaceNodes(nodes, 0, from, view);\n        for (let i = 0; i < nodes.length; i++)\n            nodes[i].parent = copy;\n        copy.children = nodes;\n        return copy;\n    }\n    ignoreMutation(mutation) {\n        return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);\n    }\n    destroy() {\n        if (this.spec.destroy)\n            this.spec.destroy();\n        super.destroy();\n    }\n}\n// Node view descs are the main, most common type of view desc, and\n// correspond to an actual node in the document. Unlike mark descs,\n// they populate their child array themselves.\nclass NodeViewDesc extends ViewDesc {\n    constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {\n        super(parent, [], dom, contentDOM);\n        this.node = node;\n        this.outerDeco = outerDeco;\n        this.innerDeco = innerDeco;\n        this.nodeDOM = nodeDOM;\n    }\n    // By default, a node is rendered using the `toDOM` method from the\n    // node type spec. But client code can use the `nodeViews` spec to\n    // supply a custom node view, which can influence various aspects of\n    // the way the node works.\n    //\n    // (Using subclassing for this was intentionally decided against,\n    // since it'd require exposing a whole slew of finicky\n    // implementation details to the user code that they probably will\n    // never need.)\n    static create(parent, node, outerDeco, innerDeco, view, pos) {\n        let custom = view.nodeViews[node.type.name], descObj;\n        let spec = custom && custom(node, view, () => {\n            // (This is a function that allows the custom view to find its\n            // own position)\n            if (!descObj)\n                return pos;\n            if (descObj.parent)\n                return descObj.parent.posBeforeChild(descObj);\n        }, outerDeco, innerDeco);\n        let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;\n        if (node.isText) {\n            if (!dom)\n                dom = document.createTextNode(node.text);\n            else if (dom.nodeType != 3)\n                throw new RangeError(\"Text must be rendered as a DOM text node\");\n        }\n        else if (!dom) {\n            let spec = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.renderSpec(document, node.type.spec.toDOM(node), null, node.attrs);\n            ({ dom, contentDOM } = spec);\n        }\n        if (!contentDOM && !node.isText && dom.nodeName != \"BR\") { // Chrome gets confused by <br contenteditable=false>\n            if (!dom.hasAttribute(\"contenteditable\"))\n                dom.contentEditable = \"false\";\n            if (node.type.spec.draggable)\n                dom.draggable = true;\n        }\n        let nodeDOM = dom;\n        dom = applyOuterDeco(dom, outerDeco, node);\n        if (spec)\n            return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);\n        else if (node.isText)\n            return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);\n        else\n            return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);\n    }\n    parseRule() {\n        // Experimental kludge to allow opt-in re-parsing of nodes\n        if (this.node.type.spec.reparseInView)\n            return null;\n        // FIXME the assumption that this can always return the current\n        // attrs means that if the user somehow manages to change the\n        // attrs in the dom, that won't be picked up. Not entirely sure\n        // whether this is a problem\n        let rule = { node: this.node.type.name, attrs: this.node.attrs };\n        if (this.node.type.whitespace == \"pre\")\n            rule.preserveWhitespace = \"full\";\n        if (!this.contentDOM) {\n            rule.getContent = () => this.node.content;\n        }\n        else if (!this.contentLost) {\n            rule.contentElement = this.contentDOM;\n        }\n        else {\n            // Chrome likes to randomly recreate parent nodes when\n            // backspacing things. When that happens, this tries to find the\n            // new parent.\n            for (let i = this.children.length - 1; i >= 0; i--) {\n                let child = this.children[i];\n                if (this.dom.contains(child.dom.parentNode)) {\n                    rule.contentElement = child.dom.parentNode;\n                    break;\n                }\n            }\n            if (!rule.contentElement)\n                rule.getContent = () => prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n        }\n        return rule;\n    }\n    matchesNode(node, outerDeco, innerDeco) {\n        return this.dirty == NOT_DIRTY && node.eq(this.node) &&\n            sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);\n    }\n    get size() { return this.node.nodeSize; }\n    get border() { return this.node.isLeaf ? 0 : 1; }\n    // Syncs `this.children` to match `this.node.content` and the local\n    // decorations, possibly introducing nesting for marks. Then, in a\n    // separate step, syncs the DOM inside `this.contentDOM` to\n    // `this.children`.\n    updateChildren(view, pos) {\n        let inline = this.node.inlineContent, off = pos;\n        let composition = view.composing ? this.localCompositionInfo(view, pos) : null;\n        let localComposition = composition && composition.pos > -1 ? composition : null;\n        let compositionInChild = composition && composition.pos < 0;\n        let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);\n        iterDeco(this.node, this.innerDeco, (widget, i, insideNode) => {\n            if (widget.spec.marks)\n                updater.syncToMarks(widget.spec.marks, inline, view, i);\n            else if (widget.type.side >= 0 && !insideNode)\n                updater.syncToMarks(i == this.node.childCount ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark.none : this.node.child(i).marks, inline, view, i);\n            // If the next node is a desc matching this widget, reuse it,\n            // otherwise insert the widget as a new view desc.\n            updater.placeWidget(widget, view, off);\n        }, (child, outerDeco, innerDeco, i) => {\n            // Make sure the wrapping mark descs match the node's marks.\n            updater.syncToMarks(child.marks, inline, view, i);\n            // Try several strategies for drawing this node\n            let compIndex;\n            if (updater.findNodeMatch(child, outerDeco, innerDeco, i)) ;\n            else if (compositionInChild && view.state.selection.from > off &&\n                view.state.selection.to < off + child.nodeSize &&\n                (compIndex = updater.findIndexWithChild(composition.node)) > -1 &&\n                updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ;\n            else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i, off)) ;\n            else {\n                // Add it as a new view\n                updater.addNode(child, outerDeco, innerDeco, view, off);\n            }\n            off += child.nodeSize;\n        });\n        // Drop all remaining descs after the current position.\n        updater.syncToMarks([], inline, view, 0);\n        if (this.node.isTextblock)\n            updater.addTextblockHacks();\n        updater.destroyRest();\n        // Sync the DOM if anything changed\n        if (updater.changed || this.dirty == CONTENT_DIRTY) {\n            // May have to protect focused DOM from being changed if a composition is active\n            if (localComposition)\n                this.protectLocalComposition(view, localComposition);\n            renderDescs(this.contentDOM, this.children, view);\n            if (ios)\n                iosHacks(this.dom);\n        }\n    }\n    localCompositionInfo(view, pos) {\n        // Only do something if both the selection and a focused text node\n        // are inside of this node\n        let { from, to } = view.state.selection;\n        if (!(view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) || from < pos || to > pos + this.node.content.size)\n            return null;\n        let textNode = view.input.compositionNode;\n        if (!textNode || !this.dom.contains(textNode.parentNode))\n            return null;\n        if (this.node.inlineContent) {\n            // Find the text in the focused node in the node, stop if it's not\n            // there (may have been modified through other means, in which\n            // case it should overwritten)\n            let text = textNode.nodeValue;\n            let textPos = findTextInFragment(this.node.content, text, from - pos, to - pos);\n            return textPos < 0 ? null : { node: textNode, pos: textPos, text };\n        }\n        else {\n            return { node: textNode, pos: -1, text: \"\" };\n        }\n    }\n    protectLocalComposition(view, { node, pos, text }) {\n        // The node is already part of a local view desc, leave it there\n        if (this.getDesc(node))\n            return;\n        // Create a composition view for the orphaned nodes\n        let topNode = node;\n        for (;; topNode = topNode.parentNode) {\n            if (topNode.parentNode == this.contentDOM)\n                break;\n            while (topNode.previousSibling)\n                topNode.parentNode.removeChild(topNode.previousSibling);\n            while (topNode.nextSibling)\n                topNode.parentNode.removeChild(topNode.nextSibling);\n            if (topNode.pmViewDesc)\n                topNode.pmViewDesc = undefined;\n        }\n        let desc = new CompositionViewDesc(this, topNode, node, text);\n        view.input.compositionNodes.push(desc);\n        // Patch up this.children to contain the composition view\n        this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);\n    }\n    // If this desc must be updated to match the given node decoration,\n    // do so and return true.\n    update(node, outerDeco, innerDeco, view) {\n        if (this.dirty == NODE_DIRTY ||\n            !node.sameMarkup(this.node))\n            return false;\n        this.updateInner(node, outerDeco, innerDeco, view);\n        return true;\n    }\n    updateInner(node, outerDeco, innerDeco, view) {\n        this.updateOuterDeco(outerDeco);\n        this.node = node;\n        this.innerDeco = innerDeco;\n        if (this.contentDOM)\n            this.updateChildren(view, this.posAtStart);\n        this.dirty = NOT_DIRTY;\n    }\n    updateOuterDeco(outerDeco) {\n        if (sameOuterDeco(outerDeco, this.outerDeco))\n            return;\n        let needsWrap = this.nodeDOM.nodeType != 1;\n        let oldDOM = this.dom;\n        this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));\n        if (this.dom != oldDOM) {\n            oldDOM.pmViewDesc = undefined;\n            this.dom.pmViewDesc = this;\n        }\n        this.outerDeco = outerDeco;\n    }\n    // Mark this node as being the selected node.\n    selectNode() {\n        if (this.nodeDOM.nodeType == 1) {\n            this.nodeDOM.classList.add(\"ProseMirror-selectednode\");\n            if (this.contentDOM || !this.node.type.spec.draggable)\n                this.nodeDOM.draggable = true;\n        }\n    }\n    // Remove selected node marking from this node.\n    deselectNode() {\n        if (this.nodeDOM.nodeType == 1) {\n            this.nodeDOM.classList.remove(\"ProseMirror-selectednode\");\n            if (this.contentDOM || !this.node.type.spec.draggable)\n                this.nodeDOM.removeAttribute(\"draggable\");\n        }\n    }\n    get domAtom() { return this.node.isAtom; }\n}\n// Create a view desc for the top-level document node, to be exported\n// and used by the view class.\nfunction docViewDesc(doc, outerDeco, innerDeco, dom, view) {\n    applyOuterDeco(dom, outerDeco, doc);\n    let docView = new NodeViewDesc(undefined, doc, outerDeco, innerDeco, dom, dom, dom, view, 0);\n    if (docView.contentDOM)\n        docView.updateChildren(view, 0);\n    return docView;\n}\nclass TextViewDesc extends NodeViewDesc {\n    constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {\n        super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);\n    }\n    parseRule() {\n        let skip = this.nodeDOM.parentNode;\n        while (skip && skip != this.dom && !skip.pmIsDeco)\n            skip = skip.parentNode;\n        return { skip: (skip || true) };\n    }\n    update(node, outerDeco, innerDeco, view) {\n        if (this.dirty == NODE_DIRTY || (this.dirty != NOT_DIRTY && !this.inParent()) ||\n            !node.sameMarkup(this.node))\n            return false;\n        this.updateOuterDeco(outerDeco);\n        if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {\n            this.nodeDOM.nodeValue = node.text;\n            if (view.trackWrites == this.nodeDOM)\n                view.trackWrites = null;\n        }\n        this.node = node;\n        this.dirty = NOT_DIRTY;\n        return true;\n    }\n    inParent() {\n        let parentDOM = this.parent.contentDOM;\n        for (let n = this.nodeDOM; n; n = n.parentNode)\n            if (n == parentDOM)\n                return true;\n        return false;\n    }\n    domFromPos(pos) {\n        return { node: this.nodeDOM, offset: pos };\n    }\n    localPosFromDOM(dom, offset, bias) {\n        if (dom == this.nodeDOM)\n            return this.posAtStart + Math.min(offset, this.node.text.length);\n        return super.localPosFromDOM(dom, offset, bias);\n    }\n    ignoreMutation(mutation) {\n        return mutation.type != \"characterData\" && mutation.type != \"selection\";\n    }\n    slice(from, to, view) {\n        let node = this.node.cut(from, to), dom = document.createTextNode(node.text);\n        return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);\n    }\n    markDirty(from, to) {\n        super.markDirty(from, to);\n        if (this.dom != this.nodeDOM && (from == 0 || to == this.nodeDOM.nodeValue.length))\n            this.dirty = NODE_DIRTY;\n    }\n    get domAtom() { return false; }\n    isText(text) { return this.node.text == text; }\n}\n// A dummy desc used to tag trailing BR or IMG nodes created to work\n// around contentEditable terribleness.\nclass TrailingHackViewDesc extends ViewDesc {\n    parseRule() { return { ignore: true }; }\n    matchesHack(nodeName) { return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName; }\n    get domAtom() { return true; }\n    get ignoreForCoords() { return this.dom.nodeName == \"IMG\"; }\n}\n// A separate subclass is used for customized node views, so that the\n// extra checks only have to be made for nodes that are actually\n// customized.\nclass CustomNodeViewDesc extends NodeViewDesc {\n    constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {\n        super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);\n        this.spec = spec;\n    }\n    // A custom `update` method gets to decide whether the update goes\n    // through. If it does, and there's a `contentDOM` node, our logic\n    // updates the children.\n    update(node, outerDeco, innerDeco, view) {\n        if (this.dirty == NODE_DIRTY)\n            return false;\n        if (this.spec.update && (this.node.type == node.type || this.spec.multiType)) {\n            let result = this.spec.update(node, outerDeco, innerDeco);\n            if (result)\n                this.updateInner(node, outerDeco, innerDeco, view);\n            return result;\n        }\n        else if (!this.contentDOM && !node.isLeaf) {\n            return false;\n        }\n        else {\n            return super.update(node, outerDeco, innerDeco, view);\n        }\n    }\n    selectNode() {\n        this.spec.selectNode ? this.spec.selectNode() : super.selectNode();\n    }\n    deselectNode() {\n        this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();\n    }\n    setSelection(anchor, head, view, force) {\n        this.spec.setSelection ? this.spec.setSelection(anchor, head, view.root)\n            : super.setSelection(anchor, head, view, force);\n    }\n    destroy() {\n        if (this.spec.destroy)\n            this.spec.destroy();\n        super.destroy();\n    }\n    stopEvent(event) {\n        return this.spec.stopEvent ? this.spec.stopEvent(event) : false;\n    }\n    ignoreMutation(mutation) {\n        return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);\n    }\n}\n// Sync the content of the given DOM node with the nodes associated\n// with the given array of view descs, recursing into mark descs\n// because this should sync the subtree for a whole node at a time.\nfunction renderDescs(parentDOM, descs, view) {\n    let dom = parentDOM.firstChild, written = false;\n    for (let i = 0; i < descs.length; i++) {\n        let desc = descs[i], childDOM = desc.dom;\n        if (childDOM.parentNode == parentDOM) {\n            while (childDOM != dom) {\n                dom = rm(dom);\n                written = true;\n            }\n            dom = dom.nextSibling;\n        }\n        else {\n            written = true;\n            parentDOM.insertBefore(childDOM, dom);\n        }\n        if (desc instanceof MarkViewDesc) {\n            let pos = dom ? dom.previousSibling : parentDOM.lastChild;\n            renderDescs(desc.contentDOM, desc.children, view);\n            dom = pos ? pos.nextSibling : parentDOM.firstChild;\n        }\n    }\n    while (dom) {\n        dom = rm(dom);\n        written = true;\n    }\n    if (written && view.trackWrites == parentDOM)\n        view.trackWrites = null;\n}\nconst OuterDecoLevel = function (nodeName) {\n    if (nodeName)\n        this.nodeName = nodeName;\n};\nOuterDecoLevel.prototype = Object.create(null);\nconst noDeco = [new OuterDecoLevel];\nfunction computeOuterDeco(outerDeco, node, needsWrap) {\n    if (outerDeco.length == 0)\n        return noDeco;\n    let top = needsWrap ? noDeco[0] : new OuterDecoLevel, result = [top];\n    for (let i = 0; i < outerDeco.length; i++) {\n        let attrs = outerDeco[i].type.attrs;\n        if (!attrs)\n            continue;\n        if (attrs.nodeName)\n            result.push(top = new OuterDecoLevel(attrs.nodeName));\n        for (let name in attrs) {\n            let val = attrs[name];\n            if (val == null)\n                continue;\n            if (needsWrap && result.length == 1)\n                result.push(top = new OuterDecoLevel(node.isInline ? \"span\" : \"div\"));\n            if (name == \"class\")\n                top.class = (top.class ? top.class + \" \" : \"\") + val;\n            else if (name == \"style\")\n                top.style = (top.style ? top.style + \";\" : \"\") + val;\n            else if (name != \"nodeName\")\n                top[name] = val;\n        }\n    }\n    return result;\n}\nfunction patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {\n    // Shortcut for trivial case\n    if (prevComputed == noDeco && curComputed == noDeco)\n        return nodeDOM;\n    let curDOM = nodeDOM;\n    for (let i = 0; i < curComputed.length; i++) {\n        let deco = curComputed[i], prev = prevComputed[i];\n        if (i) {\n            let parent;\n            if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM &&\n                (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {\n                curDOM = parent;\n            }\n            else {\n                parent = document.createElement(deco.nodeName);\n                parent.pmIsDeco = true;\n                parent.appendChild(curDOM);\n                prev = noDeco[0];\n                curDOM = parent;\n            }\n        }\n        patchAttributes(curDOM, prev || noDeco[0], deco);\n    }\n    return curDOM;\n}\nfunction patchAttributes(dom, prev, cur) {\n    for (let name in prev)\n        if (name != \"class\" && name != \"style\" && name != \"nodeName\" && !(name in cur))\n            dom.removeAttribute(name);\n    for (let name in cur)\n        if (name != \"class\" && name != \"style\" && name != \"nodeName\" && cur[name] != prev[name])\n            dom.setAttribute(name, cur[name]);\n    if (prev.class != cur.class) {\n        let prevList = prev.class ? prev.class.split(\" \").filter(Boolean) : [];\n        let curList = cur.class ? cur.class.split(\" \").filter(Boolean) : [];\n        for (let i = 0; i < prevList.length; i++)\n            if (curList.indexOf(prevList[i]) == -1)\n                dom.classList.remove(prevList[i]);\n        for (let i = 0; i < curList.length; i++)\n            if (prevList.indexOf(curList[i]) == -1)\n                dom.classList.add(curList[i]);\n        if (dom.classList.length == 0)\n            dom.removeAttribute(\"class\");\n    }\n    if (prev.style != cur.style) {\n        if (prev.style) {\n            let prop = /\\s*([\\w\\-\\xa1-\\uffff]+)\\s*:(?:\"(?:\\\\.|[^\"])*\"|'(?:\\\\.|[^'])*'|\\(.*?\\)|[^;])*/g, m;\n            while (m = prop.exec(prev.style))\n                dom.style.removeProperty(m[1]);\n        }\n        if (cur.style)\n            dom.style.cssText += cur.style;\n    }\n}\nfunction applyOuterDeco(dom, deco, node) {\n    return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));\n}\nfunction sameOuterDeco(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (!a[i].type.eq(b[i].type))\n            return false;\n    return true;\n}\n// Remove a DOM node and return its next sibling.\nfunction rm(dom) {\n    let next = dom.nextSibling;\n    dom.parentNode.removeChild(dom);\n    return next;\n}\n// Helper class for incrementally updating a tree of mark descs and\n// the widget and node descs inside of them.\nclass ViewTreeUpdater {\n    constructor(top, lock, view) {\n        this.lock = lock;\n        this.view = view;\n        // Index into `this.top`'s child array, represents the current\n        // update position.\n        this.index = 0;\n        // When entering a mark, the current top and index are pushed\n        // onto this.\n        this.stack = [];\n        // Tracks whether anything was changed\n        this.changed = false;\n        this.top = top;\n        this.preMatch = preMatch(top.node.content, top);\n    }\n    // Destroy and remove the children between the given indices in\n    // `this.top`.\n    destroyBetween(start, end) {\n        if (start == end)\n            return;\n        for (let i = start; i < end; i++)\n            this.top.children[i].destroy();\n        this.top.children.splice(start, end - start);\n        this.changed = true;\n    }\n    // Destroy all remaining children in `this.top`.\n    destroyRest() {\n        this.destroyBetween(this.index, this.top.children.length);\n    }\n    // Sync the current stack of mark descs with the given array of\n    // marks, reusing existing mark descs when possible.\n    syncToMarks(marks, inline, view, parentIndex) {\n        let keep = 0, depth = this.stack.length >> 1;\n        let maxKeep = Math.min(depth, marks.length);\n        while (keep < maxKeep &&\n            (keep == depth - 1 ? this.top : this.stack[(keep + 1) << 1])\n                .matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)\n            keep++;\n        while (keep < depth) {\n            this.destroyRest();\n            this.top.dirty = NOT_DIRTY;\n            this.index = this.stack.pop();\n            this.top = this.stack.pop();\n            depth--;\n        }\n        while (depth < marks.length) {\n            this.stack.push(this.top, this.index + 1);\n            let found = -1, scanTo = this.top.children.length;\n            if (parentIndex < this.preMatch.index)\n                scanTo = Math.min(this.index + 3, scanTo);\n            for (let i = this.index; i < scanTo; i++) {\n                let next = this.top.children[i];\n                if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {\n                    found = i;\n                    break;\n                }\n            }\n            if (found > -1) {\n                if (found > this.index) {\n                    this.changed = true;\n                    this.destroyBetween(this.index, found);\n                }\n                this.top = this.top.children[this.index];\n            }\n            else {\n                let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);\n                this.top.children.splice(this.index, 0, markDesc);\n                this.top = markDesc;\n                this.changed = true;\n            }\n            this.index = 0;\n            depth++;\n        }\n    }\n    // Try to find a node desc matching the given data. Skip over it and\n    // return true when successful.\n    findNodeMatch(node, outerDeco, innerDeco, index) {\n        let found = -1, targetDesc;\n        if (index >= this.preMatch.index &&\n            (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top &&\n            targetDesc.matchesNode(node, outerDeco, innerDeco)) {\n            found = this.top.children.indexOf(targetDesc, this.index);\n        }\n        else {\n            for (let i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {\n                let child = this.top.children[i];\n                if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {\n                    found = i;\n                    break;\n                }\n            }\n        }\n        if (found < 0)\n            return false;\n        this.destroyBetween(this.index, found);\n        this.index++;\n        return true;\n    }\n    updateNodeAt(node, outerDeco, innerDeco, index, view) {\n        let child = this.top.children[index];\n        if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)\n            child.dirty = CONTENT_DIRTY;\n        if (!child.update(node, outerDeco, innerDeco, view))\n            return false;\n        this.destroyBetween(this.index, index);\n        this.index++;\n        return true;\n    }\n    findIndexWithChild(domNode) {\n        for (;;) {\n            let parent = domNode.parentNode;\n            if (!parent)\n                return -1;\n            if (parent == this.top.contentDOM) {\n                let desc = domNode.pmViewDesc;\n                if (desc)\n                    for (let i = this.index; i < this.top.children.length; i++) {\n                        if (this.top.children[i] == desc)\n                            return i;\n                    }\n                return -1;\n            }\n            domNode = parent;\n        }\n    }\n    // Try to update the next node, if any, to the given data. Checks\n    // pre-matches to avoid overwriting nodes that could still be used.\n    updateNextNode(node, outerDeco, innerDeco, view, index, pos) {\n        for (let i = this.index; i < this.top.children.length; i++) {\n            let next = this.top.children[i];\n            if (next instanceof NodeViewDesc) {\n                let preMatch = this.preMatch.matched.get(next);\n                if (preMatch != null && preMatch != index)\n                    return false;\n                let nextDOM = next.dom, updated;\n                // Can't update if nextDOM is or contains this.lock, except if\n                // it's a text node whose content already matches the new text\n                // and whose decorations match the new ones.\n                let locked = this.isLocked(nextDOM) &&\n                    !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text &&\n                        next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));\n                if (!locked && next.update(node, outerDeco, innerDeco, view)) {\n                    this.destroyBetween(this.index, i);\n                    if (next.dom != nextDOM)\n                        this.changed = true;\n                    this.index++;\n                    return true;\n                }\n                else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {\n                    this.destroyBetween(this.index, i);\n                    this.top.children[this.index] = updated;\n                    if (updated.contentDOM) {\n                        updated.dirty = CONTENT_DIRTY;\n                        updated.updateChildren(view, pos + 1);\n                        updated.dirty = NOT_DIRTY;\n                    }\n                    this.changed = true;\n                    this.index++;\n                    return true;\n                }\n                break;\n            }\n        }\n        return false;\n    }\n    // When a node with content is replaced by a different node with\n    // identical content, move over its children.\n    recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {\n        if (next.dirty || node.isAtom || !next.children.length ||\n            !next.node.content.eq(node.content) ||\n            !sameOuterDeco(outerDeco, next.outerDeco) || !innerDeco.eq(next.innerDeco))\n            return null;\n        let wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);\n        if (wrapper.contentDOM) {\n            wrapper.children = next.children;\n            next.children = [];\n            for (let ch of wrapper.children)\n                ch.parent = wrapper;\n        }\n        next.destroy();\n        return wrapper;\n    }\n    // Insert the node as a newly created node desc.\n    addNode(node, outerDeco, innerDeco, view, pos) {\n        let desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);\n        if (desc.contentDOM)\n            desc.updateChildren(view, pos + 1);\n        this.top.children.splice(this.index++, 0, desc);\n        this.changed = true;\n    }\n    placeWidget(widget, view, pos) {\n        let next = this.index < this.top.children.length ? this.top.children[this.index] : null;\n        if (next && next.matchesWidget(widget) &&\n            (widget == next.widget || !next.widget.type.toDOM.parentNode)) {\n            this.index++;\n        }\n        else {\n            let desc = new WidgetViewDesc(this.top, widget, view, pos);\n            this.top.children.splice(this.index++, 0, desc);\n            this.changed = true;\n        }\n    }\n    // Make sure a textblock looks and behaves correctly in\n    // contentEditable.\n    addTextblockHacks() {\n        let lastChild = this.top.children[this.index - 1], parent = this.top;\n        while (lastChild instanceof MarkViewDesc) {\n            parent = lastChild;\n            lastChild = parent.children[parent.children.length - 1];\n        }\n        if (!lastChild || // Empty textblock\n            !(lastChild instanceof TextViewDesc) ||\n            /\\n$/.test(lastChild.node.text) ||\n            (this.view.requiresGeckoHackNode && /\\s$/.test(lastChild.node.text))) {\n            // Avoid bugs in Safari's cursor drawing (#1165) and Chrome's mouse selection (#1152)\n            if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == \"false\")\n                this.addHackNode(\"IMG\", parent);\n            this.addHackNode(\"BR\", this.top);\n        }\n    }\n    addHackNode(nodeName, parent) {\n        if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {\n            this.index++;\n        }\n        else {\n            let dom = document.createElement(nodeName);\n            if (nodeName == \"IMG\") {\n                dom.className = \"ProseMirror-separator\";\n                dom.alt = \"\";\n            }\n            if (nodeName == \"BR\")\n                dom.className = \"ProseMirror-trailingBreak\";\n            let hack = new TrailingHackViewDesc(this.top, [], dom, null);\n            if (parent != this.top)\n                parent.children.push(hack);\n            else\n                parent.children.splice(this.index++, 0, hack);\n            this.changed = true;\n        }\n    }\n    isLocked(node) {\n        return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));\n    }\n}\n// Iterate from the end of the fragment and array of descs to find\n// directly matching ones, in order to avoid overeagerly reusing those\n// for other nodes.\nfunction preMatch(frag, parentDesc) {\n    let curDesc = parentDesc, descI = curDesc.children.length;\n    let fI = frag.childCount, matched = new Map, matches = [];\n    outer: while (fI > 0) {\n        let desc;\n        for (;;) {\n            if (descI) {\n                let next = curDesc.children[descI - 1];\n                if (next instanceof MarkViewDesc) {\n                    curDesc = next;\n                    descI = next.children.length;\n                }\n                else {\n                    desc = next;\n                    descI--;\n                    break;\n                }\n            }\n            else if (curDesc == parentDesc) {\n                break outer;\n            }\n            else {\n                descI = curDesc.parent.children.indexOf(curDesc);\n                curDesc = curDesc.parent;\n            }\n        }\n        let node = desc.node;\n        if (!node)\n            continue;\n        if (node != frag.child(fI - 1))\n            break;\n        --fI;\n        matched.set(desc, fI);\n        matches.push(desc);\n    }\n    return { index: fI, matched, matches: matches.reverse() };\n}\nfunction compareSide(a, b) {\n    return a.type.side - b.type.side;\n}\n// This function abstracts iterating over the nodes and decorations in\n// a fragment. Calls `onNode` for each node, with its local and child\n// decorations. Splits text nodes when there is a decoration starting\n// or ending inside of them. Calls `onWidget` for each widget.\nfunction iterDeco(parent, deco, onWidget, onNode) {\n    let locals = deco.locals(parent), offset = 0;\n    // Simple, cheap variant for when there are no local decorations\n    if (locals.length == 0) {\n        for (let i = 0; i < parent.childCount; i++) {\n            let child = parent.child(i);\n            onNode(child, locals, deco.forChild(offset, child), i);\n            offset += child.nodeSize;\n        }\n        return;\n    }\n    let decoIndex = 0, active = [], restNode = null;\n    for (let parentIndex = 0;;) {\n        let widget, widgets;\n        while (decoIndex < locals.length && locals[decoIndex].to == offset) {\n            let next = locals[decoIndex++];\n            if (next.widget) {\n                if (!widget)\n                    widget = next;\n                else\n                    (widgets || (widgets = [widget])).push(next);\n            }\n        }\n        if (widget) {\n            if (widgets) {\n                widgets.sort(compareSide);\n                for (let i = 0; i < widgets.length; i++)\n                    onWidget(widgets[i], parentIndex, !!restNode);\n            }\n            else {\n                onWidget(widget, parentIndex, !!restNode);\n            }\n        }\n        let child, index;\n        if (restNode) {\n            index = -1;\n            child = restNode;\n            restNode = null;\n        }\n        else if (parentIndex < parent.childCount) {\n            index = parentIndex;\n            child = parent.child(parentIndex++);\n        }\n        else {\n            break;\n        }\n        for (let i = 0; i < active.length; i++)\n            if (active[i].to <= offset)\n                active.splice(i--, 1);\n        while (decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset)\n            active.push(locals[decoIndex++]);\n        let end = offset + child.nodeSize;\n        if (child.isText) {\n            let cutAt = end;\n            if (decoIndex < locals.length && locals[decoIndex].from < cutAt)\n                cutAt = locals[decoIndex].from;\n            for (let i = 0; i < active.length; i++)\n                if (active[i].to < cutAt)\n                    cutAt = active[i].to;\n            if (cutAt < end) {\n                restNode = child.cut(cutAt - offset);\n                child = child.cut(0, cutAt - offset);\n                end = cutAt;\n                index = -1;\n            }\n        }\n        else {\n            while (decoIndex < locals.length && locals[decoIndex].to < end)\n                decoIndex++;\n        }\n        let outerDeco = child.isInline && !child.isLeaf ? active.filter(d => !d.inline) : active.slice();\n        onNode(child, outerDeco, deco.forChild(offset, child), index);\n        offset = end;\n    }\n}\n// List markers in Mobile Safari will mysteriously disappear\n// sometimes. This works around that.\nfunction iosHacks(dom) {\n    if (dom.nodeName == \"UL\" || dom.nodeName == \"OL\") {\n        let oldCSS = dom.style.cssText;\n        dom.style.cssText = oldCSS + \"; list-style: square !important\";\n        window.getComputedStyle(dom).listStyle;\n        dom.style.cssText = oldCSS;\n    }\n}\n// Find a piece of text in an inline fragment, overlapping from-to\nfunction findTextInFragment(frag, text, from, to) {\n    for (let i = 0, pos = 0; i < frag.childCount && pos <= to;) {\n        let child = frag.child(i++), childStart = pos;\n        pos += child.nodeSize;\n        if (!child.isText)\n            continue;\n        let str = child.text;\n        while (i < frag.childCount) {\n            let next = frag.child(i++);\n            pos += next.nodeSize;\n            if (!next.isText)\n                break;\n            str += next.text;\n        }\n        if (pos >= from) {\n            if (pos >= to && str.slice(to - text.length - childStart, to - childStart) == text)\n                return to - text.length;\n            let found = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;\n            if (found >= 0 && found + text.length + childStart >= from)\n                return childStart + found;\n            if (from == to && str.length >= (to + text.length) - childStart &&\n                str.slice(to - childStart, to - childStart + text.length) == text)\n                return to;\n        }\n    }\n    return -1;\n}\n// Replace range from-to in an array of view descs with replacement\n// (may be null to just delete). This goes very much against the grain\n// of the rest of this code, which tends to create nodes with the\n// right shape in one go, rather than messing with them after\n// creation, but is necessary in the composition hack.\nfunction replaceNodes(nodes, from, to, view, replacement) {\n    let result = [];\n    for (let i = 0, off = 0; i < nodes.length; i++) {\n        let child = nodes[i], start = off, end = off += child.size;\n        if (start >= to || end <= from) {\n            result.push(child);\n        }\n        else {\n            if (start < from)\n                result.push(child.slice(0, from - start, view));\n            if (replacement) {\n                result.push(replacement);\n                replacement = undefined;\n            }\n            if (end > to)\n                result.push(child.slice(to - start, child.size, view));\n        }\n    }\n    return result;\n}\n\nfunction selectionFromDOM(view, origin = null) {\n    let domSel = view.domSelectionRange(), doc = view.state.doc;\n    if (!domSel.focusNode)\n        return null;\n    let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;\n    let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);\n    if (head < 0)\n        return null;\n    let $head = doc.resolve(head), anchor, selection;\n    if (selectionCollapsed(domSel)) {\n        anchor = head;\n        while (nearestDesc && !nearestDesc.node)\n            nearestDesc = nearestDesc.parent;\n        let nearestDescNode = nearestDesc.node;\n        if (nearestDesc && nearestDescNode.isAtom && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent\n            && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {\n            let pos = nearestDesc.posBefore;\n            selection = new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection(head == pos ? $head : doc.resolve(pos));\n        }\n    }\n    else {\n        if (domSel instanceof view.dom.ownerDocument.defaultView.Selection && domSel.rangeCount > 1) {\n            let min = head, max = head;\n            for (let i = 0; i < domSel.rangeCount; i++) {\n                let range = domSel.getRangeAt(i);\n                min = Math.min(min, view.docView.posFromDOM(range.startContainer, range.startOffset, 1));\n                max = Math.max(max, view.docView.posFromDOM(range.endContainer, range.endOffset, -1));\n            }\n            if (min < 0)\n                return null;\n            [anchor, head] = max == view.state.selection.anchor ? [max, min] : [min, max];\n            $head = doc.resolve(head);\n        }\n        else {\n            anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);\n        }\n        if (anchor < 0)\n            return null;\n    }\n    let $anchor = doc.resolve(anchor);\n    if (!selection) {\n        let bias = origin == \"pointer\" || (view.state.selection.head < $head.pos && !inWidget) ? 1 : -1;\n        selection = selectionBetween(view, $anchor, $head, bias);\n    }\n    return selection;\n}\nfunction editorOwnsSelection(view) {\n    return view.editable ? view.hasFocus() :\n        hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);\n}\nfunction selectionToDOM(view, force = false) {\n    let sel = view.state.selection;\n    syncNodeSelection(view, sel);\n    if (!editorOwnsSelection(view))\n        return;\n    // The delayed drag selection causes issues with Cell Selections\n    // in Safari. And the drag selection delay is to workarond issues\n    // which only present in Chrome.\n    if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {\n        let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;\n        if (domSel.anchorNode && curSel.anchorNode &&\n            isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {\n            view.input.mouseDown.delayedSelectionSync = true;\n            view.domObserver.setCurSelection();\n            return;\n        }\n    }\n    view.domObserver.disconnectSelection();\n    if (view.cursorWrapper) {\n        selectCursorWrapper(view);\n    }\n    else {\n        let { anchor, head } = sel, resetEditableFrom, resetEditableTo;\n        if (brokenSelectBetweenUneditable && !(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection)) {\n            if (!sel.$from.parent.inlineContent)\n                resetEditableFrom = temporarilyEditableNear(view, sel.from);\n            if (!sel.empty && !sel.$from.parent.inlineContent)\n                resetEditableTo = temporarilyEditableNear(view, sel.to);\n        }\n        view.docView.setSelection(anchor, head, view, force);\n        if (brokenSelectBetweenUneditable) {\n            if (resetEditableFrom)\n                resetEditable(resetEditableFrom);\n            if (resetEditableTo)\n                resetEditable(resetEditableTo);\n        }\n        if (sel.visible) {\n            view.dom.classList.remove(\"ProseMirror-hideselection\");\n        }\n        else {\n            view.dom.classList.add(\"ProseMirror-hideselection\");\n            if (\"onselectionchange\" in document)\n                removeClassOnSelectionChange(view);\n        }\n    }\n    view.domObserver.setCurSelection();\n    view.domObserver.connectSelection();\n}\n// Kludge to work around Webkit not allowing a selection to start/end\n// between non-editable block nodes. We briefly make something\n// editable, set the selection, then set it uneditable again.\nconst brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;\nfunction temporarilyEditableNear(view, pos) {\n    let { node, offset } = view.docView.domFromPos(pos, 0);\n    let after = offset < node.childNodes.length ? node.childNodes[offset] : null;\n    let before = offset ? node.childNodes[offset - 1] : null;\n    if (safari && after && after.contentEditable == \"false\")\n        return setEditable(after);\n    if ((!after || after.contentEditable == \"false\") &&\n        (!before || before.contentEditable == \"false\")) {\n        if (after)\n            return setEditable(after);\n        else if (before)\n            return setEditable(before);\n    }\n}\nfunction setEditable(element) {\n    element.contentEditable = \"true\";\n    if (safari && element.draggable) {\n        element.draggable = false;\n        element.wasDraggable = true;\n    }\n    return element;\n}\nfunction resetEditable(element) {\n    element.contentEditable = \"false\";\n    if (element.wasDraggable) {\n        element.draggable = true;\n        element.wasDraggable = null;\n    }\n}\nfunction removeClassOnSelectionChange(view) {\n    let doc = view.dom.ownerDocument;\n    doc.removeEventListener(\"selectionchange\", view.input.hideSelectionGuard);\n    let domSel = view.domSelectionRange();\n    let node = domSel.anchorNode, offset = domSel.anchorOffset;\n    doc.addEventListener(\"selectionchange\", view.input.hideSelectionGuard = () => {\n        if (domSel.anchorNode != node || domSel.anchorOffset != offset) {\n            doc.removeEventListener(\"selectionchange\", view.input.hideSelectionGuard);\n            setTimeout(() => {\n                if (!editorOwnsSelection(view) || view.state.selection.visible)\n                    view.dom.classList.remove(\"ProseMirror-hideselection\");\n            }, 20);\n        }\n    });\n}\nfunction selectCursorWrapper(view) {\n    let domSel = view.domSelection();\n    if (!domSel)\n        return;\n    let node = view.cursorWrapper.dom, img = node.nodeName == \"IMG\";\n    if (img)\n        domSel.collapse(node.parentNode, domIndex(node) + 1);\n    else\n        domSel.collapse(node, 0);\n    // Kludge to kill 'control selection' in IE11 when selecting an\n    // invisible cursor wrapper, since that would result in those weird\n    // resize handles and a selection that considers the absolutely\n    // positioned wrapper, rather than the root editable node, the\n    // focused element.\n    if (!img && !view.state.selection.visible && ie && ie_version <= 11) {\n        node.disabled = true;\n        node.disabled = false;\n    }\n}\nfunction syncNodeSelection(view, sel) {\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) {\n        let desc = view.docView.descAt(sel.from);\n        if (desc != view.lastSelectedViewDesc) {\n            clearNodeSelection(view);\n            if (desc)\n                desc.selectNode();\n            view.lastSelectedViewDesc = desc;\n        }\n    }\n    else {\n        clearNodeSelection(view);\n    }\n}\n// Clear all DOM statefulness of the last node selection.\nfunction clearNodeSelection(view) {\n    if (view.lastSelectedViewDesc) {\n        if (view.lastSelectedViewDesc.parent)\n            view.lastSelectedViewDesc.deselectNode();\n        view.lastSelectedViewDesc = undefined;\n    }\n}\nfunction selectionBetween(view, $anchor, $head, bias) {\n    return view.someProp(\"createSelectionBetween\", f => f(view, $anchor, $head))\n        || prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.between($anchor, $head, bias);\n}\nfunction hasFocusAndSelection(view) {\n    if (view.editable && !view.hasFocus())\n        return false;\n    return hasSelection(view);\n}\nfunction hasSelection(view) {\n    let sel = view.domSelectionRange();\n    if (!sel.anchorNode)\n        return false;\n    try {\n        // Firefox will raise 'permission denied' errors when accessing\n        // properties of `sel.anchorNode` when it's in a generated CSS\n        // element.\n        return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) &&\n            (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));\n    }\n    catch (_) {\n        return false;\n    }\n}\nfunction anchorInRightPlace(view) {\n    let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);\n    let domSel = view.domSelectionRange();\n    return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);\n}\n\nfunction moveSelectionBlock(state, dir) {\n    let { $anchor, $head } = state.selection;\n    let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);\n    let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;\n    return $start && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom($start, dir);\n}\nfunction apply(view, sel) {\n    view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());\n    return true;\n}\nfunction selectHorizontally(view, dir, mods) {\n    let sel = view.state.selection;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) {\n        if (mods.indexOf(\"s\") > -1) {\n            let { $head } = sel, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;\n            if (!node || node.isText || !node.isLeaf)\n                return false;\n            let $newHead = view.state.doc.resolve($head.pos + node.nodeSize * (dir < 0 ? -1 : 1));\n            return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection(sel.$anchor, $newHead));\n        }\n        else if (!sel.empty) {\n            return false;\n        }\n        else if (view.endOfTextblock(dir > 0 ? \"forward\" : \"backward\")) {\n            let next = moveSelectionBlock(view.state, dir);\n            if (next && (next instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection))\n                return apply(view, next);\n            return false;\n        }\n        else if (!(mac && mods.indexOf(\"m\") > -1)) {\n            let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;\n            if (!node || node.isText)\n                return false;\n            let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;\n            if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))\n                return false;\n            if (prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) {\n                return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));\n            }\n            else if (webkit) {\n                // Chrome and Safari will introduce extra pointless cursor\n                // positions around inline uneditable nodes, so we have to\n                // take over and move the cursor past them (#937)\n                return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));\n            }\n            else {\n                return false;\n            }\n        }\n    }\n    else if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection && sel.node.isInline) {\n        return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection(dir > 0 ? sel.$to : sel.$from));\n    }\n    else {\n        let next = moveSelectionBlock(view.state, dir);\n        if (next)\n            return apply(view, next);\n        return false;\n    }\n}\nfunction nodeLen(node) {\n    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nfunction isIgnorable(dom, dir) {\n    let desc = dom.pmViewDesc;\n    return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != \"BR\");\n}\nfunction skipIgnoredNodes(view, dir) {\n    return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);\n}\n// Make sure the cursor isn't directly after one or more ignored\n// nodes, which will confuse the browser's cursor motion logic.\nfunction skipIgnoredNodesBefore(view) {\n    let sel = view.domSelectionRange();\n    let node = sel.focusNode, offset = sel.focusOffset;\n    if (!node)\n        return;\n    let moveNode, moveOffset, force = false;\n    // Gecko will do odd things when the selection is directly in front\n    // of a non-editable node, so in that case, move it into the next\n    // node if possible. Issue prosemirror/prosemirror#832.\n    if (gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset], -1))\n        force = true;\n    for (;;) {\n        if (offset > 0) {\n            if (node.nodeType != 1) {\n                break;\n            }\n            else {\n                let before = node.childNodes[offset - 1];\n                if (isIgnorable(before, -1)) {\n                    moveNode = node;\n                    moveOffset = --offset;\n                }\n                else if (before.nodeType == 3) {\n                    node = before;\n                    offset = node.nodeValue.length;\n                }\n                else\n                    break;\n            }\n        }\n        else if (isBlockNode(node)) {\n            break;\n        }\n        else {\n            let prev = node.previousSibling;\n            while (prev && isIgnorable(prev, -1)) {\n                moveNode = node.parentNode;\n                moveOffset = domIndex(prev);\n                prev = prev.previousSibling;\n            }\n            if (!prev) {\n                node = node.parentNode;\n                if (node == view.dom)\n                    break;\n                offset = 0;\n            }\n            else {\n                node = prev;\n                offset = nodeLen(node);\n            }\n        }\n    }\n    if (force)\n        setSelFocus(view, node, offset);\n    else if (moveNode)\n        setSelFocus(view, moveNode, moveOffset);\n}\n// Make sure the cursor isn't directly before one or more ignored\n// nodes.\nfunction skipIgnoredNodesAfter(view) {\n    let sel = view.domSelectionRange();\n    let node = sel.focusNode, offset = sel.focusOffset;\n    if (!node)\n        return;\n    let len = nodeLen(node);\n    let moveNode, moveOffset;\n    for (;;) {\n        if (offset < len) {\n            if (node.nodeType != 1)\n                break;\n            let after = node.childNodes[offset];\n            if (isIgnorable(after, 1)) {\n                moveNode = node;\n                moveOffset = ++offset;\n            }\n            else\n                break;\n        }\n        else if (isBlockNode(node)) {\n            break;\n        }\n        else {\n            let next = node.nextSibling;\n            while (next && isIgnorable(next, 1)) {\n                moveNode = next.parentNode;\n                moveOffset = domIndex(next) + 1;\n                next = next.nextSibling;\n            }\n            if (!next) {\n                node = node.parentNode;\n                if (node == view.dom)\n                    break;\n                offset = len = 0;\n            }\n            else {\n                node = next;\n                offset = 0;\n                len = nodeLen(node);\n            }\n        }\n    }\n    if (moveNode)\n        setSelFocus(view, moveNode, moveOffset);\n}\nfunction isBlockNode(dom) {\n    let desc = dom.pmViewDesc;\n    return desc && desc.node && desc.node.isBlock;\n}\nfunction textNodeAfter(node, offset) {\n    while (node && offset == node.childNodes.length && !hasBlockDesc(node)) {\n        offset = domIndex(node) + 1;\n        node = node.parentNode;\n    }\n    while (node && offset < node.childNodes.length) {\n        let next = node.childNodes[offset];\n        if (next.nodeType == 3)\n            return next;\n        if (next.nodeType == 1 && next.contentEditable == \"false\")\n            break;\n        node = next;\n        offset = 0;\n    }\n}\nfunction textNodeBefore(node, offset) {\n    while (node && !offset && !hasBlockDesc(node)) {\n        offset = domIndex(node);\n        node = node.parentNode;\n    }\n    while (node && offset) {\n        let next = node.childNodes[offset - 1];\n        if (next.nodeType == 3)\n            return next;\n        if (next.nodeType == 1 && next.contentEditable == \"false\")\n            break;\n        node = next;\n        offset = node.childNodes.length;\n    }\n}\nfunction setSelFocus(view, node, offset) {\n    if (node.nodeType != 3) {\n        let before, after;\n        if (after = textNodeAfter(node, offset)) {\n            node = after;\n            offset = 0;\n        }\n        else if (before = textNodeBefore(node, offset)) {\n            node = before;\n            offset = before.nodeValue.length;\n        }\n    }\n    let sel = view.domSelection();\n    if (!sel)\n        return;\n    if (selectionCollapsed(sel)) {\n        let range = document.createRange();\n        range.setEnd(node, offset);\n        range.setStart(node, offset);\n        sel.removeAllRanges();\n        sel.addRange(range);\n    }\n    else if (sel.extend) {\n        sel.extend(node, offset);\n    }\n    view.domObserver.setCurSelection();\n    let { state } = view;\n    // If no state update ends up happening, reset the selection.\n    setTimeout(() => {\n        if (view.state == state)\n            selectionToDOM(view);\n    }, 50);\n}\nfunction findDirection(view, pos) {\n    let $pos = view.state.doc.resolve(pos);\n    if (!(chrome || windows) && $pos.parent.inlineContent) {\n        let coords = view.coordsAtPos(pos);\n        if (pos > $pos.start()) {\n            let before = view.coordsAtPos(pos - 1);\n            let mid = (before.top + before.bottom) / 2;\n            if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1)\n                return before.left < coords.left ? \"ltr\" : \"rtl\";\n        }\n        if (pos < $pos.end()) {\n            let after = view.coordsAtPos(pos + 1);\n            let mid = (after.top + after.bottom) / 2;\n            if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1)\n                return after.left > coords.left ? \"ltr\" : \"rtl\";\n        }\n    }\n    let computed = getComputedStyle(view.dom).direction;\n    return computed == \"rtl\" ? \"rtl\" : \"ltr\";\n}\n// Check whether vertical selection motion would involve node\n// selections. If so, apply it (if not, the result is left to the\n// browser)\nfunction selectVertically(view, dir, mods) {\n    let sel = view.state.selection;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection && !sel.empty || mods.indexOf(\"s\") > -1)\n        return false;\n    if (mac && mods.indexOf(\"m\") > -1)\n        return false;\n    let { $from, $to } = sel;\n    if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? \"up\" : \"down\")) {\n        let next = moveSelectionBlock(view.state, dir);\n        if (next && (next instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection))\n            return apply(view, next);\n    }\n    if (!$from.parent.inlineContent) {\n        let side = dir < 0 ? $from : $to;\n        let beyond = sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection ? prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(side, dir) : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(side, dir);\n        return beyond ? apply(view, beyond) : false;\n    }\n    return false;\n}\nfunction stopNativeHorizontalDelete(view, dir) {\n    if (!(view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection))\n        return true;\n    let { $head, $anchor, empty } = view.state.selection;\n    if (!$head.sameParent($anchor))\n        return true;\n    if (!empty)\n        return false;\n    if (view.endOfTextblock(dir > 0 ? \"forward\" : \"backward\"))\n        return true;\n    let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);\n    if (nextNode && !nextNode.isText) {\n        let tr = view.state.tr;\n        if (dir < 0)\n            tr.delete($head.pos - nextNode.nodeSize, $head.pos);\n        else\n            tr.delete($head.pos, $head.pos + nextNode.nodeSize);\n        view.dispatch(tr);\n        return true;\n    }\n    return false;\n}\nfunction switchEditable(view, node, state) {\n    view.domObserver.stop();\n    node.contentEditable = state;\n    view.domObserver.start();\n}\n// Issue #867 / #1090 / https://bugs.chromium.org/p/chromium/issues/detail?id=903821\n// In which Safari (and at some point in the past, Chrome) does really\n// wrong things when the down arrow is pressed when the cursor is\n// directly at the start of a textblock and has an uneditable node\n// after it\nfunction safariDownArrowBug(view) {\n    if (!safari || view.state.selection.$head.parentOffset > 0)\n        return false;\n    let { focusNode, focusOffset } = view.domSelectionRange();\n    if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 &&\n        focusNode.firstChild && focusNode.firstChild.contentEditable == \"false\") {\n        let child = focusNode.firstChild;\n        switchEditable(view, child, \"true\");\n        setTimeout(() => switchEditable(view, child, \"false\"), 20);\n    }\n    return false;\n}\n// A backdrop key mapping used to make sure we always suppress keys\n// that have a dangerous default effect, even if the commands they are\n// bound to return false, and to make sure that cursor-motion keys\n// find a cursor (as opposed to a node selection) when pressed. For\n// cursor-motion keys, the code in the handlers also takes care of\n// block selections.\nfunction getMods(event) {\n    let result = \"\";\n    if (event.ctrlKey)\n        result += \"c\";\n    if (event.metaKey)\n        result += \"m\";\n    if (event.altKey)\n        result += \"a\";\n    if (event.shiftKey)\n        result += \"s\";\n    return result;\n}\nfunction captureKeyDown(view, event) {\n    let code = event.keyCode, mods = getMods(event);\n    if (code == 8 || (mac && code == 72 && mods == \"c\")) { // Backspace, Ctrl-h on Mac\n        return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);\n    }\n    else if ((code == 46 && !event.shiftKey) || (mac && code == 68 && mods == \"c\")) { // Delete, Ctrl-d on Mac\n        return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);\n    }\n    else if (code == 13 || code == 27) { // Enter, Esc\n        return true;\n    }\n    else if (code == 37 || (mac && code == 66 && mods == \"c\")) { // Left arrow, Ctrl-b on Mac\n        let dir = code == 37 ? (findDirection(view, view.state.selection.from) == \"ltr\" ? -1 : 1) : -1;\n        return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);\n    }\n    else if (code == 39 || (mac && code == 70 && mods == \"c\")) { // Right arrow, Ctrl-f on Mac\n        let dir = code == 39 ? (findDirection(view, view.state.selection.from) == \"ltr\" ? 1 : -1) : 1;\n        return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);\n    }\n    else if (code == 38 || (mac && code == 80 && mods == \"c\")) { // Up arrow, Ctrl-p on Mac\n        return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);\n    }\n    else if (code == 40 || (mac && code == 78 && mods == \"c\")) { // Down arrow, Ctrl-n on Mac\n        return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);\n    }\n    else if (mods == (mac ? \"m\" : \"c\") &&\n        (code == 66 || code == 73 || code == 89 || code == 90)) { // Mod-[biyz]\n        return true;\n    }\n    return false;\n}\n\nfunction serializeForClipboard(view, slice) {\n    view.someProp(\"transformCopied\", f => { slice = f(slice, view); });\n    let context = [], { content, openStart, openEnd } = slice;\n    while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {\n        openStart--;\n        openEnd--;\n        let node = content.firstChild;\n        context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);\n        content = node.content;\n    }\n    let serializer = view.someProp(\"clipboardSerializer\") || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.fromSchema(view.state.schema);\n    let doc = detachedDoc(), wrap = doc.createElement(\"div\");\n    wrap.appendChild(serializer.serializeFragment(content, { document: doc }));\n    let firstChild = wrap.firstChild, needsWrap, wrappers = 0;\n    while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {\n        for (let i = needsWrap.length - 1; i >= 0; i--) {\n            let wrapper = doc.createElement(needsWrap[i]);\n            while (wrap.firstChild)\n                wrapper.appendChild(wrap.firstChild);\n            wrap.appendChild(wrapper);\n            wrappers++;\n        }\n        firstChild = wrap.firstChild;\n    }\n    if (firstChild && firstChild.nodeType == 1)\n        firstChild.setAttribute(\"data-pm-slice\", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : \"\"} ${JSON.stringify(context)}`);\n    let text = view.someProp(\"clipboardTextSerializer\", f => f(slice, view)) ||\n        slice.content.textBetween(0, slice.content.size, \"\\n\\n\");\n    return { dom: wrap, text, slice };\n}\n// Read a slice of content from the clipboard (or drop data).\nfunction parseFromClipboard(view, text, html, plainText, $context) {\n    let inCode = $context.parent.type.spec.code;\n    let dom, slice;\n    if (!html && !text)\n        return null;\n    let asText = !!text && (plainText || inCode || !html);\n    if (asText) {\n        view.someProp(\"transformPastedText\", f => { text = f(text, inCode || plainText, view); });\n        if (inCode) {\n            slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(view.state.schema.text(text.replace(/\\r\\n?/g, \"\\n\"))), 0, 0);\n            view.someProp(\"transformPasted\", f => { slice = f(slice, view, true); });\n            return slice;\n        }\n        let parsed = view.someProp(\"clipboardTextParser\", f => f(text, $context, plainText, view));\n        if (parsed) {\n            slice = parsed;\n        }\n        else {\n            let marks = $context.marks();\n            let { schema } = view.state, serializer = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.fromSchema(schema);\n            dom = document.createElement(\"div\");\n            text.split(/(?:\\r\\n?|\\n)+/).forEach(block => {\n                let p = dom.appendChild(document.createElement(\"p\"));\n                if (block)\n                    p.appendChild(serializer.serializeNode(schema.text(block, marks)));\n            });\n        }\n    }\n    else {\n        view.someProp(\"transformPastedHTML\", f => { html = f(html, view); });\n        dom = readHTML(html);\n        if (webkit)\n            restoreReplacedSpaces(dom);\n    }\n    let contextNode = dom && dom.querySelector(\"[data-pm-slice]\");\n    let sliceData = contextNode && /^(\\d+) (\\d+)(?: -(\\d+))? (.*)/.exec(contextNode.getAttribute(\"data-pm-slice\") || \"\");\n    if (sliceData && sliceData[3])\n        for (let i = +sliceData[3]; i > 0; i--) {\n            let child = dom.firstChild;\n            while (child && child.nodeType != 1)\n                child = child.nextSibling;\n            if (!child)\n                break;\n            dom = child;\n        }\n    if (!slice) {\n        let parser = view.someProp(\"clipboardParser\") || view.someProp(\"domParser\") || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMParser.fromSchema(view.state.schema);\n        slice = parser.parseSlice(dom, {\n            preserveWhitespace: !!(asText || sliceData),\n            context: $context,\n            ruleFromNode(dom) {\n                if (dom.nodeName == \"BR\" && !dom.nextSibling &&\n                    dom.parentNode && !inlineParents.test(dom.parentNode.nodeName))\n                    return { ignore: true };\n                return null;\n            }\n        });\n    }\n    if (sliceData) {\n        slice = addContext(closeSlice(slice, +sliceData[1], +sliceData[2]), sliceData[4]);\n    }\n    else { // HTML wasn't created by ProseMirror. Make sure top-level siblings are coherent\n        slice = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.maxOpen(normalizeSiblings(slice.content, $context), true);\n        if (slice.openStart || slice.openEnd) {\n            let openStart = 0, openEnd = 0;\n            for (let node = slice.content.firstChild; openStart < slice.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) { }\n            for (let node = slice.content.lastChild; openEnd < slice.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild) { }\n            slice = closeSlice(slice, openStart, openEnd);\n        }\n    }\n    view.someProp(\"transformPasted\", f => { slice = f(slice, view, asText); });\n    return slice;\n}\nconst inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;\n// Takes a slice parsed with parseSlice, which means there hasn't been\n// any content-expression checking done on the top nodes, tries to\n// find a parent node in the current context that might fit the nodes,\n// and if successful, rebuilds the slice so that it fits into that parent.\n//\n// This addresses the problem that Transform.replace expects a\n// coherent slice, and will fail to place a set of siblings that don't\n// fit anywhere in the schema.\nfunction normalizeSiblings(fragment, $context) {\n    if (fragment.childCount < 2)\n        return fragment;\n    for (let d = $context.depth; d >= 0; d--) {\n        let parent = $context.node(d);\n        let match = parent.contentMatchAt($context.index(d));\n        let lastWrap, result = [];\n        fragment.forEach(node => {\n            if (!result)\n                return;\n            let wrap = match.findWrapping(node.type), inLast;\n            if (!wrap)\n                return result = null;\n            if (inLast = result.length && lastWrap.length && addToSibling(wrap, lastWrap, node, result[result.length - 1], 0)) {\n                result[result.length - 1] = inLast;\n            }\n            else {\n                if (result.length)\n                    result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);\n                let wrapped = withWrappers(node, wrap);\n                result.push(wrapped);\n                match = match.matchType(wrapped.type);\n                lastWrap = wrap;\n            }\n        });\n        if (result)\n            return prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(result);\n    }\n    return fragment;\n}\nfunction withWrappers(node, wrap, from = 0) {\n    for (let i = wrap.length - 1; i >= from; i--)\n        node = wrap[i].create(null, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(node));\n    return node;\n}\n// Used to group adjacent nodes wrapped in similar parents by\n// normalizeSiblings into the same parent node\nfunction addToSibling(wrap, lastWrap, node, sibling, depth) {\n    if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {\n        let inner = addToSibling(wrap, lastWrap, node, sibling.lastChild, depth + 1);\n        if (inner)\n            return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));\n        let match = sibling.contentMatchAt(sibling.childCount);\n        if (match.matchType(depth == wrap.length - 1 ? node.type : wrap[depth + 1]))\n            return sibling.copy(sibling.content.append(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(withWrappers(node, wrap, depth + 1))));\n    }\n}\nfunction closeRight(node, depth) {\n    if (depth == 0)\n        return node;\n    let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));\n    let fill = node.contentMatchAt(node.childCount).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true);\n    return node.copy(fragment.append(fill));\n}\nfunction closeRange(fragment, side, from, to, depth, openEnd) {\n    let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;\n    if (fragment.childCount > 1)\n        openEnd = 0;\n    if (depth < to - 1)\n        inner = closeRange(inner, side, from, to, depth + 1, openEnd);\n    if (depth >= from)\n        inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner)\n            : inner.append(node.contentMatchAt(node.childCount).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true));\n    return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));\n}\nfunction closeSlice(slice, openStart, openEnd) {\n    if (openStart < slice.openStart)\n        slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(closeRange(slice.content, -1, openStart, slice.openStart, 0, slice.openEnd), openStart, slice.openEnd);\n    if (openEnd < slice.openEnd)\n        slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(closeRange(slice.content, 1, openEnd, slice.openEnd, 0, 0), slice.openStart, openEnd);\n    return slice;\n}\n// Trick from jQuery -- some elements must be wrapped in other\n// elements for innerHTML to work. I.e. if you do `div.innerHTML =\n// \"<td>..</td>\"` the table cells are ignored.\nconst wrapMap = {\n    thead: [\"table\"],\n    tbody: [\"table\"],\n    tfoot: [\"table\"],\n    caption: [\"table\"],\n    colgroup: [\"table\"],\n    col: [\"table\", \"colgroup\"],\n    tr: [\"table\", \"tbody\"],\n    td: [\"table\", \"tbody\", \"tr\"],\n    th: [\"table\", \"tbody\", \"tr\"]\n};\nlet _detachedDoc = null;\nfunction detachedDoc() {\n    return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument(\"title\"));\n}\nlet _policy = null;\nfunction maybeWrapTrusted(html) {\n    let trustedTypes = window.trustedTypes;\n    if (!trustedTypes)\n        return html;\n    // With the require-trusted-types-for CSP, Chrome will block\n    // innerHTML, even on a detached document. This wraps the string in\n    // a way that makes the browser allow us to use its parser again.\n    if (!_policy)\n        _policy = trustedTypes.defaultPolicy || trustedTypes.createPolicy(\"ProseMirrorClipboard\", { createHTML: (s) => s });\n    return _policy.createHTML(html);\n}\nfunction readHTML(html) {\n    let metas = /^(\\s*<meta [^>]*>)*/.exec(html);\n    if (metas)\n        html = html.slice(metas[0].length);\n    let elt = detachedDoc().createElement(\"div\");\n    let firstTag = /<([a-z][^>\\s]+)/i.exec(html), wrap;\n    if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()])\n        html = wrap.map(n => \"<\" + n + \">\").join(\"\") + html + wrap.map(n => \"</\" + n + \">\").reverse().join(\"\");\n    elt.innerHTML = maybeWrapTrusted(html);\n    if (wrap)\n        for (let i = 0; i < wrap.length; i++)\n            elt = elt.querySelector(wrap[i]) || elt;\n    return elt;\n}\n// Webkit browsers do some hard-to-predict replacement of regular\n// spaces with non-breaking spaces when putting content on the\n// clipboard. This tries to convert such non-breaking spaces (which\n// will be wrapped in a plain span on Chrome, a span with class\n// Apple-converted-space on Safari) back to regular spaces.\nfunction restoreReplacedSpaces(dom) {\n    let nodes = dom.querySelectorAll(chrome ? \"span:not([class]):not([style])\" : \"span.Apple-converted-space\");\n    for (let i = 0; i < nodes.length; i++) {\n        let node = nodes[i];\n        if (node.childNodes.length == 1 && node.textContent == \"\\u00a0\" && node.parentNode)\n            node.parentNode.replaceChild(dom.ownerDocument.createTextNode(\" \"), node);\n    }\n}\nfunction addContext(slice, context) {\n    if (!slice.size)\n        return slice;\n    let schema = slice.content.firstChild.type.schema, array;\n    try {\n        array = JSON.parse(context);\n    }\n    catch (e) {\n        return slice;\n    }\n    let { content, openStart, openEnd } = slice;\n    for (let i = array.length - 2; i >= 0; i -= 2) {\n        let type = schema.nodes[array[i]];\n        if (!type || type.hasRequiredAttrs())\n            break;\n        content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(type.create(array[i + 1], content));\n        openStart++;\n        openEnd++;\n    }\n    return new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, openStart, openEnd);\n}\n\n// A collection of DOM events that occur within the editor, and callback functions\n// to invoke when the event fires.\nconst handlers = {};\nconst editHandlers = {};\nconst passiveHandlers = { touchstart: true, touchmove: true };\nclass InputState {\n    constructor() {\n        this.shiftKey = false;\n        this.mouseDown = null;\n        this.lastKeyCode = null;\n        this.lastKeyCodeTime = 0;\n        this.lastClick = { time: 0, x: 0, y: 0, type: \"\", button: 0 };\n        this.lastSelectionOrigin = null;\n        this.lastSelectionTime = 0;\n        this.lastIOSEnter = 0;\n        this.lastIOSEnterFallbackTimeout = -1;\n        this.lastFocus = 0;\n        this.lastTouch = 0;\n        this.lastChromeDelete = 0;\n        this.composing = false;\n        this.compositionNode = null;\n        this.composingTimeout = -1;\n        this.compositionNodes = [];\n        this.compositionEndedAt = -2e8;\n        this.compositionID = 1;\n        this.badSafariComposition = false;\n        // Set to a composition ID when there are pending changes at compositionend\n        this.compositionPendingChanges = 0;\n        this.domChangeCount = 0;\n        this.eventHandlers = Object.create(null);\n        this.hideSelectionGuard = null;\n    }\n}\nfunction initInput(view) {\n    for (let event in handlers) {\n        let handler = handlers[event];\n        view.dom.addEventListener(event, view.input.eventHandlers[event] = (event) => {\n            if (eventBelongsToView(view, event) && !runCustomHandler(view, event) &&\n                (view.editable || !(event.type in editHandlers)))\n                handler(view, event);\n        }, passiveHandlers[event] ? { passive: true } : undefined);\n    }\n    // On Safari, for reasons beyond my understanding, adding an input\n    // event handler makes an issue where the composition vanishes when\n    // you press enter go away.\n    if (safari)\n        view.dom.addEventListener(\"input\", () => null);\n    ensureListeners(view);\n}\nfunction setSelectionOrigin(view, origin) {\n    view.input.lastSelectionOrigin = origin;\n    view.input.lastSelectionTime = Date.now();\n}\nfunction destroyInput(view) {\n    view.domObserver.stop();\n    for (let type in view.input.eventHandlers)\n        view.dom.removeEventListener(type, view.input.eventHandlers[type]);\n    clearTimeout(view.input.composingTimeout);\n    clearTimeout(view.input.lastIOSEnterFallbackTimeout);\n}\nfunction ensureListeners(view) {\n    view.someProp(\"handleDOMEvents\", currentHandlers => {\n        for (let type in currentHandlers)\n            if (!view.input.eventHandlers[type])\n                view.dom.addEventListener(type, view.input.eventHandlers[type] = event => runCustomHandler(view, event));\n    });\n}\nfunction runCustomHandler(view, event) {\n    return view.someProp(\"handleDOMEvents\", handlers => {\n        let handler = handlers[event.type];\n        return handler ? handler(view, event) || event.defaultPrevented : false;\n    });\n}\nfunction eventBelongsToView(view, event) {\n    if (!event.bubbles)\n        return true;\n    if (event.defaultPrevented)\n        return false;\n    for (let node = event.target; node != view.dom; node = node.parentNode)\n        if (!node || node.nodeType == 11 ||\n            (node.pmViewDesc && node.pmViewDesc.stopEvent(event)))\n            return false;\n    return true;\n}\nfunction dispatchEvent(view, event) {\n    if (!runCustomHandler(view, event) && handlers[event.type] &&\n        (view.editable || !(event.type in editHandlers)))\n        handlers[event.type](view, event);\n}\neditHandlers.keydown = (view, _event) => {\n    let event = _event;\n    view.input.shiftKey = event.keyCode == 16 || event.shiftKey;\n    if (inOrNearComposition(view, event))\n        return;\n    view.input.lastKeyCode = event.keyCode;\n    view.input.lastKeyCodeTime = Date.now();\n    // Suppress enter key events on Chrome Android, because those tend\n    // to be part of a confused sequence of composition events fired,\n    // and handling them eagerly tends to corrupt the input.\n    if (android && chrome && event.keyCode == 13)\n        return;\n    if (event.keyCode != 229)\n        view.domObserver.forceFlush();\n    // On iOS, if we preventDefault enter key presses, the virtual\n    // keyboard gets confused. So the hack here is to set a flag that\n    // makes the DOM change code recognize that what just happens should\n    // be replaced by whatever the Enter key handlers do.\n    if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {\n        let now = Date.now();\n        view.input.lastIOSEnter = now;\n        view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {\n            if (view.input.lastIOSEnter == now) {\n                view.someProp(\"handleKeyDown\", f => f(view, keyEvent(13, \"Enter\")));\n                view.input.lastIOSEnter = 0;\n            }\n        }, 200);\n    }\n    else if (view.someProp(\"handleKeyDown\", f => f(view, event)) || captureKeyDown(view, event)) {\n        event.preventDefault();\n    }\n    else {\n        setSelectionOrigin(view, \"key\");\n    }\n};\neditHandlers.keyup = (view, event) => {\n    if (event.keyCode == 16)\n        view.input.shiftKey = false;\n};\neditHandlers.keypress = (view, _event) => {\n    let event = _event;\n    if (inOrNearComposition(view, event) || !event.charCode ||\n        event.ctrlKey && !event.altKey || mac && event.metaKey)\n        return;\n    if (view.someProp(\"handleKeyPress\", f => f(view, event))) {\n        event.preventDefault();\n        return;\n    }\n    let sel = view.state.selection;\n    if (!(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) || !sel.$from.sameParent(sel.$to)) {\n        let text = String.fromCharCode(event.charCode);\n        let deflt = () => view.state.tr.insertText(text).scrollIntoView();\n        if (!/[\\r\\n]/.test(text) && !view.someProp(\"handleTextInput\", f => f(view, sel.$from.pos, sel.$to.pos, text, deflt)))\n            view.dispatch(deflt());\n        event.preventDefault();\n    }\n};\nfunction eventCoords(event) { return { left: event.clientX, top: event.clientY }; }\nfunction isNear(event, click) {\n    let dx = click.x - event.clientX, dy = click.y - event.clientY;\n    return dx * dx + dy * dy < 100;\n}\nfunction runHandlerOnContext(view, propName, pos, inside, event) {\n    if (inside == -1)\n        return false;\n    let $pos = view.state.doc.resolve(inside);\n    for (let i = $pos.depth + 1; i > 0; i--) {\n        if (view.someProp(propName, f => i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true)\n            : f(view, pos, $pos.node(i), $pos.before(i), event, false)))\n            return true;\n    }\n    return false;\n}\nfunction updateSelection(view, selection, origin) {\n    if (!view.focused)\n        view.focus();\n    if (view.state.selection.eq(selection))\n        return;\n    let tr = view.state.tr.setSelection(selection);\n    if (origin == \"pointer\")\n        tr.setMeta(\"pointer\", true);\n    view.dispatch(tr);\n}\nfunction selectClickedLeaf(view, inside) {\n    if (inside == -1)\n        return false;\n    let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;\n    if (node && node.isAtom && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) {\n        updateSelection(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection($pos), \"pointer\");\n        return true;\n    }\n    return false;\n}\nfunction selectClickedNode(view, inside) {\n    if (inside == -1)\n        return false;\n    let sel = view.state.selection, selectedNode, selectAt;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection)\n        selectedNode = sel.node;\n    let $pos = view.state.doc.resolve(inside);\n    for (let i = $pos.depth + 1; i > 0; i--) {\n        let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);\n        if (prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) {\n            if (selectedNode && sel.$from.depth > 0 &&\n                i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)\n                selectAt = $pos.before(sel.$from.depth);\n            else\n                selectAt = $pos.before(i);\n            break;\n        }\n    }\n    if (selectAt != null) {\n        updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(view.state.doc, selectAt), \"pointer\");\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nfunction handleSingleClick(view, pos, inside, event, selectNode) {\n    return runHandlerOnContext(view, \"handleClickOn\", pos, inside, event) ||\n        view.someProp(\"handleClick\", f => f(view, pos, event)) ||\n        (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));\n}\nfunction handleDoubleClick(view, pos, inside, event) {\n    return runHandlerOnContext(view, \"handleDoubleClickOn\", pos, inside, event) ||\n        view.someProp(\"handleDoubleClick\", f => f(view, pos, event));\n}\nfunction handleTripleClick(view, pos, inside, event) {\n    return runHandlerOnContext(view, \"handleTripleClickOn\", pos, inside, event) ||\n        view.someProp(\"handleTripleClick\", f => f(view, pos, event)) ||\n        defaultTripleClick(view, inside, event);\n}\nfunction defaultTripleClick(view, inside, event) {\n    if (event.button != 0)\n        return false;\n    let doc = view.state.doc;\n    if (inside == -1) {\n        if (doc.inlineContent) {\n            updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(doc, 0, doc.content.size), \"pointer\");\n            return true;\n        }\n        return false;\n    }\n    let $pos = doc.resolve(inside);\n    for (let i = $pos.depth + 1; i > 0; i--) {\n        let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);\n        let nodePos = $pos.before(i);\n        if (node.inlineContent)\n            updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(doc, nodePos + 1, nodePos + 1 + node.content.size), \"pointer\");\n        else if (prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node))\n            updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(doc, nodePos), \"pointer\");\n        else\n            continue;\n        return true;\n    }\n}\nfunction forceDOMFlush(view) {\n    return endComposition(view);\n}\nconst selectNodeModifier = mac ? \"metaKey\" : \"ctrlKey\";\nhandlers.mousedown = (view, _event) => {\n    let event = _event;\n    view.input.shiftKey = event.shiftKey;\n    let flushed = forceDOMFlush(view);\n    let now = Date.now(), type = \"singleClick\";\n    if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier] &&\n        view.input.lastClick.button == event.button) {\n        if (view.input.lastClick.type == \"singleClick\")\n            type = \"doubleClick\";\n        else if (view.input.lastClick.type == \"doubleClick\")\n            type = \"tripleClick\";\n    }\n    view.input.lastClick = { time: now, x: event.clientX, y: event.clientY, type, button: event.button };\n    let pos = view.posAtCoords(eventCoords(event));\n    if (!pos)\n        return;\n    if (type == \"singleClick\") {\n        if (view.input.mouseDown)\n            view.input.mouseDown.done();\n        view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);\n    }\n    else if ((type == \"doubleClick\" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {\n        event.preventDefault();\n    }\n    else {\n        setSelectionOrigin(view, \"pointer\");\n    }\n};\nclass MouseDown {\n    constructor(view, pos, event, flushed) {\n        this.view = view;\n        this.pos = pos;\n        this.event = event;\n        this.flushed = flushed;\n        this.delayedSelectionSync = false;\n        this.mightDrag = null;\n        this.startDoc = view.state.doc;\n        this.selectNode = !!event[selectNodeModifier];\n        this.allowDefault = event.shiftKey;\n        let targetNode, targetPos;\n        if (pos.inside > -1) {\n            targetNode = view.state.doc.nodeAt(pos.inside);\n            targetPos = pos.inside;\n        }\n        else {\n            let $pos = view.state.doc.resolve(pos.pos);\n            targetNode = $pos.parent;\n            targetPos = $pos.depth ? $pos.before() : 0;\n        }\n        const target = flushed ? null : event.target;\n        const targetDesc = target ? view.docView.nearestDesc(target, true) : null;\n        this.target = targetDesc && targetDesc.nodeDOM.nodeType == 1 ? targetDesc.nodeDOM : null;\n        let { selection } = view.state;\n        if (event.button == 0 &&\n            targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false ||\n            selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection && selection.from <= targetPos && selection.to > targetPos)\n            this.mightDrag = {\n                node: targetNode,\n                pos: targetPos,\n                addAttr: !!(this.target && !this.target.draggable),\n                setUneditable: !!(this.target && gecko && !this.target.hasAttribute(\"contentEditable\"))\n            };\n        if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {\n            this.view.domObserver.stop();\n            if (this.mightDrag.addAttr)\n                this.target.draggable = true;\n            if (this.mightDrag.setUneditable)\n                setTimeout(() => {\n                    if (this.view.input.mouseDown == this)\n                        this.target.setAttribute(\"contentEditable\", \"false\");\n                }, 20);\n            this.view.domObserver.start();\n        }\n        view.root.addEventListener(\"mouseup\", this.up = this.up.bind(this));\n        view.root.addEventListener(\"mousemove\", this.move = this.move.bind(this));\n        setSelectionOrigin(view, \"pointer\");\n    }\n    done() {\n        this.view.root.removeEventListener(\"mouseup\", this.up);\n        this.view.root.removeEventListener(\"mousemove\", this.move);\n        if (this.mightDrag && this.target) {\n            this.view.domObserver.stop();\n            if (this.mightDrag.addAttr)\n                this.target.removeAttribute(\"draggable\");\n            if (this.mightDrag.setUneditable)\n                this.target.removeAttribute(\"contentEditable\");\n            this.view.domObserver.start();\n        }\n        if (this.delayedSelectionSync)\n            setTimeout(() => selectionToDOM(this.view));\n        this.view.input.mouseDown = null;\n    }\n    up(event) {\n        this.done();\n        if (!this.view.dom.contains(event.target))\n            return;\n        let pos = this.pos;\n        if (this.view.state.doc != this.startDoc)\n            pos = this.view.posAtCoords(eventCoords(event));\n        this.updateAllowDefault(event);\n        if (this.allowDefault || !pos) {\n            setSelectionOrigin(this.view, \"pointer\");\n        }\n        else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {\n            event.preventDefault();\n        }\n        else if (event.button == 0 &&\n            (this.flushed ||\n                // Safari ignores clicks on draggable elements\n                (safari && this.mightDrag && !this.mightDrag.node.isAtom) ||\n                // Chrome will sometimes treat a node selection as a\n                // cursor, but still report that the node is selected\n                // when asked through getSelection. You'll then get a\n                // situation where clicking at the point where that\n                // (hidden) cursor is doesn't change the selection, and\n                // thus doesn't get a reaction from ProseMirror. This\n                // works around that.\n                (chrome && !this.view.state.selection.visible &&\n                    Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2))) {\n            updateSelection(this.view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(this.view.state.doc.resolve(pos.pos)), \"pointer\");\n            event.preventDefault();\n        }\n        else {\n            setSelectionOrigin(this.view, \"pointer\");\n        }\n    }\n    move(event) {\n        this.updateAllowDefault(event);\n        setSelectionOrigin(this.view, \"pointer\");\n        if (event.buttons == 0)\n            this.done();\n    }\n    updateAllowDefault(event) {\n        if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 ||\n            Math.abs(this.event.y - event.clientY) > 4))\n            this.allowDefault = true;\n    }\n}\nhandlers.touchstart = view => {\n    view.input.lastTouch = Date.now();\n    forceDOMFlush(view);\n    setSelectionOrigin(view, \"pointer\");\n};\nhandlers.touchmove = view => {\n    view.input.lastTouch = Date.now();\n    setSelectionOrigin(view, \"pointer\");\n};\nhandlers.contextmenu = view => forceDOMFlush(view);\nfunction inOrNearComposition(view, event) {\n    if (view.composing)\n        return true;\n    // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.\n    // On Japanese input method editors (IMEs), the Enter key is used to confirm character\n    // selection. On Safari, when Enter is pressed, compositionend and keydown events are\n    // emitted. The keydown event triggers newline insertion, which we don't want.\n    // This method returns true if the keydown event should be ignored.\n    // We only ignore it once, as pressing Enter a second time *should* insert a newline.\n    // Furthermore, the keydown event timestamp must be close to the compositionEndedAt timestamp.\n    // This guards against the case where compositionend is triggered without the keyboard\n    // (e.g. character confirmation may be done with the mouse), and keydown is triggered\n    // afterwards- we wouldn't want to ignore the keydown event in this case.\n    if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {\n        view.input.compositionEndedAt = -2e8;\n        return true;\n    }\n    return false;\n}\n// Drop active composition after 5 seconds of inactivity on Android\nconst timeoutComposition = android ? 5000 : -1;\neditHandlers.compositionstart = editHandlers.compositionupdate = view => {\n    if (!view.composing) {\n        view.domObserver.flush();\n        let { state } = view, $pos = state.selection.$to;\n        if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection &&\n            (state.storedMarks ||\n                (!$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some(m => m.type.spec.inclusive === false)) ||\n                chrome && windows && selectionBeforeUneditable(view))) { // Issue #1500\n            // Need to wrap the cursor in mark nodes different from the ones in the DOM context\n            view.markCursor = view.state.storedMarks || $pos.marks();\n            endComposition(view, true);\n            view.markCursor = null;\n        }\n        else {\n            endComposition(view, !state.selection.empty);\n            // In firefox, if the cursor is after but outside a marked node,\n            // the inserted text won't inherit the marks. So this moves it\n            // inside if necessary.\n            if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {\n                let sel = view.domSelectionRange();\n                for (let node = sel.focusNode, offset = sel.focusOffset; node && node.nodeType == 1 && offset != 0;) {\n                    let before = offset < 0 ? node.lastChild : node.childNodes[offset - 1];\n                    if (!before)\n                        break;\n                    if (before.nodeType == 3) {\n                        let sel = view.domSelection();\n                        if (sel)\n                            sel.collapse(before, before.nodeValue.length);\n                        break;\n                    }\n                    else {\n                        node = before;\n                        offset = -1;\n                    }\n                }\n            }\n        }\n        view.input.composing = true;\n    }\n    scheduleComposeEnd(view, timeoutComposition);\n};\nfunction selectionBeforeUneditable(view) {\n    let { focusNode, focusOffset } = view.domSelectionRange();\n    if (!focusNode || focusNode.nodeType != 1 || focusOffset >= focusNode.childNodes.length)\n        return false;\n    let next = focusNode.childNodes[focusOffset];\n    return next.nodeType == 1 && next.contentEditable == \"false\";\n}\neditHandlers.compositionend = (view, event) => {\n    if (view.composing) {\n        view.input.composing = false;\n        view.input.compositionEndedAt = event.timeStamp;\n        view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;\n        view.input.compositionNode = null;\n        if (view.input.badSafariComposition)\n            view.domObserver.forceFlush();\n        else if (view.input.compositionPendingChanges)\n            Promise.resolve().then(() => view.domObserver.flush());\n        view.input.compositionID++;\n        scheduleComposeEnd(view, 20);\n    }\n};\nfunction scheduleComposeEnd(view, delay) {\n    clearTimeout(view.input.composingTimeout);\n    if (delay > -1)\n        view.input.composingTimeout = setTimeout(() => endComposition(view), delay);\n}\nfunction clearComposition(view) {\n    if (view.composing) {\n        view.input.composing = false;\n        view.input.compositionEndedAt = timestampFromCustomEvent();\n    }\n    while (view.input.compositionNodes.length > 0)\n        view.input.compositionNodes.pop().markParentsDirty();\n}\nfunction findCompositionNode(view) {\n    let sel = view.domSelectionRange();\n    if (!sel.focusNode)\n        return null;\n    let textBefore = textNodeBefore$1(sel.focusNode, sel.focusOffset);\n    let textAfter = textNodeAfter$1(sel.focusNode, sel.focusOffset);\n    if (textBefore && textAfter && textBefore != textAfter) {\n        let descAfter = textAfter.pmViewDesc, lastChanged = view.domObserver.lastChangedTextNode;\n        if (textBefore == lastChanged || textAfter == lastChanged)\n            return lastChanged;\n        if (!descAfter || !descAfter.isText(textAfter.nodeValue)) {\n            return textAfter;\n        }\n        else if (view.input.compositionNode == textAfter) {\n            let descBefore = textBefore.pmViewDesc;\n            if (!(!descBefore || !descBefore.isText(textBefore.nodeValue)))\n                return textAfter;\n        }\n    }\n    return textBefore || textAfter;\n}\nfunction timestampFromCustomEvent() {\n    let event = document.createEvent(\"Event\");\n    event.initEvent(\"event\", true, true);\n    return event.timeStamp;\n}\n/**\n@internal\n*/\nfunction endComposition(view, restarting = false) {\n    if (android && view.domObserver.flushingSoon >= 0)\n        return;\n    view.domObserver.forceFlush();\n    clearComposition(view);\n    if (restarting || view.docView && view.docView.dirty) {\n        let sel = selectionFromDOM(view), cur = view.state.selection;\n        if (sel && !sel.eq(cur))\n            view.dispatch(view.state.tr.setSelection(sel));\n        else if ((view.markCursor || restarting) && !cur.$from.node(cur.$from.sharedDepth(cur.to)).inlineContent)\n            view.dispatch(view.state.tr.deleteSelection());\n        else\n            view.updateState(view.state);\n        return true;\n    }\n    return false;\n}\nfunction captureCopy(view, dom) {\n    // The extra wrapper is somehow necessary on IE/Edge to prevent the\n    // content from being mangled when it is put onto the clipboard\n    if (!view.dom.parentNode)\n        return;\n    let wrap = view.dom.parentNode.appendChild(document.createElement(\"div\"));\n    wrap.appendChild(dom);\n    wrap.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    let sel = getSelection(), range = document.createRange();\n    range.selectNodeContents(dom);\n    // Done because IE will fire a selectionchange moving the selection\n    // to its start when removeAllRanges is called and the editor still\n    // has focus (which will mess up the editor's selection state).\n    view.dom.blur();\n    sel.removeAllRanges();\n    sel.addRange(range);\n    setTimeout(() => {\n        if (wrap.parentNode)\n            wrap.parentNode.removeChild(wrap);\n        view.focus();\n    }, 50);\n}\n// This is very crude, but unfortunately both these browsers _pretend_\n// that they have a clipboard APIall the objects and methods are\n// there, they just don't work, and they are hard to test.\nconst brokenClipboardAPI = (ie && ie_version < 15) ||\n    (ios && webkit_version < 604);\nhandlers.copy = editHandlers.cut = (view, _event) => {\n    let event = _event;\n    let sel = view.state.selection, cut = event.type == \"cut\";\n    if (sel.empty)\n        return;\n    // IE and Edge's clipboard interface is completely broken\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    let slice = sel.content(), { dom, text } = serializeForClipboard(view, slice);\n    if (data) {\n        event.preventDefault();\n        data.clearData();\n        data.setData(\"text/html\", dom.innerHTML);\n        data.setData(\"text/plain\", text);\n    }\n    else {\n        captureCopy(view, dom);\n    }\n    if (cut)\n        view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta(\"uiEvent\", \"cut\"));\n};\nfunction sliceSingleNode(slice) {\n    return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null;\n}\nfunction capturePaste(view, event) {\n    if (!view.dom.parentNode)\n        return;\n    let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;\n    let target = view.dom.parentNode.appendChild(document.createElement(plainText ? \"textarea\" : \"div\"));\n    if (!plainText)\n        target.contentEditable = \"true\";\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    target.focus();\n    let plain = view.input.shiftKey && view.input.lastKeyCode != 45;\n    setTimeout(() => {\n        view.focus();\n        if (target.parentNode)\n            target.parentNode.removeChild(target);\n        if (plainText)\n            doPaste(view, target.value, null, plain, event);\n        else\n            doPaste(view, target.textContent, target.innerHTML, plain, event);\n    }, 50);\n}\nfunction doPaste(view, text, html, preferPlain, event) {\n    let slice = parseFromClipboard(view, text, html, preferPlain, view.state.selection.$from);\n    if (view.someProp(\"handlePaste\", f => f(view, event, slice || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty)))\n        return true;\n    if (!slice)\n        return false;\n    let singleNode = sliceSingleNode(slice);\n    let tr = singleNode\n        ? view.state.tr.replaceSelectionWith(singleNode, preferPlain)\n        : view.state.tr.replaceSelection(slice);\n    view.dispatch(tr.scrollIntoView().setMeta(\"paste\", true).setMeta(\"uiEvent\", \"paste\"));\n    return true;\n}\nfunction getText(clipboardData) {\n    let text = clipboardData.getData(\"text/plain\") || clipboardData.getData(\"Text\");\n    if (text)\n        return text;\n    let uris = clipboardData.getData(\"text/uri-list\");\n    return uris ? uris.replace(/\\r?\\n/g, \" \") : \"\";\n}\neditHandlers.paste = (view, _event) => {\n    let event = _event;\n    // Handling paste from JavaScript during composition is very poorly\n    // handled by browsers, so as a dodgy but preferable kludge, we just\n    // let the browser do its native thing there, except on Android,\n    // where the editor is almost always composing.\n    if (view.composing && !android)\n        return;\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    let plain = view.input.shiftKey && view.input.lastKeyCode != 45;\n    if (data && doPaste(view, getText(data), data.getData(\"text/html\"), plain, event))\n        event.preventDefault();\n    else\n        capturePaste(view, event);\n};\nclass Dragging {\n    constructor(slice, move, node) {\n        this.slice = slice;\n        this.move = move;\n        this.node = node;\n    }\n}\nconst dragCopyModifier = mac ? \"altKey\" : \"ctrlKey\";\nfunction dragMoves(view, event) {\n    let moves = view.someProp(\"dragCopies\", test => !test(event));\n    return moves != null ? moves : !event[dragCopyModifier];\n}\nhandlers.dragstart = (view, _event) => {\n    let event = _event;\n    let mouseDown = view.input.mouseDown;\n    if (mouseDown)\n        mouseDown.done();\n    if (!event.dataTransfer)\n        return;\n    let sel = view.state.selection;\n    let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));\n    let node;\n    if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection ? sel.to - 1 : sel.to)) ;\n    else if (mouseDown && mouseDown.mightDrag) {\n        node = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);\n    }\n    else if (event.target && event.target.nodeType == 1) {\n        let desc = view.docView.nearestDesc(event.target, true);\n        if (desc && desc.node.type.spec.draggable && desc != view.docView)\n            node = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(view.state.doc, desc.posBefore);\n    }\n    let draggedSlice = (node || view.state.selection).content();\n    let { dom, text, slice } = serializeForClipboard(view, draggedSlice);\n    // Pre-120 Chrome versions clear files when calling `clearData` (#1472)\n    if (!event.dataTransfer.files.length || !chrome || chrome_version > 120)\n        event.dataTransfer.clearData();\n    event.dataTransfer.setData(brokenClipboardAPI ? \"Text\" : \"text/html\", dom.innerHTML);\n    // See https://github.com/ProseMirror/prosemirror/issues/1156\n    event.dataTransfer.effectAllowed = \"copyMove\";\n    if (!brokenClipboardAPI)\n        event.dataTransfer.setData(\"text/plain\", text);\n    view.dragging = new Dragging(slice, dragMoves(view, event), node);\n};\nhandlers.dragend = view => {\n    let dragging = view.dragging;\n    window.setTimeout(() => {\n        if (view.dragging == dragging)\n            view.dragging = null;\n    }, 50);\n};\neditHandlers.dragover = editHandlers.dragenter = (_, e) => e.preventDefault();\neditHandlers.drop = (view, event) => {\n    try {\n        handleDrop(view, event, view.dragging);\n    }\n    finally {\n        view.dragging = null;\n    }\n};\nfunction handleDrop(view, event, dragging) {\n    if (!event.dataTransfer)\n        return;\n    let eventPos = view.posAtCoords(eventCoords(event));\n    if (!eventPos)\n        return;\n    let $mouse = view.state.doc.resolve(eventPos.pos);\n    let slice = dragging && dragging.slice;\n    if (slice) {\n        view.someProp(\"transformPasted\", f => { slice = f(slice, view, false); });\n    }\n    else {\n        slice = parseFromClipboard(view, getText(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData(\"text/html\"), false, $mouse);\n    }\n    let move = !!(dragging && dragMoves(view, event));\n    if (view.someProp(\"handleDrop\", f => f(view, event, slice || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty, move))) {\n        event.preventDefault();\n        return;\n    }\n    if (!slice)\n        return;\n    event.preventDefault();\n    let insertPos = slice ? (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_2__.dropPoint)(view.state.doc, $mouse.pos, slice) : $mouse.pos;\n    if (insertPos == null)\n        insertPos = $mouse.pos;\n    let tr = view.state.tr;\n    if (move) {\n        let { node } = dragging;\n        if (node)\n            node.replace(tr);\n        else\n            tr.deleteSelection();\n    }\n    let pos = tr.mapping.map(insertPos);\n    let isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1;\n    let beforeInsert = tr.doc;\n    if (isNode)\n        tr.replaceRangeWith(pos, pos, slice.content.firstChild);\n    else\n        tr.replaceRange(pos, pos, slice);\n    if (tr.doc.eq(beforeInsert))\n        return;\n    let $pos = tr.doc.resolve(pos);\n    if (isNode && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(slice.content.firstChild) &&\n        $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild)) {\n        tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection($pos));\n    }\n    else {\n        let end = tr.mapping.map(insertPos);\n        tr.mapping.maps[tr.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end = newTo);\n        tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)));\n    }\n    view.focus();\n    view.dispatch(tr.setMeta(\"uiEvent\", \"drop\"));\n}\nhandlers.focus = view => {\n    view.input.lastFocus = Date.now();\n    if (!view.focused) {\n        view.domObserver.stop();\n        view.dom.classList.add(\"ProseMirror-focused\");\n        view.domObserver.start();\n        view.focused = true;\n        setTimeout(() => {\n            if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))\n                selectionToDOM(view);\n        }, 20);\n    }\n};\nhandlers.blur = (view, _event) => {\n    let event = _event;\n    if (view.focused) {\n        view.domObserver.stop();\n        view.dom.classList.remove(\"ProseMirror-focused\");\n        view.domObserver.start();\n        if (event.relatedTarget && view.dom.contains(event.relatedTarget))\n            view.domObserver.currentSelection.clear();\n        view.focused = false;\n    }\n};\nhandlers.beforeinput = (view, _event) => {\n    let event = _event;\n    // We should probably do more with beforeinput events, but support\n    // is so spotty that I'm still waiting to see where they are going.\n    // Very specific hack to deal with backspace sometimes failing on\n    // Chrome Android when after an uneditable node.\n    if (chrome && android && event.inputType == \"deleteContentBackward\") {\n        view.domObserver.flushSoon();\n        let { domChangeCount } = view.input;\n        setTimeout(() => {\n            if (view.input.domChangeCount != domChangeCount)\n                return; // Event already had some effect\n            // This bug tends to close the virtual keyboard, so we refocus\n            view.dom.blur();\n            view.focus();\n            if (view.someProp(\"handleKeyDown\", f => f(view, keyEvent(8, \"Backspace\"))))\n                return;\n            let { $cursor } = view.state.selection;\n            // Crude approximation of backspace behavior when no command handled it\n            if ($cursor && $cursor.pos > 0)\n                view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());\n        }, 50);\n    }\n};\n// Make sure all handlers get registered\nfor (let prop in editHandlers)\n    handlers[prop] = editHandlers[prop];\n\nfunction compareObjs(a, b) {\n    if (a == b)\n        return true;\n    for (let p in a)\n        if (a[p] !== b[p])\n            return false;\n    for (let p in b)\n        if (!(p in a))\n            return false;\n    return true;\n}\nclass WidgetType {\n    constructor(toDOM, spec) {\n        this.toDOM = toDOM;\n        this.spec = spec || noSpec;\n        this.side = this.spec.side || 0;\n    }\n    map(mapping, span, offset, oldOffset) {\n        let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);\n        return deleted ? null : new Decoration(pos - offset, pos - offset, this);\n    }\n    valid() { return true; }\n    eq(other) {\n        return this == other ||\n            (other instanceof WidgetType &&\n                (this.spec.key && this.spec.key == other.spec.key ||\n                    this.toDOM == other.toDOM && compareObjs(this.spec, other.spec)));\n    }\n    destroy(node) {\n        if (this.spec.destroy)\n            this.spec.destroy(node);\n    }\n}\nclass InlineType {\n    constructor(attrs, spec) {\n        this.attrs = attrs;\n        this.spec = spec || noSpec;\n    }\n    map(mapping, span, offset, oldOffset) {\n        let from = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;\n        let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;\n        return from >= to ? null : new Decoration(from, to, this);\n    }\n    valid(_, span) { return span.from < span.to; }\n    eq(other) {\n        return this == other ||\n            (other instanceof InlineType && compareObjs(this.attrs, other.attrs) &&\n                compareObjs(this.spec, other.spec));\n    }\n    static is(span) { return span.type instanceof InlineType; }\n    destroy() { }\n}\nclass NodeType {\n    constructor(attrs, spec) {\n        this.attrs = attrs;\n        this.spec = spec || noSpec;\n    }\n    map(mapping, span, offset, oldOffset) {\n        let from = mapping.mapResult(span.from + oldOffset, 1);\n        if (from.deleted)\n            return null;\n        let to = mapping.mapResult(span.to + oldOffset, -1);\n        if (to.deleted || to.pos <= from.pos)\n            return null;\n        return new Decoration(from.pos - offset, to.pos - offset, this);\n    }\n    valid(node, span) {\n        let { index, offset } = node.content.findIndex(span.from), child;\n        return offset == span.from && !(child = node.child(index)).isText && offset + child.nodeSize == span.to;\n    }\n    eq(other) {\n        return this == other ||\n            (other instanceof NodeType && compareObjs(this.attrs, other.attrs) &&\n                compareObjs(this.spec, other.spec));\n    }\n    destroy() { }\n}\n/**\nDecoration objects can be provided to the view through the\n[`decorations` prop](https://prosemirror.net/docs/ref/#view.EditorProps.decorations). They come in\nseveral variantssee the static members of this class for details.\n*/\nclass Decoration {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The start position of the decoration.\n    */\n    from, \n    /**\n    The end position. Will be the same as `from` for [widget\n    decorations](https://prosemirror.net/docs/ref/#view.Decoration^widget).\n    */\n    to, \n    /**\n    @internal\n    */\n    type) {\n        this.from = from;\n        this.to = to;\n        this.type = type;\n    }\n    /**\n    @internal\n    */\n    copy(from, to) {\n        return new Decoration(from, to, this.type);\n    }\n    /**\n    @internal\n    */\n    eq(other, offset = 0) {\n        return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to;\n    }\n    /**\n    @internal\n    */\n    map(mapping, offset, oldOffset) {\n        return this.type.map(mapping, this, offset, oldOffset);\n    }\n    /**\n    Creates a widget decoration, which is a DOM node that's shown in\n    the document at the given position. It is recommended that you\n    delay rendering the widget by passing a function that will be\n    called when the widget is actually drawn in a view, but you can\n    also directly pass a DOM node. `getPos` can be used to find the\n    widget's current document position.\n    */\n    static widget(pos, toDOM, spec) {\n        return new Decoration(pos, pos, new WidgetType(toDOM, spec));\n    }\n    /**\n    Creates an inline decoration, which adds the given attributes to\n    each inline node between `from` and `to`.\n    */\n    static inline(from, to, attrs, spec) {\n        return new Decoration(from, to, new InlineType(attrs, spec));\n    }\n    /**\n    Creates a node decoration. `from` and `to` should point precisely\n    before and after a node in the document. That node, and only that\n    node, will receive the given attributes.\n    */\n    static node(from, to, attrs, spec) {\n        return new Decoration(from, to, new NodeType(attrs, spec));\n    }\n    /**\n    The spec provided when creating this decoration. Can be useful\n    if you've stored extra information in that object.\n    */\n    get spec() { return this.type.spec; }\n    /**\n    @internal\n    */\n    get inline() { return this.type instanceof InlineType; }\n    /**\n    @internal\n    */\n    get widget() { return this.type instanceof WidgetType; }\n}\nconst none = [], noSpec = {};\n/**\nA collection of [decorations](https://prosemirror.net/docs/ref/#view.Decoration), organized in such\na way that the drawing algorithm can efficiently use and compare\nthem. This is a persistent data structureit is not modified,\nupdates create a new value.\n*/\nclass DecorationSet {\n    /**\n    @internal\n    */\n    constructor(local, children) {\n        this.local = local.length ? local : none;\n        this.children = children.length ? children : none;\n    }\n    /**\n    Create a set of decorations, using the structure of the given\n    document. This will consume (modify) the `decorations` array, so\n    you must make a copy if you want need to preserve that.\n    */\n    static create(doc, decorations) {\n        return decorations.length ? buildTree(decorations, doc, 0, noSpec) : empty;\n    }\n    /**\n    Find all decorations in this set which touch the given range\n    (including decorations that start or end directly at the\n    boundaries) and match the given predicate on their spec. When\n    `start` and `end` are omitted, all decorations in the set are\n    considered. When `predicate` isn't given, all decorations are\n    assumed to match.\n    */\n    find(start, end, predicate) {\n        let result = [];\n        this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);\n        return result;\n    }\n    findInner(start, end, result, offset, predicate) {\n        for (let i = 0; i < this.local.length; i++) {\n            let span = this.local[i];\n            if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec)))\n                result.push(span.copy(span.from + offset, span.to + offset));\n        }\n        for (let i = 0; i < this.children.length; i += 3) {\n            if (this.children[i] < end && this.children[i + 1] > start) {\n                let childOff = this.children[i] + 1;\n                this.children[i + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);\n            }\n        }\n    }\n    /**\n    Map the set of decorations in response to a change in the\n    document.\n    */\n    map(mapping, doc, options) {\n        if (this == empty || mapping.maps.length == 0)\n            return this;\n        return this.mapInner(mapping, doc, 0, 0, options || noSpec);\n    }\n    /**\n    @internal\n    */\n    mapInner(mapping, node, offset, oldOffset, options) {\n        let newLocal;\n        for (let i = 0; i < this.local.length; i++) {\n            let mapped = this.local[i].map(mapping, offset, oldOffset);\n            if (mapped && mapped.type.valid(node, mapped))\n                (newLocal || (newLocal = [])).push(mapped);\n            else if (options.onRemove)\n                options.onRemove(this.local[i].spec);\n        }\n        if (this.children.length)\n            return mapChildren(this.children, newLocal || [], mapping, node, offset, oldOffset, options);\n        else\n            return newLocal ? new DecorationSet(newLocal.sort(byPos), none) : empty;\n    }\n    /**\n    Add the given array of decorations to the ones in the set,\n    producing a new set. Consumes the `decorations` array. Needs\n    access to the current document to create the appropriate tree\n    structure.\n    */\n    add(doc, decorations) {\n        if (!decorations.length)\n            return this;\n        if (this == empty)\n            return DecorationSet.create(doc, decorations);\n        return this.addInner(doc, decorations, 0);\n    }\n    addInner(doc, decorations, offset) {\n        let children, childIndex = 0;\n        doc.forEach((childNode, childOffset) => {\n            let baseOffset = childOffset + offset, found;\n            if (!(found = takeSpansForNode(decorations, childNode, baseOffset)))\n                return;\n            if (!children)\n                children = this.children.slice();\n            while (childIndex < children.length && children[childIndex] < childOffset)\n                childIndex += 3;\n            if (children[childIndex] == childOffset)\n                children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found, baseOffset + 1);\n            else\n                children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found, childNode, baseOffset + 1, noSpec));\n            childIndex += 3;\n        });\n        let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);\n        for (let i = 0; i < local.length; i++)\n            if (!local[i].type.valid(doc, local[i]))\n                local.splice(i--, 1);\n        return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);\n    }\n    /**\n    Create a new set that contains the decorations in this set, minus\n    the ones in the given array.\n    */\n    remove(decorations) {\n        if (decorations.length == 0 || this == empty)\n            return this;\n        return this.removeInner(decorations, 0);\n    }\n    removeInner(decorations, offset) {\n        let children = this.children, local = this.local;\n        for (let i = 0; i < children.length; i += 3) {\n            let found;\n            let from = children[i] + offset, to = children[i + 1] + offset;\n            for (let j = 0, span; j < decorations.length; j++)\n                if (span = decorations[j]) {\n                    if (span.from > from && span.to < to) {\n                        decorations[j] = null;\n                        (found || (found = [])).push(span);\n                    }\n                }\n            if (!found)\n                continue;\n            if (children == this.children)\n                children = this.children.slice();\n            let removed = children[i + 2].removeInner(found, from + 1);\n            if (removed != empty) {\n                children[i + 2] = removed;\n            }\n            else {\n                children.splice(i, 3);\n                i -= 3;\n            }\n        }\n        if (local.length)\n            for (let i = 0, span; i < decorations.length; i++)\n                if (span = decorations[i]) {\n                    for (let j = 0; j < local.length; j++)\n                        if (local[j].eq(span, offset)) {\n                            if (local == this.local)\n                                local = this.local.slice();\n                            local.splice(j--, 1);\n                        }\n                }\n        if (children == this.children && local == this.local)\n            return this;\n        return local.length || children.length ? new DecorationSet(local, children) : empty;\n    }\n    forChild(offset, node) {\n        if (this == empty)\n            return this;\n        if (node.isLeaf)\n            return DecorationSet.empty;\n        let child, local;\n        for (let i = 0; i < this.children.length; i += 3)\n            if (this.children[i] >= offset) {\n                if (this.children[i] == offset)\n                    child = this.children[i + 2];\n                break;\n            }\n        let start = offset + 1, end = start + node.content.size;\n        for (let i = 0; i < this.local.length; i++) {\n            let dec = this.local[i];\n            if (dec.from < end && dec.to > start && (dec.type instanceof InlineType)) {\n                let from = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start;\n                if (from < to)\n                    (local || (local = [])).push(dec.copy(from, to));\n            }\n        }\n        if (local) {\n            let localSet = new DecorationSet(local.sort(byPos), none);\n            return child ? new DecorationGroup([localSet, child]) : localSet;\n        }\n        return child || empty;\n    }\n    /**\n    @internal\n    */\n    eq(other) {\n        if (this == other)\n            return true;\n        if (!(other instanceof DecorationSet) ||\n            this.local.length != other.local.length ||\n            this.children.length != other.children.length)\n            return false;\n        for (let i = 0; i < this.local.length; i++)\n            if (!this.local[i].eq(other.local[i]))\n                return false;\n        for (let i = 0; i < this.children.length; i += 3)\n            if (this.children[i] != other.children[i] ||\n                this.children[i + 1] != other.children[i + 1] ||\n                !this.children[i + 2].eq(other.children[i + 2]))\n                return false;\n        return true;\n    }\n    /**\n    @internal\n    */\n    locals(node) {\n        return removeOverlap(this.localsInner(node));\n    }\n    /**\n    @internal\n    */\n    localsInner(node) {\n        if (this == empty)\n            return none;\n        if (node.inlineContent || !this.local.some(InlineType.is))\n            return this.local;\n        let result = [];\n        for (let i = 0; i < this.local.length; i++) {\n            if (!(this.local[i].type instanceof InlineType))\n                result.push(this.local[i]);\n        }\n        return result;\n    }\n    forEachSet(f) { f(this); }\n}\n/**\nThe empty set of decorations.\n*/\nDecorationSet.empty = new DecorationSet([], []);\n/**\n@internal\n*/\nDecorationSet.removeOverlap = removeOverlap;\nconst empty = DecorationSet.empty;\n// An abstraction that allows the code dealing with decorations to\n// treat multiple DecorationSet objects as if it were a single object\n// with (a subset of) the same interface.\nclass DecorationGroup {\n    constructor(members) {\n        this.members = members;\n    }\n    map(mapping, doc) {\n        const mappedDecos = this.members.map(member => member.map(mapping, doc, noSpec));\n        return DecorationGroup.from(mappedDecos);\n    }\n    forChild(offset, child) {\n        if (child.isLeaf)\n            return DecorationSet.empty;\n        let found = [];\n        for (let i = 0; i < this.members.length; i++) {\n            let result = this.members[i].forChild(offset, child);\n            if (result == empty)\n                continue;\n            if (result instanceof DecorationGroup)\n                found = found.concat(result.members);\n            else\n                found.push(result);\n        }\n        return DecorationGroup.from(found);\n    }\n    eq(other) {\n        if (!(other instanceof DecorationGroup) ||\n            other.members.length != this.members.length)\n            return false;\n        for (let i = 0; i < this.members.length; i++)\n            if (!this.members[i].eq(other.members[i]))\n                return false;\n        return true;\n    }\n    locals(node) {\n        let result, sorted = true;\n        for (let i = 0; i < this.members.length; i++) {\n            let locals = this.members[i].localsInner(node);\n            if (!locals.length)\n                continue;\n            if (!result) {\n                result = locals;\n            }\n            else {\n                if (sorted) {\n                    result = result.slice();\n                    sorted = false;\n                }\n                for (let j = 0; j < locals.length; j++)\n                    result.push(locals[j]);\n            }\n        }\n        return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;\n    }\n    // Create a group for the given array of decoration sets, or return\n    // a single set when possible.\n    static from(members) {\n        switch (members.length) {\n            case 0: return empty;\n            case 1: return members[0];\n            default: return new DecorationGroup(members.every(m => m instanceof DecorationSet) ? members :\n                members.reduce((r, m) => r.concat(m instanceof DecorationSet ? m : m.members), []));\n        }\n    }\n    forEachSet(f) {\n        for (let i = 0; i < this.members.length; i++)\n            this.members[i].forEachSet(f);\n    }\n}\nfunction mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {\n    let children = oldChildren.slice();\n    // Mark the children that are directly touched by changes, and\n    // move those that are after the changes.\n    for (let i = 0, baseOffset = oldOffset; i < mapping.maps.length; i++) {\n        let moved = 0;\n        mapping.maps[i].forEach((oldStart, oldEnd, newStart, newEnd) => {\n            let dSize = (newEnd - newStart) - (oldEnd - oldStart);\n            for (let i = 0; i < children.length; i += 3) {\n                let end = children[i + 1];\n                if (end < 0 || oldStart > end + baseOffset - moved)\n                    continue;\n                let start = children[i] + baseOffset - moved;\n                if (oldEnd >= start) {\n                    children[i + 1] = oldStart <= start ? -2 : -1;\n                }\n                else if (oldStart >= baseOffset && dSize) {\n                    children[i] += dSize;\n                    children[i + 1] += dSize;\n                }\n            }\n            moved += dSize;\n        });\n        baseOffset = mapping.maps[i].map(baseOffset, -1);\n    }\n    // Find the child nodes that still correspond to a single node,\n    // recursively call mapInner on them and update their positions.\n    let mustRebuild = false;\n    for (let i = 0; i < children.length; i += 3)\n        if (children[i + 1] < 0) { // Touched nodes\n            if (children[i + 1] == -2) {\n                mustRebuild = true;\n                children[i + 1] = -1;\n                continue;\n            }\n            let from = mapping.map(oldChildren[i] + oldOffset), fromLocal = from - offset;\n            if (fromLocal < 0 || fromLocal >= node.content.size) {\n                mustRebuild = true;\n                continue;\n            }\n            // Must read oldChildren because children was tagged with -1\n            let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset;\n            let { index, offset: childOffset } = node.content.findIndex(fromLocal);\n            let childNode = node.maybeChild(index);\n            if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {\n                let mapped = children[i + 2]\n                    .mapInner(mapping, childNode, from + 1, oldChildren[i] + oldOffset + 1, options);\n                if (mapped != empty) {\n                    children[i] = fromLocal;\n                    children[i + 1] = toLocal;\n                    children[i + 2] = mapped;\n                }\n                else {\n                    children[i + 1] = -2;\n                    mustRebuild = true;\n                }\n            }\n            else {\n                mustRebuild = true;\n            }\n        }\n    // Remaining children must be collected and rebuilt into the appropriate structure\n    if (mustRebuild) {\n        let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset, oldOffset, options);\n        let built = buildTree(decorations, node, 0, options);\n        newLocal = built.local;\n        for (let i = 0; i < children.length; i += 3)\n            if (children[i + 1] < 0) {\n                children.splice(i, 3);\n                i -= 3;\n            }\n        for (let i = 0, j = 0; i < built.children.length; i += 3) {\n            let from = built.children[i];\n            while (j < children.length && children[j] < from)\n                j += 3;\n            children.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2]);\n        }\n    }\n    return new DecorationSet(newLocal.sort(byPos), children);\n}\nfunction moveSpans(spans, offset) {\n    if (!offset || !spans.length)\n        return spans;\n    let result = [];\n    for (let i = 0; i < spans.length; i++) {\n        let span = spans[i];\n        result.push(new Decoration(span.from + offset, span.to + offset, span.type));\n    }\n    return result;\n}\nfunction mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {\n    // Gather all decorations from the remaining marked children\n    function gather(set, oldOffset) {\n        for (let i = 0; i < set.local.length; i++) {\n            let mapped = set.local[i].map(mapping, offset, oldOffset);\n            if (mapped)\n                decorations.push(mapped);\n            else if (options.onRemove)\n                options.onRemove(set.local[i].spec);\n        }\n        for (let i = 0; i < set.children.length; i += 3)\n            gather(set.children[i + 2], set.children[i] + oldOffset + 1);\n    }\n    for (let i = 0; i < children.length; i += 3)\n        if (children[i + 1] == -1)\n            gather(children[i + 2], oldChildren[i] + oldOffset + 1);\n    return decorations;\n}\nfunction takeSpansForNode(spans, node, offset) {\n    if (node.isLeaf)\n        return null;\n    let end = offset + node.nodeSize, found = null;\n    for (let i = 0, span; i < spans.length; i++) {\n        if ((span = spans[i]) && span.from > offset && span.to < end) {\n            (found || (found = [])).push(span);\n            spans[i] = null;\n        }\n    }\n    return found;\n}\nfunction withoutNulls(array) {\n    let result = [];\n    for (let i = 0; i < array.length; i++)\n        if (array[i] != null)\n            result.push(array[i]);\n    return result;\n}\n// Build up a tree that corresponds to a set of decorations. `offset`\n// is a base offset that should be subtracted from the `from` and `to`\n// positions in the spans (so that we don't have to allocate new spans\n// for recursive calls).\nfunction buildTree(spans, node, offset, options) {\n    let children = [], hasNulls = false;\n    node.forEach((childNode, localStart) => {\n        let found = takeSpansForNode(spans, childNode, localStart + offset);\n        if (found) {\n            hasNulls = true;\n            let subtree = buildTree(found, childNode, offset + localStart + 1, options);\n            if (subtree != empty)\n                children.push(localStart, localStart + childNode.nodeSize, subtree);\n        }\n    });\n    let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);\n    for (let i = 0; i < locals.length; i++)\n        if (!locals[i].type.valid(node, locals[i])) {\n            if (options.onRemove)\n                options.onRemove(locals[i].spec);\n            locals.splice(i--, 1);\n        }\n    return locals.length || children.length ? new DecorationSet(locals, children) : empty;\n}\n// Used to sort decorations so that ones with a low start position\n// come first, and within a set with the same start position, those\n// with an smaller end position come first.\nfunction byPos(a, b) {\n    return a.from - b.from || a.to - b.to;\n}\n// Scan a sorted array of decorations for partially overlapping spans,\n// and split those so that only fully overlapping spans are left (to\n// make subsequent rendering easier). Will return the input array if\n// no partially overlapping spans are found (the common case).\nfunction removeOverlap(spans) {\n    let working = spans;\n    for (let i = 0; i < working.length - 1; i++) {\n        let span = working[i];\n        if (span.from != span.to)\n            for (let j = i + 1; j < working.length; j++) {\n                let next = working[j];\n                if (next.from == span.from) {\n                    if (next.to != span.to) {\n                        if (working == spans)\n                            working = spans.slice();\n                        // Followed by a partially overlapping larger span. Split that\n                        // span.\n                        working[j] = next.copy(next.from, span.to);\n                        insertAhead(working, j + 1, next.copy(span.to, next.to));\n                    }\n                    continue;\n                }\n                else {\n                    if (next.from < span.to) {\n                        if (working == spans)\n                            working = spans.slice();\n                        // The end of this one overlaps with a subsequent span. Split\n                        // this one.\n                        working[i] = span.copy(span.from, next.from);\n                        insertAhead(working, j, span.copy(next.from, span.to));\n                    }\n                    break;\n                }\n            }\n    }\n    return working;\n}\nfunction insertAhead(array, i, deco) {\n    while (i < array.length && byPos(deco, array[i]) > 0)\n        i++;\n    array.splice(i, 0, deco);\n}\n// Get the decorations associated with the current props of a view.\nfunction viewDecorations(view) {\n    let found = [];\n    view.someProp(\"decorations\", f => {\n        let result = f(view.state);\n        if (result && result != empty)\n            found.push(result);\n    });\n    if (view.cursorWrapper)\n        found.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));\n    return DecorationGroup.from(found);\n}\n\nconst observeOptions = {\n    childList: true,\n    characterData: true,\n    characterDataOldValue: true,\n    attributes: true,\n    attributeOldValue: true,\n    subtree: true\n};\n// IE11 has very broken mutation observers, so we also listen to DOMCharacterDataModified\nconst useCharData = ie && ie_version <= 11;\nclass SelectionState {\n    constructor() {\n        this.anchorNode = null;\n        this.anchorOffset = 0;\n        this.focusNode = null;\n        this.focusOffset = 0;\n    }\n    set(sel) {\n        this.anchorNode = sel.anchorNode;\n        this.anchorOffset = sel.anchorOffset;\n        this.focusNode = sel.focusNode;\n        this.focusOffset = sel.focusOffset;\n    }\n    clear() {\n        this.anchorNode = this.focusNode = null;\n    }\n    eq(sel) {\n        return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset &&\n            sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;\n    }\n}\nclass DOMObserver {\n    constructor(view, handleDOMChange) {\n        this.view = view;\n        this.handleDOMChange = handleDOMChange;\n        this.queue = [];\n        this.flushingSoon = -1;\n        this.observer = null;\n        this.currentSelection = new SelectionState;\n        this.onCharData = null;\n        this.suppressingSelectionUpdates = false;\n        this.lastChangedTextNode = null;\n        this.observer = window.MutationObserver &&\n            new window.MutationObserver(mutations => {\n                for (let i = 0; i < mutations.length; i++)\n                    this.queue.push(mutations[i]);\n                if (ie && ie_version <= 11 && mutations.some(m => m.type == \"childList\" && m.removedNodes.length ||\n                    m.type == \"characterData\" && m.oldValue.length > m.target.nodeValue.length)) {\n                    // IE11 will sometimes (on backspacing out a single character\n                    // text node after a BR node) call the observer callback\n                    // before actually updating the DOM, which will cause\n                    // ProseMirror to miss the change (see #930)\n                    this.flushSoon();\n                }\n                else if (safari && view.composing && mutations.some(m => m.type == \"childList\" && m.target.nodeName == \"TR\")) {\n                    // Safari does weird stuff when finishing a composition in a\n                    // table cell, which tends to involve inserting inappropriate\n                    // nodes in the table row.\n                    view.input.badSafariComposition = true;\n                    this.flushSoon();\n                }\n                else {\n                    this.flush();\n                }\n            });\n        if (useCharData) {\n            this.onCharData = e => {\n                this.queue.push({ target: e.target, type: \"characterData\", oldValue: e.prevValue });\n                this.flushSoon();\n            };\n        }\n        this.onSelectionChange = this.onSelectionChange.bind(this);\n    }\n    flushSoon() {\n        if (this.flushingSoon < 0)\n            this.flushingSoon = window.setTimeout(() => { this.flushingSoon = -1; this.flush(); }, 20);\n    }\n    forceFlush() {\n        if (this.flushingSoon > -1) {\n            window.clearTimeout(this.flushingSoon);\n            this.flushingSoon = -1;\n            this.flush();\n        }\n    }\n    start() {\n        if (this.observer) {\n            this.observer.takeRecords();\n            this.observer.observe(this.view.dom, observeOptions);\n        }\n        if (this.onCharData)\n            this.view.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData);\n        this.connectSelection();\n    }\n    stop() {\n        if (this.observer) {\n            let take = this.observer.takeRecords();\n            if (take.length) {\n                for (let i = 0; i < take.length; i++)\n                    this.queue.push(take[i]);\n                window.setTimeout(() => this.flush(), 20);\n            }\n            this.observer.disconnect();\n        }\n        if (this.onCharData)\n            this.view.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData);\n        this.disconnectSelection();\n    }\n    connectSelection() {\n        this.view.dom.ownerDocument.addEventListener(\"selectionchange\", this.onSelectionChange);\n    }\n    disconnectSelection() {\n        this.view.dom.ownerDocument.removeEventListener(\"selectionchange\", this.onSelectionChange);\n    }\n    suppressSelectionUpdates() {\n        this.suppressingSelectionUpdates = true;\n        setTimeout(() => this.suppressingSelectionUpdates = false, 50);\n    }\n    onSelectionChange() {\n        if (!hasFocusAndSelection(this.view))\n            return;\n        if (this.suppressingSelectionUpdates)\n            return selectionToDOM(this.view);\n        // Deletions on IE11 fire their events in the wrong order, giving\n        // us a selection change event before the DOM changes are\n        // reported.\n        if (ie && ie_version <= 11 && !this.view.state.selection.empty) {\n            let sel = this.view.domSelectionRange();\n            // Selection.isCollapsed isn't reliable on IE\n            if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))\n                return this.flushSoon();\n        }\n        this.flush();\n    }\n    setCurSelection() {\n        this.currentSelection.set(this.view.domSelectionRange());\n    }\n    ignoreSelectionChange(sel) {\n        if (!sel.focusNode)\n            return true;\n        let ancestors = new Set, container;\n        for (let scan = sel.focusNode; scan; scan = parentNode(scan))\n            ancestors.add(scan);\n        for (let scan = sel.anchorNode; scan; scan = parentNode(scan))\n            if (ancestors.has(scan)) {\n                container = scan;\n                break;\n            }\n        let desc = container && this.view.docView.nearestDesc(container);\n        if (desc && desc.ignoreMutation({\n            type: \"selection\",\n            target: container.nodeType == 3 ? container.parentNode : container\n        })) {\n            this.setCurSelection();\n            return true;\n        }\n    }\n    pendingRecords() {\n        if (this.observer)\n            for (let mut of this.observer.takeRecords())\n                this.queue.push(mut);\n        return this.queue;\n    }\n    flush() {\n        let { view } = this;\n        if (!view.docView || this.flushingSoon > -1)\n            return;\n        let mutations = this.pendingRecords();\n        if (mutations.length)\n            this.queue = [];\n        let sel = view.domSelectionRange();\n        let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);\n        let from = -1, to = -1, typeOver = false, added = [];\n        if (view.editable) {\n            for (let i = 0; i < mutations.length; i++) {\n                let result = this.registerMutation(mutations[i], added);\n                if (result) {\n                    from = from < 0 ? result.from : Math.min(result.from, from);\n                    to = to < 0 ? result.to : Math.max(result.to, to);\n                    if (result.typeOver)\n                        typeOver = true;\n                }\n            }\n        }\n        if (gecko && added.length) {\n            let brs = added.filter(n => n.nodeName == \"BR\");\n            if (brs.length == 2) {\n                let [a, b] = brs;\n                if (a.parentNode && a.parentNode.parentNode == b.parentNode)\n                    b.remove();\n                else\n                    a.remove();\n            }\n            else {\n                let { focusNode } = this.currentSelection;\n                for (let br of brs) {\n                    let parent = br.parentNode;\n                    if (parent && parent.nodeName == \"LI\" && (!focusNode || blockParent(view, focusNode) != parent))\n                        br.remove();\n                }\n            }\n        }\n        else if ((chrome || safari) && added.some(n => n.nodeName == \"BR\") &&\n            (view.input.lastKeyCode == 8 || view.input.lastKeyCode == 46)) {\n            // Chrome/Safari sometimes insert a bogus break node if you\n            // backspace out the last bit of text before an inline-flex node (#1552)\n            for (let node of added)\n                if (node.nodeName == \"BR\" && node.parentNode) {\n                    let after = node.nextSibling;\n                    if (after && after.nodeType == 1 && after.contentEditable == \"false\")\n                        node.parentNode.removeChild(node);\n                }\n        }\n        let readSel = null;\n        // If it looks like the browser has reset the selection to the\n        // start of the document after focus, restore the selection from\n        // the state\n        if (from < 0 && newSel && view.input.lastFocus > Date.now() - 200 &&\n            Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 &&\n            selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) &&\n            readSel.eq(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(view.state.doc.resolve(0), 1))) {\n            view.input.lastFocus = 0;\n            selectionToDOM(view);\n            this.currentSelection.set(sel);\n            view.scrollToSelection();\n        }\n        else if (from > -1 || newSel) {\n            if (from > -1) {\n                view.docView.markDirty(from, to);\n                checkCSS(view);\n            }\n            if (view.input.badSafariComposition) {\n                view.input.badSafariComposition = false;\n                fixUpBadSafariComposition(view, added);\n            }\n            this.handleDOMChange(from, to, typeOver, added);\n            if (view.docView && view.docView.dirty)\n                view.updateState(view.state);\n            else if (!this.currentSelection.eq(sel))\n                selectionToDOM(view);\n            this.currentSelection.set(sel);\n        }\n    }\n    registerMutation(mut, added) {\n        // Ignore mutations inside nodes that were already noted as inserted\n        if (added.indexOf(mut.target) > -1)\n            return null;\n        let desc = this.view.docView.nearestDesc(mut.target);\n        if (mut.type == \"attributes\" &&\n            (desc == this.view.docView || mut.attributeName == \"contenteditable\" ||\n                // Firefox sometimes fires spurious events for null/empty styles\n                (mut.attributeName == \"style\" && !mut.oldValue && !mut.target.getAttribute(\"style\"))))\n            return null;\n        if (!desc || desc.ignoreMutation(mut))\n            return null;\n        if (mut.type == \"childList\") {\n            for (let i = 0; i < mut.addedNodes.length; i++) {\n                let node = mut.addedNodes[i];\n                added.push(node);\n                if (node.nodeType == 3)\n                    this.lastChangedTextNode = node;\n            }\n            if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))\n                return { from: desc.posBefore, to: desc.posAfter };\n            let prev = mut.previousSibling, next = mut.nextSibling;\n            if (ie && ie_version <= 11 && mut.addedNodes.length) {\n                // IE11 gives us incorrect next/prev siblings for some\n                // insertions, so if there are added nodes, recompute those\n                for (let i = 0; i < mut.addedNodes.length; i++) {\n                    let { previousSibling, nextSibling } = mut.addedNodes[i];\n                    if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)\n                        prev = previousSibling;\n                    if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)\n                        next = nextSibling;\n                }\n            }\n            let fromOffset = prev && prev.parentNode == mut.target\n                ? domIndex(prev) + 1 : 0;\n            let from = desc.localPosFromDOM(mut.target, fromOffset, -1);\n            let toOffset = next && next.parentNode == mut.target\n                ? domIndex(next) : mut.target.childNodes.length;\n            let to = desc.localPosFromDOM(mut.target, toOffset, 1);\n            return { from, to };\n        }\n        else if (mut.type == \"attributes\") {\n            return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };\n        }\n        else { // \"characterData\"\n            this.lastChangedTextNode = mut.target;\n            return {\n                from: desc.posAtStart,\n                to: desc.posAtEnd,\n                // An event was generated for a text change that didn't change\n                // any text. Mark the dom change to fall back to assuming the\n                // selection was typed over with an identical value if it can't\n                // find another change.\n                typeOver: mut.target.nodeValue == mut.oldValue\n            };\n        }\n    }\n}\nlet cssChecked = new WeakMap();\nlet cssCheckWarned = false;\nfunction checkCSS(view) {\n    if (cssChecked.has(view))\n        return;\n    cssChecked.set(view, null);\n    if (['normal', 'nowrap', 'pre-line'].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {\n        view.requiresGeckoHackNode = gecko;\n        if (cssCheckWarned)\n            return;\n        console[\"warn\"](\"ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.\");\n        cssCheckWarned = true;\n    }\n}\nfunction rangeToSelectionRange(view, range) {\n    let anchorNode = range.startContainer, anchorOffset = range.startOffset;\n    let focusNode = range.endContainer, focusOffset = range.endOffset;\n    let currentAnchor = view.domAtPos(view.state.selection.anchor);\n    // Since such a range doesn't distinguish between anchor and head,\n    // use a heuristic that flips it around if its end matches the\n    // current anchor.\n    if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset))\n        [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];\n    return { anchorNode, anchorOffset, focusNode, focusOffset };\n}\n// Used to work around a Safari Selection/shadow DOM bug\n// Based on https://github.com/codemirror/dev/issues/414 fix\nfunction safariShadowSelectionRange(view, selection) {\n    if (selection.getComposedRanges) {\n        let range = selection.getComposedRanges(view.root)[0];\n        if (range)\n            return rangeToSelectionRange(view, range);\n    }\n    let found;\n    function read(event) {\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        found = event.getTargetRanges()[0];\n    }\n    // Because Safari (at least in 2018-2022) doesn't provide regular\n    // access to the selection inside a shadowRoot, we have to perform a\n    // ridiculous hack to get at itusing `execCommand` to trigger a\n    // `beforeInput` event so that we can read the target range from the\n    // event.\n    view.dom.addEventListener(\"beforeinput\", read, true);\n    document.execCommand(\"indent\");\n    view.dom.removeEventListener(\"beforeinput\", read, true);\n    return found ? rangeToSelectionRange(view, found) : null;\n}\nfunction blockParent(view, node) {\n    for (let p = node.parentNode; p && p != view.dom; p = p.parentNode) {\n        let desc = view.docView.nearestDesc(p, true);\n        if (desc && desc.node.isBlock)\n            return p;\n    }\n    return null;\n}\n// Kludge for a Safari bug where, on ending a composition in an\n// otherwise empty table cell, it randomly moves the composed text\n// into the table row around that cell, greatly confusing everything\n// (#188).\nfunction fixUpBadSafariComposition(view, addedNodes) {\n    var _a;\n    let { focusNode, focusOffset } = view.domSelectionRange();\n    for (let node of addedNodes) {\n        if (((_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.nodeName) == \"TR\") {\n            let nextCell = node.nextSibling;\n            while (nextCell && (nextCell.nodeName != \"TD\" && nextCell.nodeName != \"TH\"))\n                nextCell = nextCell.nextSibling;\n            if (nextCell) {\n                let parent = nextCell;\n                for (;;) {\n                    let first = parent.firstChild;\n                    if (!first || first.nodeType != 1 || first.contentEditable == \"false\" ||\n                        /^(BR|IMG)$/.test(first.nodeName))\n                        break;\n                    parent = first;\n                }\n                parent.insertBefore(node, parent.firstChild);\n                if (focusNode == node)\n                    view.domSelection().collapse(node, focusOffset);\n            }\n            else {\n                node.parentNode.removeChild(node);\n            }\n        }\n    }\n}\n\n// Note that all referencing and parsing is done with the\n// start-of-operation selection and document, since that's the one\n// that the DOM represents. If any changes came in in the meantime,\n// the modification is mapped over those before it is applied, in\n// readDOMChange.\nfunction parseBetween(view, from_, to_) {\n    let { node: parent, fromOffset, toOffset, from, to } = view.docView.parseRange(from_, to_);\n    let domSel = view.domSelectionRange();\n    let find;\n    let anchor = domSel.anchorNode;\n    if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {\n        find = [{ node: anchor, offset: domSel.anchorOffset }];\n        if (!selectionCollapsed(domSel))\n            find.push({ node: domSel.focusNode, offset: domSel.focusOffset });\n    }\n    // Work around issue in Chrome where backspacing sometimes replaces\n    // the deleted content with a random BR node (issues #799, #831)\n    if (chrome && view.input.lastKeyCode === 8) {\n        for (let off = toOffset; off > fromOffset; off--) {\n            let node = parent.childNodes[off - 1], desc = node.pmViewDesc;\n            if (node.nodeName == \"BR\" && !desc) {\n                toOffset = off;\n                break;\n            }\n            if (!desc || desc.size)\n                break;\n        }\n    }\n    let startDoc = view.state.doc;\n    let parser = view.someProp(\"domParser\") || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMParser.fromSchema(view.state.schema);\n    let $from = startDoc.resolve(from);\n    let sel = null, doc = parser.parse(parent, {\n        topNode: $from.parent,\n        topMatch: $from.parent.contentMatchAt($from.index()),\n        topOpen: true,\n        from: fromOffset,\n        to: toOffset,\n        preserveWhitespace: $from.parent.type.whitespace == \"pre\" ? \"full\" : true,\n        findPositions: find,\n        ruleFromNode,\n        context: $from\n    });\n    if (find && find[0].pos != null) {\n        let anchor = find[0].pos, head = find[1] && find[1].pos;\n        if (head == null)\n            head = anchor;\n        sel = { anchor: anchor + from, head: head + from };\n    }\n    return { doc, sel, from, to };\n}\nfunction ruleFromNode(dom) {\n    let desc = dom.pmViewDesc;\n    if (desc) {\n        return desc.parseRule();\n    }\n    else if (dom.nodeName == \"BR\" && dom.parentNode) {\n        // Safari replaces the list item or table cell with a BR\n        // directly in the list node (?!) if you delete the last\n        // character in a list item or table cell (#708, #862)\n        if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {\n            let skip = document.createElement(\"div\");\n            skip.appendChild(document.createElement(\"li\"));\n            return { skip };\n        }\n        else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {\n            return { ignore: true };\n        }\n    }\n    else if (dom.nodeName == \"IMG\" && dom.getAttribute(\"mark-placeholder\")) {\n        return { ignore: true };\n    }\n    return null;\n}\nconst isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|img|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;\nfunction readDOMChange(view, from, to, typeOver, addedNodes) {\n    let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);\n    view.input.compositionPendingChanges = 0;\n    if (from < 0) {\n        let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;\n        let newSel = selectionFromDOM(view, origin);\n        if (newSel && !view.state.selection.eq(newSel)) {\n            if (chrome && android &&\n                view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime &&\n                view.someProp(\"handleKeyDown\", f => f(view, keyEvent(13, \"Enter\"))))\n                return;\n            let tr = view.state.tr.setSelection(newSel);\n            if (origin == \"pointer\")\n                tr.setMeta(\"pointer\", true);\n            else if (origin == \"key\")\n                tr.scrollIntoView();\n            if (compositionID)\n                tr.setMeta(\"composition\", compositionID);\n            view.dispatch(tr);\n        }\n        return;\n    }\n    let $before = view.state.doc.resolve(from);\n    let shared = $before.sharedDepth(to);\n    from = $before.before(shared + 1);\n    to = view.state.doc.resolve(to).after(shared + 1);\n    let sel = view.state.selection;\n    let parse = parseBetween(view, from, to);\n    let doc = view.state.doc, compare = doc.slice(parse.from, parse.to);\n    let preferredPos, preferredSide;\n    // Prefer anchoring to end when Backspace is pressed\n    if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {\n        preferredPos = view.state.selection.to;\n        preferredSide = \"end\";\n    }\n    else {\n        preferredPos = view.state.selection.from;\n        preferredSide = \"start\";\n    }\n    view.input.lastKeyCode = null;\n    let change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);\n    if (change)\n        view.input.domChangeCount++;\n    if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) &&\n        addedNodes.some(n => n.nodeType == 1 && !isInline.test(n.nodeName)) &&\n        (!change || change.endA >= change.endB) &&\n        view.someProp(\"handleKeyDown\", f => f(view, keyEvent(13, \"Enter\")))) {\n        view.input.lastIOSEnter = 0;\n        return;\n    }\n    if (!change) {\n        if (typeOver && sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) &&\n            !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {\n            change = { start: sel.from, endA: sel.to, endB: sel.to };\n        }\n        else {\n            if (parse.sel) {\n                let sel = resolveSelection(view, view.state.doc, parse.sel);\n                if (sel && !sel.eq(view.state.selection)) {\n                    let tr = view.state.tr.setSelection(sel);\n                    if (compositionID)\n                        tr.setMeta(\"composition\", compositionID);\n                    view.dispatch(tr);\n                }\n            }\n            return;\n        }\n    }\n    // Handle the case where overwriting a selection by typing matches\n    // the start or end of the selected content, creating a change\n    // that's smaller than what was actually overwritten.\n    if (view.state.selection.from < view.state.selection.to &&\n        change.start == change.endB &&\n        view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) {\n        if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 &&\n            view.state.selection.from >= parse.from) {\n            change.start = view.state.selection.from;\n        }\n        else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 &&\n            view.state.selection.to <= parse.to) {\n            change.endB += (view.state.selection.to - change.endA);\n            change.endA = view.state.selection.to;\n        }\n    }\n    // IE11 will insert a non-breaking space _ahead_ of the space after\n    // the cursor space when adding a space before another space. When\n    // that happened, adjust the change to cover the space instead.\n    if (ie && ie_version <= 11 && change.endB == change.start + 1 &&\n        change.endA == change.start && change.start > parse.from &&\n        parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == \" \\u00a0\") {\n        change.start--;\n        change.endA--;\n        change.endB--;\n    }\n    let $from = parse.doc.resolveNoCache(change.start - parse.from);\n    let $to = parse.doc.resolveNoCache(change.endB - parse.from);\n    let $fromA = doc.resolve(change.start);\n    let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;\n    // If this looks like the effect of pressing Enter (or was recorded\n    // as being an iOS enter press), just dispatch an Enter key instead.\n    if (((ios && view.input.lastIOSEnter > Date.now() - 225 &&\n        (!inlineChange || addedNodes.some(n => n.nodeName == \"DIV\" || n.nodeName == \"P\"))) ||\n        (!inlineChange && $from.pos < parse.doc.content.size &&\n            (!$from.sameParent($to) || !$from.parent.inlineContent) &&\n            $from.pos < $to.pos && !/\\S/.test(parse.doc.textBetween($from.pos, $to.pos, \"\", \"\")))) &&\n        view.someProp(\"handleKeyDown\", f => f(view, keyEvent(13, \"Enter\")))) {\n        view.input.lastIOSEnter = 0;\n        return;\n    }\n    // Same for backspace\n    if (view.state.selection.anchor > change.start &&\n        looksLikeBackspace(doc, change.start, change.endA, $from, $to) &&\n        view.someProp(\"handleKeyDown\", f => f(view, keyEvent(8, \"Backspace\")))) {\n        if (android && chrome)\n            view.domObserver.suppressSelectionUpdates(); // #820\n        return;\n    }\n    // Chrome will occasionally, during composition, delete the\n    // entire composition and then immediately insert it again. This is\n    // used to detect that situation.\n    if (chrome && change.endB == change.start)\n        view.input.lastChromeDelete = Date.now();\n    // This tries to detect Android virtual keyboard\n    // enter-and-pick-suggestion action. That sometimes (see issue\n    // #1059) first fires a DOM mutation, before moving the selection to\n    // the newly created block. And then, because ProseMirror cleans up\n    // the DOM selection, it gives up moving the selection entirely,\n    // leaving the cursor in the wrong place. When that happens, we drop\n    // the new paragraph from the initial change, and fire a simulated\n    // enter key afterwards.\n    if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth &&\n        parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {\n        change.endB -= 2;\n        $to = parse.doc.resolveNoCache(change.endB - parse.from);\n        setTimeout(() => {\n            view.someProp(\"handleKeyDown\", function (f) { return f(view, keyEvent(13, \"Enter\")); });\n        }, 20);\n    }\n    let chFrom = change.start, chTo = change.endA;\n    let mkTr = (base) => {\n        let tr = base || view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));\n        if (parse.sel) {\n            let sel = resolveSelection(view, tr.doc, parse.sel);\n            // Chrome will sometimes, during composition, report the\n            // selection in the wrong place. If it looks like that is\n            // happening, don't update the selection.\n            // Edge just doesn't move the cursor forward when you start typing\n            // in an empty block or between br nodes.\n            if (sel && !(chrome && view.composing && sel.empty &&\n                (change.start != change.endB || view.input.lastChromeDelete < Date.now() - 100) &&\n                (sel.head == chFrom || sel.head == tr.mapping.map(chTo) - 1) ||\n                ie && sel.empty && sel.head == chFrom))\n                tr.setSelection(sel);\n        }\n        if (compositionID)\n            tr.setMeta(\"composition\", compositionID);\n        return tr.scrollIntoView();\n    };\n    let markChange;\n    if (inlineChange) {\n        if ($from.pos == $to.pos) { // Deletion\n            // IE11 sometimes weirdly moves the DOM selection around after\n            // backspacing out the first element in a textblock\n            if (ie && ie_version <= 11 && $from.parentOffset == 0) {\n                view.domObserver.suppressSelectionUpdates();\n                setTimeout(() => selectionToDOM(view), 20);\n            }\n            let tr = mkTr(view.state.tr.delete(chFrom, chTo));\n            let marks = doc.resolve(change.start).marksAcross(doc.resolve(change.endA));\n            if (marks)\n                tr.ensureMarks(marks);\n            view.dispatch(tr);\n        }\n        else if ( // Adding or removing a mark\n        change.endA == change.endB &&\n            (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))) {\n            let tr = mkTr(view.state.tr);\n            if (markChange.type == \"add\")\n                tr.addMark(chFrom, chTo, markChange.mark);\n            else\n                tr.removeMark(chFrom, chTo, markChange.mark);\n            view.dispatch(tr);\n        }\n        else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {\n            // Both positions in the same text node -- simply insert text\n            let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);\n            let deflt = () => mkTr(view.state.tr.insertText(text, chFrom, chTo));\n            if (!view.someProp(\"handleTextInput\", f => f(view, chFrom, chTo, text, deflt)))\n                view.dispatch(deflt());\n        }\n        else {\n            view.dispatch(mkTr());\n        }\n    }\n    else {\n        view.dispatch(mkTr());\n    }\n}\nfunction resolveSelection(view, doc, parsedSel) {\n    if (Math.max(parsedSel.anchor, parsedSel.head) > doc.content.size)\n        return null;\n    return selectionBetween(view, doc.resolve(parsedSel.anchor), doc.resolve(parsedSel.head));\n}\n// Given two same-length, non-empty fragments of inline content,\n// determine whether the first could be created from the second by\n// removing or adding a single mark type.\nfunction isMarkChange(cur, prev) {\n    let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;\n    let added = curMarks, removed = prevMarks, type, mark, update;\n    for (let i = 0; i < prevMarks.length; i++)\n        added = prevMarks[i].removeFromSet(added);\n    for (let i = 0; i < curMarks.length; i++)\n        removed = curMarks[i].removeFromSet(removed);\n    if (added.length == 1 && removed.length == 0) {\n        mark = added[0];\n        type = \"add\";\n        update = (node) => node.mark(mark.addToSet(node.marks));\n    }\n    else if (added.length == 0 && removed.length == 1) {\n        mark = removed[0];\n        type = \"remove\";\n        update = (node) => node.mark(mark.removeFromSet(node.marks));\n    }\n    else {\n        return null;\n    }\n    let updated = [];\n    for (let i = 0; i < prev.childCount; i++)\n        updated.push(update(prev.child(i)));\n    if (prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated).eq(cur))\n        return { mark, type };\n}\nfunction looksLikeBackspace(old, start, end, $newStart, $newEnd) {\n    if ( // The content must have shrunk\n    end - start <= $newEnd.pos - $newStart.pos ||\n        // newEnd must point directly at or after the end of the block that newStart points into\n        skipClosingAndOpening($newStart, true, false) < $newEnd.pos)\n        return false;\n    let $start = old.resolve(start);\n    // Handle the case where, rather than joining blocks, the change just removed an entire block\n    if (!$newStart.parent.isTextblock) {\n        let after = $start.nodeAfter;\n        return after != null && end == start + after.nodeSize;\n    }\n    // Start must be at the end of a block\n    if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)\n        return false;\n    let $next = old.resolve(skipClosingAndOpening($start, true, true));\n    // The next textblock must start before end and end near it\n    if (!$next.parent.isTextblock || $next.pos > end ||\n        skipClosingAndOpening($next, true, false) < end)\n        return false;\n    // The fragments after the join point must match\n    return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);\n}\nfunction skipClosingAndOpening($pos, fromEnd, mayOpen) {\n    let depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;\n    while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {\n        depth--;\n        end++;\n        fromEnd = false;\n    }\n    if (mayOpen) {\n        let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));\n        while (next && !next.isLeaf) {\n            next = next.firstChild;\n            end++;\n        }\n    }\n    return end;\n}\nfunction findDiff(a, b, pos, preferredPos, preferredSide) {\n    let start = a.findDiffStart(b, pos);\n    if (start == null)\n        return null;\n    let { a: endA, b: endB } = a.findDiffEnd(b, pos + a.size, pos + b.size);\n    if (preferredSide == \"end\") {\n        let adjust = Math.max(0, start - Math.min(endA, endB));\n        preferredPos -= endA + adjust - start;\n    }\n    if (endA < start && a.size < b.size) {\n        let move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;\n        start -= move;\n        if (start && start < b.size && isSurrogatePair(b.textBetween(start - 1, start + 1)))\n            start += move ? 1 : -1;\n        endB = start + (endB - endA);\n        endA = start;\n    }\n    else if (endB < start) {\n        let move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;\n        start -= move;\n        if (start && start < a.size && isSurrogatePair(a.textBetween(start - 1, start + 1)))\n            start += move ? 1 : -1;\n        endA = start + (endA - endB);\n        endB = start;\n    }\n    return { start, endA, endB };\n}\nfunction isSurrogatePair(str) {\n    if (str.length != 2)\n        return false;\n    let a = str.charCodeAt(0), b = str.charCodeAt(1);\n    return a >= 0xDC00 && a <= 0xDFFF && b >= 0xD800 && b <= 0xDBFF;\n}\n\n/**\n@internal\n*/\nconst __parseFromClipboard = parseFromClipboard;\n/**\n@internal\n*/\nconst __endComposition = endComposition;\n/**\nAn editor view manages the DOM structure that represents an\neditable document. Its state and behavior are determined by its\n[props](https://prosemirror.net/docs/ref/#view.DirectEditorProps).\n*/\nclass EditorView {\n    /**\n    Create a view. `place` may be a DOM node that the editor should\n    be appended to, a function that will place it into the document,\n    or an object whose `mount` property holds the node to use as the\n    document container. If it is `null`, the editor will not be\n    added to the document.\n    */\n    constructor(place, props) {\n        this._root = null;\n        /**\n        @internal\n        */\n        this.focused = false;\n        /**\n        Kludge used to work around a Chrome bug @internal\n        */\n        this.trackWrites = null;\n        this.mounted = false;\n        /**\n        @internal\n        */\n        this.markCursor = null;\n        /**\n        @internal\n        */\n        this.cursorWrapper = null;\n        /**\n        @internal\n        */\n        this.lastSelectedViewDesc = undefined;\n        /**\n        @internal\n        */\n        this.input = new InputState;\n        this.prevDirectPlugins = [];\n        this.pluginViews = [];\n        /**\n        Holds `true` when a hack node is needed in Firefox to prevent the\n        [space is eaten issue](https://github.com/ProseMirror/prosemirror/issues/651)\n        @internal\n        */\n        this.requiresGeckoHackNode = false;\n        /**\n        When editor content is being dragged, this object contains\n        information about the dragged slice and whether it is being\n        copied or moved. At any other time, it is null.\n        */\n        this.dragging = null;\n        this._props = props;\n        this.state = props.state;\n        this.directPlugins = props.plugins || [];\n        this.directPlugins.forEach(checkStateComponent);\n        this.dispatch = this.dispatch.bind(this);\n        this.dom = (place && place.mount) || document.createElement(\"div\");\n        if (place) {\n            if (place.appendChild)\n                place.appendChild(this.dom);\n            else if (typeof place == \"function\")\n                place(this.dom);\n            else if (place.mount)\n                this.mounted = true;\n        }\n        this.editable = getEditable(this);\n        updateCursorWrapper(this);\n        this.nodeViews = buildNodeViews(this);\n        this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);\n        this.domObserver = new DOMObserver(this, (from, to, typeOver, added) => readDOMChange(this, from, to, typeOver, added));\n        this.domObserver.start();\n        initInput(this);\n        this.updatePluginViews();\n    }\n    /**\n    Holds `true` when a\n    [composition](https://w3c.github.io/uievents/#events-compositionevents)\n    is active.\n    */\n    get composing() { return this.input.composing; }\n    /**\n    The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).\n    */\n    get props() {\n        if (this._props.state != this.state) {\n            let prev = this._props;\n            this._props = {};\n            for (let name in prev)\n                this._props[name] = prev[name];\n            this._props.state = this.state;\n        }\n        return this._props;\n    }\n    /**\n    Update the view's props. Will immediately cause an update to\n    the DOM.\n    */\n    update(props) {\n        if (props.handleDOMEvents != this._props.handleDOMEvents)\n            ensureListeners(this);\n        let prevProps = this._props;\n        this._props = props;\n        if (props.plugins) {\n            props.plugins.forEach(checkStateComponent);\n            this.directPlugins = props.plugins;\n        }\n        this.updateStateInner(props.state, prevProps);\n    }\n    /**\n    Update the view by updating existing props object with the object\n    given as argument. Equivalent to `view.update(Object.assign({},\n    view.props, props))`.\n    */\n    setProps(props) {\n        let updated = {};\n        for (let name in this._props)\n            updated[name] = this._props[name];\n        updated.state = this.state;\n        for (let name in props)\n            updated[name] = props[name];\n        this.update(updated);\n    }\n    /**\n    Update the editor's `state` prop, without touching any of the\n    other props.\n    */\n    updateState(state) {\n        this.updateStateInner(state, this._props);\n    }\n    updateStateInner(state, prevProps) {\n        var _a;\n        let prev = this.state, redraw = false, updateSel = false;\n        // When stored marks are added, stop composition, so that they can\n        // be displayed.\n        if (state.storedMarks && this.composing) {\n            clearComposition(this);\n            updateSel = true;\n        }\n        this.state = state;\n        let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;\n        if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {\n            let nodeViews = buildNodeViews(this);\n            if (changedNodeViews(nodeViews, this.nodeViews)) {\n                this.nodeViews = nodeViews;\n                redraw = true;\n            }\n        }\n        if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {\n            ensureListeners(this);\n        }\n        this.editable = getEditable(this);\n        updateCursorWrapper(this);\n        let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);\n        let scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? \"reset\"\n            : state.scrollToSelection > prev.scrollToSelection ? \"to selection\" : \"preserve\";\n        let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);\n        if (updateDoc || !state.selection.eq(prev.selection))\n            updateSel = true;\n        let oldScrollPos = scroll == \"preserve\" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);\n        if (updateSel) {\n            this.domObserver.stop();\n            // Work around an issue in Chrome, IE, and Edge where changing\n            // the DOM around an active selection puts it into a broken\n            // state where the thing the user sees differs from the\n            // selection reported by the Selection object (#710, #973,\n            // #1011, #1013, #1035).\n            let forceSelUpdate = updateDoc && (ie || chrome) && !this.composing &&\n                !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);\n            if (updateDoc) {\n                // If the node that the selection points into is written to,\n                // Chrome sometimes starts misreporting the selection, so this\n                // tracks that and forces a selection reset when our update\n                // did write to the node.\n                let chromeKludge = chrome ? (this.trackWrites = this.domSelectionRange().focusNode) : null;\n                if (this.composing)\n                    this.input.compositionNode = findCompositionNode(this);\n                if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {\n                    this.docView.updateOuterDeco(outerDeco);\n                    this.docView.destroy();\n                    this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);\n                }\n                if (chromeKludge && (!this.trackWrites || !this.dom.contains(this.trackWrites)))\n                    forceSelUpdate = true;\n            }\n            // Work around for an issue where an update arriving right between\n            // a DOM selection change and the \"selectionchange\" event for it\n            // can cause a spurious DOM selection update, disrupting mouse\n            // drag selection.\n            if (forceSelUpdate ||\n                !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) &&\n                    anchorInRightPlace(this))) {\n                selectionToDOM(this, forceSelUpdate);\n            }\n            else {\n                syncNodeSelection(this, state.selection);\n                this.domObserver.setCurSelection();\n            }\n            this.domObserver.start();\n        }\n        this.updatePluginViews(prev);\n        if (((_a = this.dragging) === null || _a === void 0 ? void 0 : _a.node) && !prev.doc.eq(state.doc))\n            this.updateDraggedNode(this.dragging, prev);\n        if (scroll == \"reset\") {\n            this.dom.scrollTop = 0;\n        }\n        else if (scroll == \"to selection\") {\n            this.scrollToSelection();\n        }\n        else if (oldScrollPos) {\n            resetScrollPos(oldScrollPos);\n        }\n    }\n    /**\n    @internal\n    */\n    scrollToSelection() {\n        let startDOM = this.domSelectionRange().focusNode;\n        if (!startDOM || !this.dom.contains(startDOM.nodeType == 1 ? startDOM : startDOM.parentNode)) ;\n        else if (this.someProp(\"handleScrollToSelection\", f => f(this))) ;\n        else if (this.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) {\n            let target = this.docView.domAfterPos(this.state.selection.from);\n            if (target.nodeType == 1)\n                scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);\n        }\n        else {\n            scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);\n        }\n    }\n    destroyPluginViews() {\n        let view;\n        while (view = this.pluginViews.pop())\n            if (view.destroy)\n                view.destroy();\n    }\n    updatePluginViews(prevState) {\n        if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {\n            this.prevDirectPlugins = this.directPlugins;\n            this.destroyPluginViews();\n            for (let i = 0; i < this.directPlugins.length; i++) {\n                let plugin = this.directPlugins[i];\n                if (plugin.spec.view)\n                    this.pluginViews.push(plugin.spec.view(this));\n            }\n            for (let i = 0; i < this.state.plugins.length; i++) {\n                let plugin = this.state.plugins[i];\n                if (plugin.spec.view)\n                    this.pluginViews.push(plugin.spec.view(this));\n            }\n        }\n        else {\n            for (let i = 0; i < this.pluginViews.length; i++) {\n                let pluginView = this.pluginViews[i];\n                if (pluginView.update)\n                    pluginView.update(this, prevState);\n            }\n        }\n    }\n    updateDraggedNode(dragging, prev) {\n        let sel = dragging.node, found = -1;\n        if (this.state.doc.nodeAt(sel.from) == sel.node) {\n            found = sel.from;\n        }\n        else {\n            let movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);\n            let moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);\n            if (moved == sel.node)\n                found = movedPos;\n        }\n        this.dragging = new Dragging(dragging.slice, dragging.move, found < 0 ? undefined : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(this.state.doc, found));\n    }\n    someProp(propName, f) {\n        let prop = this._props && this._props[propName], value;\n        if (prop != null && (value = f ? f(prop) : prop))\n            return value;\n        for (let i = 0; i < this.directPlugins.length; i++) {\n            let prop = this.directPlugins[i].props[propName];\n            if (prop != null && (value = f ? f(prop) : prop))\n                return value;\n        }\n        let plugins = this.state.plugins;\n        if (plugins)\n            for (let i = 0; i < plugins.length; i++) {\n                let prop = plugins[i].props[propName];\n                if (prop != null && (value = f ? f(prop) : prop))\n                    return value;\n            }\n    }\n    /**\n    Query whether the view has focus.\n    */\n    hasFocus() {\n        // Work around IE not handling focus correctly if resize handles are shown.\n        // If the cursor is inside an element with resize handles, activeElement\n        // will be that element instead of this.dom.\n        if (ie) {\n            // If activeElement is within this.dom, and there are no other elements\n            // setting `contenteditable` to false in between, treat it as focused.\n            let node = this.root.activeElement;\n            if (node == this.dom)\n                return true;\n            if (!node || !this.dom.contains(node))\n                return false;\n            while (node && this.dom != node && this.dom.contains(node)) {\n                if (node.contentEditable == 'false')\n                    return false;\n                node = node.parentElement;\n            }\n            return true;\n        }\n        return this.root.activeElement == this.dom;\n    }\n    /**\n    Focus the editor.\n    */\n    focus() {\n        this.domObserver.stop();\n        if (this.editable)\n            focusPreventScroll(this.dom);\n        selectionToDOM(this);\n        this.domObserver.start();\n    }\n    /**\n    Get the document root in which the editor exists. This will\n    usually be the top-level `document`, but might be a [shadow\n    DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)\n    root if the editor is inside one.\n    */\n    get root() {\n        let cached = this._root;\n        if (cached == null)\n            for (let search = this.dom.parentNode; search; search = search.parentNode) {\n                if (search.nodeType == 9 || (search.nodeType == 11 && search.host)) {\n                    if (!search.getSelection)\n                        Object.getPrototypeOf(search).getSelection = () => search.ownerDocument.getSelection();\n                    return this._root = search;\n                }\n            }\n        return cached || document;\n    }\n    /**\n    When an existing editor view is moved to a new document or\n    shadow tree, call this to make it recompute its root.\n    */\n    updateRoot() {\n        this._root = null;\n    }\n    /**\n    Given a pair of viewport coordinates, return the document\n    position that corresponds to them. May return null if the given\n    coordinates aren't inside of the editor. When an object is\n    returned, its `pos` property is the position nearest to the\n    coordinates, and its `inside` property holds the position of the\n    inner node that the position falls inside of, or -1 if it is at\n    the top level, not in any node.\n    */\n    posAtCoords(coords) {\n        return posAtCoords(this, coords);\n    }\n    /**\n    Returns the viewport rectangle at a given document position.\n    `left` and `right` will be the same number, as this returns a\n    flat cursor-ish rectangle. If the position is between two things\n    that aren't directly adjacent, `side` determines which element\n    is used. When < 0, the element before the position is used,\n    otherwise the element after.\n    */\n    coordsAtPos(pos, side = 1) {\n        return coordsAtPos(this, pos, side);\n    }\n    /**\n    Find the DOM position that corresponds to the given document\n    position. When `side` is negative, find the position as close as\n    possible to the content before the position. When positive,\n    prefer positions close to the content after the position. When\n    zero, prefer as shallow a position as possible.\n    \n    Note that you should **not** mutate the editor's internal DOM,\n    only inspect it (and even that is usually not necessary).\n    */\n    domAtPos(pos, side = 0) {\n        return this.docView.domFromPos(pos, side);\n    }\n    /**\n    Find the DOM node that represents the document node after the\n    given position. May return `null` when the position doesn't point\n    in front of a node or if the node is inside an opaque node view.\n    \n    This is intended to be able to call things like\n    `getBoundingClientRect` on that DOM node. Do **not** mutate the\n    editor DOM directly, or add styling this way, since that will be\n    immediately overriden by the editor as it redraws the node.\n    */\n    nodeDOM(pos) {\n        let desc = this.docView.descAt(pos);\n        return desc ? desc.nodeDOM : null;\n    }\n    /**\n    Find the document position that corresponds to a given DOM\n    position. (Whenever possible, it is preferable to inspect the\n    document structure directly, rather than poking around in the\n    DOM, but sometimesfor example when interpreting an event\n    targetyou don't have a choice.)\n    \n    The `bias` parameter can be used to influence which side of a DOM\n    node to use when the position is inside a leaf node.\n    */\n    posAtDOM(node, offset, bias = -1) {\n        let pos = this.docView.posFromDOM(node, offset, bias);\n        if (pos == null)\n            throw new RangeError(\"DOM position not inside the editor\");\n        return pos;\n    }\n    /**\n    Find out whether the selection is at the end of a textblock when\n    moving in a given direction. When, for example, given `\"left\"`,\n    it will return true if moving left from the current cursor\n    position would leave that position's parent textblock. Will apply\n    to the view's current state by default, but it is possible to\n    pass a different state.\n    */\n    endOfTextblock(dir, state) {\n        return endOfTextblock(this, state || this.state, dir);\n    }\n    /**\n    Run the editor's paste logic with the given HTML string. The\n    `event`, if given, will be passed to the\n    [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.\n    */\n    pasteHTML(html, event) {\n        return doPaste(this, \"\", html, false, event || new ClipboardEvent(\"paste\"));\n    }\n    /**\n    Run the editor's paste logic with the given plain-text input.\n    */\n    pasteText(text, event) {\n        return doPaste(this, text, null, true, event || new ClipboardEvent(\"paste\"));\n    }\n    /**\n    Serialize the given slice as it would be if it was copied from\n    this editor. Returns a DOM element that contains a\n    representation of the slice as its children, a textual\n    representation, and the transformed slice (which can be\n    different from the given input due to hooks like\n    [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).\n    */\n    serializeForClipboard(slice) {\n        return serializeForClipboard(this, slice);\n    }\n    /**\n    Removes the editor from the DOM and destroys all [node\n    views](https://prosemirror.net/docs/ref/#view.NodeView).\n    */\n    destroy() {\n        if (!this.docView)\n            return;\n        destroyInput(this);\n        this.destroyPluginViews();\n        if (this.mounted) {\n            this.docView.update(this.state.doc, [], viewDecorations(this), this);\n            this.dom.textContent = \"\";\n        }\n        else if (this.dom.parentNode) {\n            this.dom.parentNode.removeChild(this.dom);\n        }\n        this.docView.destroy();\n        this.docView = null;\n        clearReusedRange();\n    }\n    /**\n    This is true when the view has been\n    [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be\n    used anymore).\n    */\n    get isDestroyed() {\n        return this.docView == null;\n    }\n    /**\n    Used for testing.\n    */\n    dispatchEvent(event) {\n        return dispatchEvent(this, event);\n    }\n    /**\n    @internal\n    */\n    domSelectionRange() {\n        let sel = this.domSelection();\n        if (!sel)\n            return { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };\n        return safari && this.root.nodeType === 11 &&\n            deepActiveElement(this.dom.ownerDocument) == this.dom && safariShadowSelectionRange(this, sel) || sel;\n    }\n    /**\n    @internal\n    */\n    domSelection() {\n        return this.root.getSelection();\n    }\n}\nEditorView.prototype.dispatch = function (tr) {\n    let dispatchTransaction = this._props.dispatchTransaction;\n    if (dispatchTransaction)\n        dispatchTransaction.call(this, tr);\n    else\n        this.updateState(this.state.apply(tr));\n};\nfunction computeDocDeco(view) {\n    let attrs = Object.create(null);\n    attrs.class = \"ProseMirror\";\n    attrs.contenteditable = String(view.editable);\n    view.someProp(\"attributes\", value => {\n        if (typeof value == \"function\")\n            value = value(view.state);\n        if (value)\n            for (let attr in value) {\n                if (attr == \"class\")\n                    attrs.class += \" \" + value[attr];\n                else if (attr == \"style\")\n                    attrs.style = (attrs.style ? attrs.style + \";\" : \"\") + value[attr];\n                else if (!attrs[attr] && attr != \"contenteditable\" && attr != \"nodeName\")\n                    attrs[attr] = String(value[attr]);\n            }\n    });\n    if (!attrs.translate)\n        attrs.translate = \"no\";\n    return [Decoration.node(0, view.state.doc.content.size, attrs)];\n}\nfunction updateCursorWrapper(view) {\n    if (view.markCursor) {\n        let dom = document.createElement(\"img\");\n        dom.className = \"ProseMirror-separator\";\n        dom.setAttribute(\"mark-placeholder\", \"true\");\n        dom.setAttribute(\"alt\", \"\");\n        view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.from, dom, { raw: true, marks: view.markCursor }) };\n    }\n    else {\n        view.cursorWrapper = null;\n    }\n}\nfunction getEditable(view) {\n    return !view.someProp(\"editable\", value => value(view.state) === false);\n}\nfunction selectionContextChanged(sel1, sel2) {\n    let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));\n    return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);\n}\nfunction buildNodeViews(view) {\n    let result = Object.create(null);\n    function add(obj) {\n        for (let prop in obj)\n            if (!Object.prototype.hasOwnProperty.call(result, prop))\n                result[prop] = obj[prop];\n    }\n    view.someProp(\"nodeViews\", add);\n    view.someProp(\"markViews\", add);\n    return result;\n}\nfunction changedNodeViews(a, b) {\n    let nA = 0, nB = 0;\n    for (let prop in a) {\n        if (a[prop] != b[prop])\n            return true;\n        nA++;\n    }\n    for (let _ in b)\n        nB++;\n    return nA != nB;\n}\nfunction checkStateComponent(plugin) {\n    if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)\n        throw new RangeError(\"Plugins passed directly to the view must not have a state component\");\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3Itdmlldy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQTBGO0FBQ047QUFDbEM7O0FBRWxEO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGlCQUFpQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsS0FBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFCQUFxQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNi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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsOEJBQThCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsOEJBQThCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0JBQW9CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlDQUFpQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtCQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsNERBQWE7QUFDbEU7QUFDQTtBQUNBLDRCQUE0Qiw0REFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGVBQWU7QUFDN0IsOERBQThELDREQUFhO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGVBQWU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNERBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDREQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0EscUJBQXFCLHdEQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDREQUFhO0FBQ3BDO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDREQUFhO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyw0REFBYTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0REFBYTtBQUM3Qix1Q0FBdUMsNERBQWE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw0REFBYTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNERBQWE7QUFDekMsK0JBQStCLDREQUFhO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdCQUFnQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsWUFBWTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxnQkFBZ0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLG9EQUFLO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtQkFBbUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCw0REFBYTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0JBQStCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtCQUErQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNkJBQTZCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsNERBQWE7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwrQkFBK0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwrREFBK0QsbUNBQW1DO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlGIiwic291cmNlcyI6WyJjOlxcVGV4dE9yXFxub2RlX21vZHVsZXNcXHByb3NlbWlycm9yLXZpZXdcXGRpc3RcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRleHRTZWxlY3Rpb24sIE5vZGVTZWxlY3Rpb24sIEFsbFNlbGVjdGlvbiwgU2VsZWN0aW9uIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuaW1wb3J0IHsgRE9NU2VyaWFsaXplciwgRnJhZ21lbnQsIE1hcmssIFNsaWNlLCBET01QYXJzZXIgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5pbXBvcnQgeyBkcm9wUG9pbnQgfSBmcm9tICdwcm9zZW1pcnJvci10cmFuc2Zvcm0nO1xuXG5jb25zdCBkb21JbmRleCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOzsgaW5kZXgrKykge1xuICAgICAgICBub2RlID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG59O1xuY29uc3QgcGFyZW50Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgbGV0IHBhcmVudCA9IG5vZGUuYXNzaWduZWRTbG90IHx8IG5vZGUucGFyZW50Tm9kZTtcbiAgICByZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSA9PSAxMSA/IHBhcmVudC5ob3N0IDogcGFyZW50O1xufTtcbmxldCByZXVzZWRSYW5nZSA9IG51bGw7XG4vLyBOb3RlIHRoYXQgdGhpcyB3aWxsIGFsd2F5cyByZXR1cm4gdGhlIHNhbWUgcmFuZ2UsIGJlY2F1c2UgRE9NIHJhbmdlXG4vLyBvYmplY3RzIGFyZSBldmVyeSBleHBlbnNpdmUsIGFuZCBrZWVwIHNsb3dpbmcgZG93biBzdWJzZXF1ZW50IERPTVxuLy8gdXBkYXRlcywgZm9yIHNvbWUgcmVhc29uLlxuY29uc3QgdGV4dFJhbmdlID0gZnVuY3Rpb24gKG5vZGUsIGZyb20sIHRvKSB7XG4gICAgbGV0IHJhbmdlID0gcmV1c2VkUmFuZ2UgfHwgKHJldXNlZFJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKSk7XG4gICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIHRvID09IG51bGwgPyBub2RlLm5vZGVWYWx1ZS5sZW5ndGggOiB0byk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgZnJvbSB8fCAwKTtcbiAgICByZXR1cm4gcmFuZ2U7XG59O1xuY29uc3QgY2xlYXJSZXVzZWRSYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXVzZWRSYW5nZSA9IG51bGw7XG59O1xuLy8gU2NhbnMgZm9yd2FyZCBhbmQgYmFja3dhcmQgdGhyb3VnaCBET00gcG9zaXRpb25zIGVxdWl2YWxlbnQgdG8gdGhlXG4vLyBnaXZlbiBvbmUgdG8gc2VlIGlmIHRoZSB0d28gYXJlIGluIHRoZSBzYW1lIHBsYWNlIChpLmUuIGFmdGVyIGFcbi8vIHRleHQgbm9kZSB2cyBhdCB0aGUgZW5kIG9mIHRoYXQgdGV4dCBub2RlKVxuY29uc3QgaXNFcXVpdmFsZW50UG9zaXRpb24gPSBmdW5jdGlvbiAobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYpIHtcbiAgICByZXR1cm4gdGFyZ2V0Tm9kZSAmJiAoc2NhbkZvcihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZiwgLTEpIHx8XG4gICAgICAgIHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIDEpKTtcbn07XG5jb25zdCBhdG9tRWxlbWVudHMgPSAvXihpbWd8YnJ8aW5wdXR8dGV4dGFyZWF8aHIpJC9pO1xuZnVuY3Rpb24gc2NhbkZvcihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZiwgZGlyKSB7XG4gICAgdmFyIF9hO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gdGFyZ2V0Tm9kZSAmJiBvZmYgPT0gdGFyZ2V0T2ZmKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChvZmYgPT0gKGRpciA8IDAgPyAwIDogbm9kZVNpemUobm9kZSkpKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQgfHwgcGFyZW50Lm5vZGVUeXBlICE9IDEgfHwgaGFzQmxvY2tEZXNjKG5vZGUpIHx8IGF0b21FbGVtZW50cy50ZXN0KG5vZGUubm9kZU5hbWUpIHx8XG4gICAgICAgICAgICAgICAgbm9kZS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIG9mZiA9IGRvbUluZGV4KG5vZGUpICsgKGRpciA8IDAgPyAwIDogMSk7XG4gICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gbm9kZS5jaGlsZE5vZGVzW29mZiArIChkaXIgPCAwID8gLTEgOiAwKV07XG4gICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMSAmJiBjaGlsZC5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKChfYSA9IGNoaWxkLnBtVmlld0Rlc2MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pZ25vcmVGb3JTZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgIG9mZiArPSBkaXI7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgb2ZmID0gZGlyIDwgMCA/IG5vZGVTaXplKG5vZGUpIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIG5vZGVTaXplKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PSAzID8gbm9kZS5ub2RlVmFsdWUubGVuZ3RoIDogbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIHRleHROb2RlQmVmb3JlJDEobm9kZSwgb2Zmc2V0KSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzICYmIG9mZnNldClcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmIG9mZnNldCA+IDApIHtcbiAgICAgICAgICAgIGlmIChub2RlLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgb2Zmc2V0ID0gbm9kZVNpemUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5wYXJlbnROb2RlICYmICFoYXNCbG9ja0Rlc2Mobm9kZSkpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IGRvbUluZGV4KG5vZGUpO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdGV4dE5vZGVBZnRlciQxKG5vZGUsIG9mZnNldCkge1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMyAmJiBvZmZzZXQgPCBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUgJiYgIWhhc0Jsb2NrRGVzYyhub2RlKSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gZG9tSW5kZXgobm9kZSkgKyAxO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaXNPbkVkZ2Uobm9kZSwgb2Zmc2V0LCBwYXJlbnQpIHtcbiAgICBmb3IgKGxldCBhdFN0YXJ0ID0gb2Zmc2V0ID09IDAsIGF0RW5kID0gb2Zmc2V0ID09IG5vZGVTaXplKG5vZGUpOyBhdFN0YXJ0IHx8IGF0RW5kOykge1xuICAgICAgICBpZiAobm9kZSA9PSBwYXJlbnQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbGV0IGluZGV4ID0gZG9tSW5kZXgobm9kZSk7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgYXRTdGFydCA9IGF0U3RhcnQgJiYgaW5kZXggPT0gMDtcbiAgICAgICAgYXRFbmQgPSBhdEVuZCAmJiBpbmRleCA9PSBub2RlU2l6ZShub2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYXNCbG9ja0Rlc2MoZG9tKSB7XG4gICAgbGV0IGRlc2M7XG4gICAgZm9yIChsZXQgY3VyID0gZG9tOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlKVxuICAgICAgICBpZiAoZGVzYyA9IGN1ci5wbVZpZXdEZXNjKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgcmV0dXJuIGRlc2MgJiYgZGVzYy5ub2RlICYmIGRlc2Mubm9kZS5pc0Jsb2NrICYmIChkZXNjLmRvbSA9PSBkb20gfHwgZGVzYy5jb250ZW50RE9NID09IGRvbSk7XG59XG4vLyBXb3JrIGFyb3VuZCBDaHJvbWUgaXNzdWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ3NTIzXG4vLyAoaXNDb2xsYXBzZWQgaW5hcHByb3ByaWF0ZWx5IHJldHVybnMgdHJ1ZSBpbiBzaGFkb3cgZG9tKVxuY29uc3Qgc2VsZWN0aW9uQ29sbGFwc2VkID0gZnVuY3Rpb24gKGRvbVNlbCkge1xuICAgIHJldHVybiBkb21TZWwuZm9jdXNOb2RlICYmIGlzRXF1aXZhbGVudFBvc2l0aW9uKGRvbVNlbC5mb2N1c05vZGUsIGRvbVNlbC5mb2N1c09mZnNldCwgZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpO1xufTtcbmZ1bmN0aW9uIGtleUV2ZW50KGtleUNvZGUsIGtleSkge1xuICAgIGxldCBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7XG4gICAgZXZlbnQuaW5pdEV2ZW50KFwia2V5ZG93blwiLCB0cnVlLCB0cnVlKTtcbiAgICBldmVudC5rZXlDb2RlID0ga2V5Q29kZTtcbiAgICBldmVudC5rZXkgPSBldmVudC5jb2RlID0ga2V5O1xuICAgIHJldHVybiBldmVudDtcbn1cbmZ1bmN0aW9uIGRlZXBBY3RpdmVFbGVtZW50KGRvYykge1xuICAgIGxldCBlbHQgPSBkb2MuYWN0aXZlRWxlbWVudDtcbiAgICB3aGlsZSAoZWx0ICYmIGVsdC5zaGFkb3dSb290KVxuICAgICAgICBlbHQgPSBlbHQuc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50O1xuICAgIHJldHVybiBlbHQ7XG59XG5mdW5jdGlvbiBjYXJldEZyb21Qb2ludChkb2MsIHgsIHkpIHtcbiAgICBpZiAoZG9jLmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQpIHtcbiAgICAgICAgdHJ5IHsgLy8gRmlyZWZveCB0aHJvd3MgZm9yIHRoaXMgY2FsbCBpbiBoYXJkLXRvLXByZWRpY3QgY2lyY3Vtc3RhbmNlcyAoIzk5NClcbiAgICAgICAgICAgIGxldCBwb3MgPSBkb2MuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCh4LCB5KTtcbiAgICAgICAgICAgIC8vIENsaXAgdGhlIG9mZnNldCwgYmVjYXVzZSBDaHJvbWUgd2lsbCByZXR1cm4gYSB0ZXh0IG9mZnNldFxuICAgICAgICAgICAgLy8gaW50byA8aW5wdXQ+IG5vZGVzLCB3aGljaCBjYW4ndCBiZSB0cmVhdGVkIGFzIGEgcmVndWxhciBET01cbiAgICAgICAgICAgIC8vIG9mZnNldFxuICAgICAgICAgICAgaWYgKHBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4geyBub2RlOiBwb3Mub2Zmc2V0Tm9kZSwgb2Zmc2V0OiBNYXRoLm1pbihub2RlU2l6ZShwb3Mub2Zmc2V0Tm9kZSksIHBvcy5vZmZzZXQpIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgIH1cbiAgICBpZiAoZG9jLmNhcmV0UmFuZ2VGcm9tUG9pbnQpIHtcbiAgICAgICAgbGV0IHJhbmdlID0gZG9jLmNhcmV0UmFuZ2VGcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgIGlmIChyYW5nZSlcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IHJhbmdlLnN0YXJ0Q29udGFpbmVyLCBvZmZzZXQ6IE1hdGgubWluKG5vZGVTaXplKHJhbmdlLnN0YXJ0Q29udGFpbmVyKSwgcmFuZ2Uuc3RhcnRPZmZzZXQpIH07XG4gICAgfVxufVxuXG5jb25zdCBuYXYgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgPyBuYXZpZ2F0b3IgOiBudWxsO1xuY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9IFwidW5kZWZpbmVkXCIgPyBkb2N1bWVudCA6IG51bGw7XG5jb25zdCBhZ2VudCA9IChuYXYgJiYgbmF2LnVzZXJBZ2VudCkgfHwgXCJcIjtcbmNvbnN0IGllX2VkZ2UgPSAvRWRnZVxcLyhcXGQrKS8uZXhlYyhhZ2VudCk7XG5jb25zdCBpZV91cHRvMTAgPSAvTVNJRSBcXGQvLmV4ZWMoYWdlbnQpO1xuY29uc3QgaWVfMTF1cCA9IC9UcmlkZW50XFwvKD86WzctOV18XFxkezIsfSlcXC4uKnJ2OihcXGQrKS8uZXhlYyhhZ2VudCk7XG5jb25zdCBpZSA9ICEhKGllX3VwdG8xMCB8fCBpZV8xMXVwIHx8IGllX2VkZ2UpO1xuY29uc3QgaWVfdmVyc2lvbiA9IGllX3VwdG8xMCA/IGRvY3VtZW50LmRvY3VtZW50TW9kZSA6IGllXzExdXAgPyAraWVfMTF1cFsxXSA6IGllX2VkZ2UgPyAraWVfZWRnZVsxXSA6IDA7XG5jb25zdCBnZWNrbyA9ICFpZSAmJiAvZ2Vja29cXC8oXFxkKykvaS50ZXN0KGFnZW50KTtcbmdlY2tvICYmICsoL0ZpcmVmb3hcXC8oXFxkKykvLmV4ZWMoYWdlbnQpIHx8IFswLCAwXSlbMV07XG5jb25zdCBfY2hyb21lID0gIWllICYmIC9DaHJvbWVcXC8oXFxkKykvLmV4ZWMoYWdlbnQpO1xuY29uc3QgY2hyb21lID0gISFfY2hyb21lO1xuY29uc3QgY2hyb21lX3ZlcnNpb24gPSBfY2hyb21lID8gK19jaHJvbWVbMV0gOiAwO1xuY29uc3Qgc2FmYXJpID0gIWllICYmICEhbmF2ICYmIC9BcHBsZSBDb21wdXRlci8udGVzdChuYXYudmVuZG9yKTtcbi8vIElzIHRydWUgZm9yIGJvdGggaU9TIGFuZCBpUGFkT1MgZm9yIGNvbnZlbmllbmNlXG5jb25zdCBpb3MgPSBzYWZhcmkgJiYgKC9Nb2JpbGVcXC9cXHcrLy50ZXN0KGFnZW50KSB8fCAhIW5hdiAmJiBuYXYubWF4VG91Y2hQb2ludHMgPiAyKTtcbmNvbnN0IG1hYyA9IGlvcyB8fCAobmF2ID8gL01hYy8udGVzdChuYXYucGxhdGZvcm0pIDogZmFsc2UpO1xuY29uc3Qgd2luZG93cyA9IG5hdiA/IC9XaW4vLnRlc3QobmF2LnBsYXRmb3JtKSA6IGZhbHNlO1xuY29uc3QgYW5kcm9pZCA9IC9BbmRyb2lkIFxcZC8udGVzdChhZ2VudCk7XG5jb25zdCB3ZWJraXQgPSAhIWRvYyAmJiBcIndlYmtpdEZvbnRTbW9vdGhpbmdcIiBpbiBkb2MuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xuY29uc3Qgd2Via2l0X3ZlcnNpb24gPSB3ZWJraXQgPyArKC9cXGJBcHBsZVdlYktpdFxcLyhcXGQrKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KSB8fCBbMCwgMF0pWzFdIDogMDtcblxuZnVuY3Rpb24gd2luZG93UmVjdChkb2MpIHtcbiAgICBsZXQgdnAgPSBkb2MuZGVmYXVsdFZpZXcgJiYgZG9jLmRlZmF1bHRWaWV3LnZpc3VhbFZpZXdwb3J0O1xuICAgIGlmICh2cClcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IDAsIHJpZ2h0OiB2cC53aWR0aCxcbiAgICAgICAgICAgIHRvcDogMCwgYm90dG9tOiB2cC5oZWlnaHRcbiAgICAgICAgfTtcbiAgICByZXR1cm4geyBsZWZ0OiAwLCByaWdodDogZG9jLmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCxcbiAgICAgICAgdG9wOiAwLCBib3R0b206IGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0IH07XG59XG5mdW5jdGlvbiBnZXRTaWRlKHZhbHVlLCBzaWRlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiID8gdmFsdWUgOiB2YWx1ZVtzaWRlXTtcbn1cbmZ1bmN0aW9uIGNsaWVudFJlY3Qobm9kZSkge1xuICAgIGxldCByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAvLyBBZGp1c3QgZm9yIGVsZW1lbnRzIHdpdGggc3R5bGUgXCJ0cmFuc2Zvcm06IHNjYWxlKClcIlxuICAgIGxldCBzY2FsZVggPSAocmVjdC53aWR0aCAvIG5vZGUub2Zmc2V0V2lkdGgpIHx8IDE7XG4gICAgbGV0IHNjYWxlWSA9IChyZWN0LmhlaWdodCAvIG5vZGUub2Zmc2V0SGVpZ2h0KSB8fCAxO1xuICAgIC8vIE1ha2Ugc3VyZSBzY3JvbGxiYXIgd2lkdGggaXNuJ3QgaW5jbHVkZWQgaW4gdGhlIHJlY3RhbmdsZVxuICAgIHJldHVybiB7IGxlZnQ6IHJlY3QubGVmdCwgcmlnaHQ6IHJlY3QubGVmdCArIG5vZGUuY2xpZW50V2lkdGggKiBzY2FsZVgsXG4gICAgICAgIHRvcDogcmVjdC50b3AsIGJvdHRvbTogcmVjdC50b3AgKyBub2RlLmNsaWVudEhlaWdodCAqIHNjYWxlWSB9O1xufVxuZnVuY3Rpb24gc2Nyb2xsUmVjdEludG9WaWV3KHZpZXcsIHJlY3QsIHN0YXJ0RE9NKSB7XG4gICAgbGV0IHNjcm9sbFRocmVzaG9sZCA9IHZpZXcuc29tZVByb3AoXCJzY3JvbGxUaHJlc2hvbGRcIikgfHwgMCwgc2Nyb2xsTWFyZ2luID0gdmlldy5zb21lUHJvcChcInNjcm9sbE1hcmdpblwiKSB8fCA1O1xuICAgIGxldCBkb2MgPSB2aWV3LmRvbS5vd25lckRvY3VtZW50O1xuICAgIGZvciAobGV0IHBhcmVudCA9IHN0YXJ0RE9NIHx8IHZpZXcuZG9tOzspIHtcbiAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKHBhcmVudC5ub2RlVHlwZSAhPSAxKSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnROb2RlKHBhcmVudCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZWx0ID0gcGFyZW50O1xuICAgICAgICBsZXQgYXRUb3AgPSBlbHQgPT0gZG9jLmJvZHk7XG4gICAgICAgIGxldCBib3VuZGluZyA9IGF0VG9wID8gd2luZG93UmVjdChkb2MpIDogY2xpZW50UmVjdChlbHQpO1xuICAgICAgICBsZXQgbW92ZVggPSAwLCBtb3ZlWSA9IDA7XG4gICAgICAgIGlmIChyZWN0LnRvcCA8IGJvdW5kaW5nLnRvcCArIGdldFNpZGUoc2Nyb2xsVGhyZXNob2xkLCBcInRvcFwiKSlcbiAgICAgICAgICAgIG1vdmVZID0gLShib3VuZGluZy50b3AgLSByZWN0LnRvcCArIGdldFNpZGUoc2Nyb2xsTWFyZ2luLCBcInRvcFwiKSk7XG4gICAgICAgIGVsc2UgaWYgKHJlY3QuYm90dG9tID4gYm91bmRpbmcuYm90dG9tIC0gZ2V0U2lkZShzY3JvbGxUaHJlc2hvbGQsIFwiYm90dG9tXCIpKVxuICAgICAgICAgICAgbW92ZVkgPSByZWN0LmJvdHRvbSAtIHJlY3QudG9wID4gYm91bmRpbmcuYm90dG9tIC0gYm91bmRpbmcudG9wXG4gICAgICAgICAgICAgICAgPyByZWN0LnRvcCArIGdldFNpZGUoc2Nyb2xsTWFyZ2luLCBcInRvcFwiKSAtIGJvdW5kaW5nLnRvcFxuICAgICAgICAgICAgICAgIDogcmVjdC5ib3R0b20gLSBib3VuZGluZy5ib3R0b20gKyBnZXRTaWRlKHNjcm9sbE1hcmdpbiwgXCJib3R0b21cIik7XG4gICAgICAgIGlmIChyZWN0LmxlZnQgPCBib3VuZGluZy5sZWZ0ICsgZ2V0U2lkZShzY3JvbGxUaHJlc2hvbGQsIFwibGVmdFwiKSlcbiAgICAgICAgICAgIG1vdmVYID0gLShib3VuZGluZy5sZWZ0IC0gcmVjdC5sZWZ0ICsgZ2V0U2lkZShzY3JvbGxNYXJnaW4sIFwibGVmdFwiKSk7XG4gICAgICAgIGVsc2UgaWYgKHJlY3QucmlnaHQgPiBib3VuZGluZy5yaWdodCAtIGdldFNpZGUoc2Nyb2xsVGhyZXNob2xkLCBcInJpZ2h0XCIpKVxuICAgICAgICAgICAgbW92ZVggPSByZWN0LnJpZ2h0IC0gYm91bmRpbmcucmlnaHQgKyBnZXRTaWRlKHNjcm9sbE1hcmdpbiwgXCJyaWdodFwiKTtcbiAgICAgICAgaWYgKG1vdmVYIHx8IG1vdmVZKSB7XG4gICAgICAgICAgICBpZiAoYXRUb3ApIHtcbiAgICAgICAgICAgICAgICBkb2MuZGVmYXVsdFZpZXcuc2Nyb2xsQnkobW92ZVgsIG1vdmVZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydFggPSBlbHQuc2Nyb2xsTGVmdCwgc3RhcnRZID0gZWx0LnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICBpZiAobW92ZVkpXG4gICAgICAgICAgICAgICAgICAgIGVsdC5zY3JvbGxUb3AgKz0gbW92ZVk7XG4gICAgICAgICAgICAgICAgaWYgKG1vdmVYKVxuICAgICAgICAgICAgICAgICAgICBlbHQuc2Nyb2xsTGVmdCArPSBtb3ZlWDtcbiAgICAgICAgICAgICAgICBsZXQgZFggPSBlbHQuc2Nyb2xsTGVmdCAtIHN0YXJ0WCwgZFkgPSBlbHQuc2Nyb2xsVG9wIC0gc3RhcnRZO1xuICAgICAgICAgICAgICAgIHJlY3QgPSB7IGxlZnQ6IHJlY3QubGVmdCAtIGRYLCB0b3A6IHJlY3QudG9wIC0gZFksIHJpZ2h0OiByZWN0LnJpZ2h0IC0gZFgsIGJvdHRvbTogcmVjdC5ib3R0b20gLSBkWSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBwb3MgPSBhdFRvcCA/IFwiZml4ZWRcIiA6IGdldENvbXB1dGVkU3R5bGUocGFyZW50KS5wb3NpdGlvbjtcbiAgICAgICAgaWYgKC9eKGZpeGVkfHN0aWNreSkkLy50ZXN0KHBvcykpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgcGFyZW50ID0gcG9zID09IFwiYWJzb2x1dGVcIiA/IHBhcmVudC5vZmZzZXRQYXJlbnQgOiBwYXJlbnROb2RlKHBhcmVudCk7XG4gICAgfVxufVxuLy8gU3RvcmUgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgZWRpdG9yJ3MgcGFyZW50IG5vZGVzLCBhbG9uZyB3aXRoXG4vLyB0aGUgdG9wIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgbmVhciB0aGUgdG9wIG9mIHRoZSBlZGl0b3IsIHdoaWNoXG4vLyB3aWxsIGJlIHVzZWQgdG8gbWFrZSBzdXJlIHRoZSB2aXNpYmxlIHZpZXdwb3J0IHJlbWFpbnMgc3RhYmxlIGV2ZW5cbi8vIHdoZW4gdGhlIHNpemUgb2YgdGhlIGNvbnRlbnQgYWJvdmUgY2hhbmdlcy5cbmZ1bmN0aW9uIHN0b3JlU2Nyb2xsUG9zKHZpZXcpIHtcbiAgICBsZXQgcmVjdCA9IHZpZXcuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBzdGFydFkgPSBNYXRoLm1heCgwLCByZWN0LnRvcCk7XG4gICAgbGV0IHJlZkRPTSwgcmVmVG9wO1xuICAgIGZvciAobGV0IHggPSAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyLCB5ID0gc3RhcnRZICsgMTsgeSA8IE1hdGgubWluKGlubmVySGVpZ2h0LCByZWN0LmJvdHRvbSk7IHkgKz0gNSkge1xuICAgICAgICBsZXQgZG9tID0gdmlldy5yb290LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgIGlmICghZG9tIHx8IGRvbSA9PSB2aWV3LmRvbSB8fCAhdmlldy5kb20uY29udGFpbnMoZG9tKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBsZXQgbG9jYWxSZWN0ID0gZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobG9jYWxSZWN0LnRvcCA+PSBzdGFydFkgLSAyMCkge1xuICAgICAgICAgICAgcmVmRE9NID0gZG9tO1xuICAgICAgICAgICAgcmVmVG9wID0gbG9jYWxSZWN0LnRvcDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHJlZkRPTTogcmVmRE9NLCByZWZUb3A6IHJlZlRvcCwgc3RhY2s6IHNjcm9sbFN0YWNrKHZpZXcuZG9tKSB9O1xufVxuZnVuY3Rpb24gc2Nyb2xsU3RhY2soZG9tKSB7XG4gICAgbGV0IHN0YWNrID0gW10sIGRvYyA9IGRvbS5vd25lckRvY3VtZW50O1xuICAgIGZvciAobGV0IGN1ciA9IGRvbTsgY3VyOyBjdXIgPSBwYXJlbnROb2RlKGN1cikpIHtcbiAgICAgICAgc3RhY2sucHVzaCh7IGRvbTogY3VyLCB0b3A6IGN1ci5zY3JvbGxUb3AsIGxlZnQ6IGN1ci5zY3JvbGxMZWZ0IH0pO1xuICAgICAgICBpZiAoZG9tID09IGRvYylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gc3RhY2s7XG59XG4vLyBSZXNldCB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBlZGl0b3IncyBwYXJlbnQgbm9kZXMgdG8gdGhhdCB3aGF0XG4vLyBpdCB3YXMgYmVmb3JlLCB3aGVuIHN0b3JlU2Nyb2xsUG9zIHdhcyBjYWxsZWQuXG5mdW5jdGlvbiByZXNldFNjcm9sbFBvcyh7IHJlZkRPTSwgcmVmVG9wLCBzdGFjayB9KSB7XG4gICAgbGV0IG5ld1JlZlRvcCA9IHJlZkRPTSA/IHJlZkRPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgOiAwO1xuICAgIHJlc3RvcmVTY3JvbGxTdGFjayhzdGFjaywgbmV3UmVmVG9wID09IDAgPyAwIDogbmV3UmVmVG9wIC0gcmVmVG9wKTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTY3JvbGxTdGFjayhzdGFjaywgZFRvcCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHsgZG9tLCB0b3AsIGxlZnQgfSA9IHN0YWNrW2ldO1xuICAgICAgICBpZiAoZG9tLnNjcm9sbFRvcCAhPSB0b3AgKyBkVG9wKVxuICAgICAgICAgICAgZG9tLnNjcm9sbFRvcCA9IHRvcCArIGRUb3A7XG4gICAgICAgIGlmIChkb20uc2Nyb2xsTGVmdCAhPSBsZWZ0KVxuICAgICAgICAgICAgZG9tLnNjcm9sbExlZnQgPSBsZWZ0O1xuICAgIH1cbn1cbmxldCBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0gbnVsbDtcbi8vIEZlYXR1cmUtZGV0ZWN0cyBzdXBwb3J0IGZvciAuZm9jdXMoe3ByZXZlbnRTY3JvbGw6IHRydWV9KSwgYW5kIHVzZXNcbi8vIGEgZmFsbGJhY2sga2x1ZGdlIHdoZW4gbm90IHN1cHBvcnRlZC5cbmZ1bmN0aW9uIGZvY3VzUHJldmVudFNjcm9sbChkb20pIHtcbiAgICBpZiAoZG9tLnNldEFjdGl2ZSlcbiAgICAgICAgcmV0dXJuIGRvbS5zZXRBY3RpdmUoKTsgLy8gaW4gSUVcbiAgICBpZiAocHJldmVudFNjcm9sbFN1cHBvcnRlZClcbiAgICAgICAgcmV0dXJuIGRvbS5mb2N1cyhwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKTtcbiAgICBsZXQgc3RvcmVkID0gc2Nyb2xsU3RhY2soZG9tKTtcbiAgICBkb20uZm9jdXMocHJldmVudFNjcm9sbFN1cHBvcnRlZCA9PSBudWxsID8ge1xuICAgICAgICBnZXQgcHJldmVudFNjcm9sbCgpIHtcbiAgICAgICAgICAgIHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSB7IHByZXZlbnRTY3JvbGw6IHRydWUgfTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSA6IHVuZGVmaW5lZCk7XG4gICAgaWYgKCFwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKSB7XG4gICAgICAgIHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmVzdG9yZVNjcm9sbFN0YWNrKHN0b3JlZCwgMCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZE9mZnNldEluTm9kZShub2RlLCBjb29yZHMpIHtcbiAgICBsZXQgY2xvc2VzdCwgZHhDbG9zZXN0ID0gMmU4LCBjb29yZHNDbG9zZXN0LCBvZmZzZXQgPSAwO1xuICAgIGxldCByb3dCb3QgPSBjb29yZHMudG9wLCByb3dUb3AgPSBjb29yZHMudG9wO1xuICAgIGxldCBmaXJzdEJlbG93LCBjb29yZHNCZWxvdztcbiAgICBmb3IgKGxldCBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZCwgY2hpbGRJbmRleCA9IDA7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nLCBjaGlsZEluZGV4KyspIHtcbiAgICAgICAgbGV0IHJlY3RzO1xuICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgIHJlY3RzID0gY2hpbGQuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgZWxzZSBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgIHJlY3RzID0gdGV4dFJhbmdlKGNoaWxkKS5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tpXTtcbiAgICAgICAgICAgIGlmIChyZWN0LnRvcCA8PSByb3dCb3QgJiYgcmVjdC5ib3R0b20gPj0gcm93VG9wKSB7XG4gICAgICAgICAgICAgICAgcm93Qm90ID0gTWF0aC5tYXgocmVjdC5ib3R0b20sIHJvd0JvdCk7XG4gICAgICAgICAgICAgICAgcm93VG9wID0gTWF0aC5taW4ocmVjdC50b3AsIHJvd1RvcCk7XG4gICAgICAgICAgICAgICAgbGV0IGR4ID0gcmVjdC5sZWZ0ID4gY29vcmRzLmxlZnQgPyByZWN0LmxlZnQgLSBjb29yZHMubGVmdFxuICAgICAgICAgICAgICAgICAgICA6IHJlY3QucmlnaHQgPCBjb29yZHMubGVmdCA/IGNvb3Jkcy5sZWZ0IC0gcmVjdC5yaWdodCA6IDA7XG4gICAgICAgICAgICAgICAgaWYgKGR4IDwgZHhDbG9zZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3QgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgZHhDbG9zZXN0ID0gZHg7XG4gICAgICAgICAgICAgICAgICAgIGNvb3Jkc0Nsb3Nlc3QgPSBkeCAmJiBjbG9zZXN0Lm5vZGVUeXBlID09IDMgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiByZWN0LnJpZ2h0IDwgY29vcmRzLmxlZnQgPyByZWN0LnJpZ2h0IDogcmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBjb29yZHMudG9wXG4gICAgICAgICAgICAgICAgICAgIH0gOiBjb29yZHM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAxICYmIGR4KVxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gY2hpbGRJbmRleCArIChjb29yZHMubGVmdCA+PSAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyID8gMSA6IDApO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZWN0LnRvcCA+IGNvb3Jkcy50b3AgJiYgIWZpcnN0QmVsb3cgJiYgcmVjdC5sZWZ0IDw9IGNvb3Jkcy5sZWZ0ICYmIHJlY3QucmlnaHQgPj0gY29vcmRzLmxlZnQpIHtcbiAgICAgICAgICAgICAgICBmaXJzdEJlbG93ID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgY29vcmRzQmVsb3cgPSB7IGxlZnQ6IE1hdGgubWF4KHJlY3QubGVmdCwgTWF0aC5taW4ocmVjdC5yaWdodCwgY29vcmRzLmxlZnQpKSwgdG9wOiByZWN0LnRvcCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjbG9zZXN0ICYmIChjb29yZHMubGVmdCA+PSByZWN0LnJpZ2h0ICYmIGNvb3Jkcy50b3AgPj0gcmVjdC50b3AgfHxcbiAgICAgICAgICAgICAgICBjb29yZHMubGVmdCA+PSByZWN0LmxlZnQgJiYgY29vcmRzLnRvcCA+PSByZWN0LmJvdHRvbSkpXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gY2hpbGRJbmRleCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjbG9zZXN0ICYmIGZpcnN0QmVsb3cpIHtcbiAgICAgICAgY2xvc2VzdCA9IGZpcnN0QmVsb3c7XG4gICAgICAgIGNvb3Jkc0Nsb3Nlc3QgPSBjb29yZHNCZWxvdztcbiAgICAgICAgZHhDbG9zZXN0ID0gMDtcbiAgICB9XG4gICAgaWYgKGNsb3Nlc3QgJiYgY2xvc2VzdC5ub2RlVHlwZSA9PSAzKVxuICAgICAgICByZXR1cm4gZmluZE9mZnNldEluVGV4dChjbG9zZXN0LCBjb29yZHNDbG9zZXN0KTtcbiAgICBpZiAoIWNsb3Nlc3QgfHwgKGR4Q2xvc2VzdCAmJiBjbG9zZXN0Lm5vZGVUeXBlID09IDEpKVxuICAgICAgICByZXR1cm4geyBub2RlLCBvZmZzZXQgfTtcbiAgICByZXR1cm4gZmluZE9mZnNldEluTm9kZShjbG9zZXN0LCBjb29yZHNDbG9zZXN0KTtcbn1cbmZ1bmN0aW9uIGZpbmRPZmZzZXRJblRleHQobm9kZSwgY29vcmRzKSB7XG4gICAgbGV0IGxlbiA9IG5vZGUubm9kZVZhbHVlLmxlbmd0aDtcbiAgICBsZXQgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpLCByZXN1bHQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICByYW5nZS5zZXRFbmQobm9kZSwgaSArIDEpO1xuICAgICAgICByYW5nZS5zZXRTdGFydChub2RlLCBpKTtcbiAgICAgICAgbGV0IHJlY3QgPSBzaW5nbGVSZWN0KHJhbmdlLCAxKTtcbiAgICAgICAgaWYgKHJlY3QudG9wID09IHJlY3QuYm90dG9tKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChpblJlY3QoY29vcmRzLCByZWN0KSkge1xuICAgICAgICAgICAgcmVzdWx0ID0geyBub2RlLCBvZmZzZXQ6IGkgKyAoY29vcmRzLmxlZnQgPj0gKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMiA/IDEgOiAwKSB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmFuZ2UuZGV0YWNoKCk7XG4gICAgcmV0dXJuIHJlc3VsdCB8fCB7IG5vZGUsIG9mZnNldDogMCB9O1xufVxuZnVuY3Rpb24gaW5SZWN0KGNvb3JkcywgcmVjdCkge1xuICAgIHJldHVybiBjb29yZHMubGVmdCA+PSByZWN0LmxlZnQgLSAxICYmIGNvb3Jkcy5sZWZ0IDw9IHJlY3QucmlnaHQgKyAxICYmXG4gICAgICAgIGNvb3Jkcy50b3AgPj0gcmVjdC50b3AgLSAxICYmIGNvb3Jkcy50b3AgPD0gcmVjdC5ib3R0b20gKyAxO1xufVxuZnVuY3Rpb24gdGFyZ2V0S2x1ZGdlKGRvbSwgY29vcmRzKSB7XG4gICAgbGV0IHBhcmVudCA9IGRvbS5wYXJlbnROb2RlO1xuICAgIGlmIChwYXJlbnQgJiYgL15saSQvaS50ZXN0KHBhcmVudC5ub2RlTmFtZSkgJiYgY29vcmRzLmxlZnQgPCBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdClcbiAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICByZXR1cm4gZG9tO1xufVxuZnVuY3Rpb24gcG9zRnJvbUVsZW1lbnQodmlldywgZWx0LCBjb29yZHMpIHtcbiAgICBsZXQgeyBub2RlLCBvZmZzZXQgfSA9IGZpbmRPZmZzZXRJbk5vZGUoZWx0LCBjb29yZHMpLCBiaWFzID0gLTE7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiAhbm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgIGxldCByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgYmlhcyA9IHJlY3QubGVmdCAhPSByZWN0LnJpZ2h0ICYmIGNvb3Jkcy5sZWZ0ID4gKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMiA/IDEgOiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKG5vZGUsIG9mZnNldCwgYmlhcyk7XG59XG5mdW5jdGlvbiBwb3NGcm9tQ2FyZXQodmlldywgbm9kZSwgb2Zmc2V0LCBjb29yZHMpIHtcbiAgICAvLyBCcm93c2VyIChpbiBjYXJldFBvc2l0aW9uL1JhbmdlRnJvbVBvaW50KSB3aWxsIGFncmVzc2l2ZWx5XG4gICAgLy8gbm9ybWFsaXplIHRvd2FyZHMgbmVhcmJ5IGlubGluZSBub2Rlcy4gU2luY2Ugd2UgYXJlIGludGVyZXN0ZWQgaW5cbiAgICAvLyBwb3NpdGlvbnMgYmV0d2VlbiBibG9jayBub2RlcyB0b28sIHdlIGZpcnN0IHdhbGsgdXAgdGhlIGhpZXJhcmNoeVxuICAgIC8vIG9mIG5vZGVzIHRvIHNlZSBpZiB0aGVyZSBhcmUgYmxvY2sgbm9kZXMgdGhhdCB0aGUgY29vcmRpbmF0ZXNcbiAgICAvLyBmYWxsIG91dHNpZGUgb2YuIElmIHNvLCB3ZSB0YWtlIHRoZSBwb3NpdGlvbiBiZWZvcmUvYWZ0ZXIgdGhhdFxuICAgIC8vIGJsb2NrLiBJZiBub3QsIHdlIGNhbGwgYHBvc0Zyb21ET01gIG9uIHRoZSByYXcgbm9kZS9vZmZzZXQuXG4gICAgbGV0IG91dHNpZGVCbG9jayA9IC0xO1xuICAgIGZvciAobGV0IGN1ciA9IG5vZGUsIHNhd0Jsb2NrID0gZmFsc2U7Oykge1xuICAgICAgICBpZiAoY3VyID09IHZpZXcuZG9tKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCBkZXNjID0gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGN1ciwgdHJ1ZSksIHJlY3Q7XG4gICAgICAgIGlmICghZGVzYylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoZGVzYy5kb20ubm9kZVR5cGUgPT0gMSAmJiAoZGVzYy5ub2RlLmlzQmxvY2sgJiYgZGVzYy5wYXJlbnQgfHwgIWRlc2MuY29udGVudERPTSkgJiZcbiAgICAgICAgICAgIC8vIElnbm9yZSBlbGVtZW50cyB3aXRoIHplcm8tc2l6ZSBib3VuZGluZyByZWN0YW5nbGVzXG4gICAgICAgICAgICAoKHJlY3QgPSBkZXNjLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkud2lkdGggfHwgcmVjdC5oZWlnaHQpKSB7XG4gICAgICAgICAgICBpZiAoZGVzYy5ub2RlLmlzQmxvY2sgJiYgZGVzYy5wYXJlbnQgJiYgIS9eVChSfEJPRFl8SEVBRHxGT09UKSQvLnRlc3QoZGVzYy5kb20ubm9kZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSBhcHBseSB0aGUgaG9yaXpvbnRhbCB0ZXN0IHRvIHRoZSBpbm5lcm1vc3QgYmxvY2suIFZlcnRpY2FsIGZvciBhbnkgcGFyZW50LlxuICAgICAgICAgICAgICAgIGlmICghc2F3QmxvY2sgJiYgcmVjdC5sZWZ0ID4gY29vcmRzLmxlZnQgfHwgcmVjdC50b3AgPiBjb29yZHMudG9wKVxuICAgICAgICAgICAgICAgICAgICBvdXRzaWRlQmxvY2sgPSBkZXNjLnBvc0JlZm9yZTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghc2F3QmxvY2sgJiYgcmVjdC5yaWdodCA8IGNvb3Jkcy5sZWZ0IHx8IHJlY3QuYm90dG9tIDwgY29vcmRzLnRvcClcbiAgICAgICAgICAgICAgICAgICAgb3V0c2lkZUJsb2NrID0gZGVzYy5wb3NBZnRlcjtcbiAgICAgICAgICAgICAgICBzYXdCbG9jayA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRlc2MuY29udGVudERPTSAmJiBvdXRzaWRlQmxvY2sgPCAwICYmICFkZXNjLm5vZGUuaXNUZXh0KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGluc2lkZSBhIGxlYWYsIHJldHVybiB0aGUgc2lkZSBvZiB0aGUgbGVhZiBjbG9zZXIgdG8gdGhlIGNvb3Jkc1xuICAgICAgICAgICAgICAgIGxldCBiZWZvcmUgPSBkZXNjLm5vZGUuaXNCbG9jayA/IGNvb3Jkcy50b3AgPCAocmVjdC50b3AgKyByZWN0LmJvdHRvbSkgLyAyXG4gICAgICAgICAgICAgICAgICAgIDogY29vcmRzLmxlZnQgPCAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyO1xuICAgICAgICAgICAgICAgIHJldHVybiBiZWZvcmUgPyBkZXNjLnBvc0JlZm9yZSA6IGRlc2MucG9zQWZ0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VyID0gZGVzYy5kb20ucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHNpZGVCbG9jayA+IC0xID8gb3V0c2lkZUJsb2NrIDogdmlldy5kb2NWaWV3LnBvc0Zyb21ET00obm9kZSwgb2Zmc2V0LCAtMSk7XG59XG5mdW5jdGlvbiBlbGVtZW50RnJvbVBvaW50KGVsZW1lbnQsIGNvb3JkcywgYm94KSB7XG4gICAgbGV0IGxlbiA9IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgaWYgKGxlbiAmJiBib3gudG9wIDwgYm94LmJvdHRvbSkge1xuICAgICAgICBmb3IgKGxldCBzdGFydEkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihsZW4gLSAxLCBNYXRoLmZsb29yKGxlbiAqIChjb29yZHMudG9wIC0gYm94LnRvcCkgLyAoYm94LmJvdHRvbSAtIGJveC50b3ApKSAtIDIpKSwgaSA9IHN0YXJ0STs7KSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbaV07XG4gICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgICAgIGxldCByZWN0cyA9IGNoaWxkLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByZWN0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVjdCA9IHJlY3RzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5SZWN0KGNvb3JkcywgcmVjdCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudEZyb21Qb2ludChjaGlsZCwgY29vcmRzLCByZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGkgPSAoaSArIDEpICUgbGVuKSA9PSBzdGFydEkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59XG4vLyBHaXZlbiBhbiB4LHkgcG9zaXRpb24gb24gdGhlIGVkaXRvciwgZ2V0IHRoZSBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnQuXG5mdW5jdGlvbiBwb3NBdENvb3Jkcyh2aWV3LCBjb29yZHMpIHtcbiAgICBsZXQgZG9jID0gdmlldy5kb20ub3duZXJEb2N1bWVudCwgbm9kZSwgb2Zmc2V0ID0gMDtcbiAgICBsZXQgY2FyZXQgPSBjYXJldEZyb21Qb2ludChkb2MsIGNvb3Jkcy5sZWZ0LCBjb29yZHMudG9wKTtcbiAgICBpZiAoY2FyZXQpXG4gICAgICAgICh7IG5vZGUsIG9mZnNldCB9ID0gY2FyZXQpO1xuICAgIGxldCBlbHQgPSAodmlldy5yb290LmVsZW1lbnRGcm9tUG9pbnQgPyB2aWV3LnJvb3QgOiBkb2MpXG4gICAgICAgIC5lbGVtZW50RnJvbVBvaW50KGNvb3Jkcy5sZWZ0LCBjb29yZHMudG9wKTtcbiAgICBsZXQgcG9zO1xuICAgIGlmICghZWx0IHx8ICF2aWV3LmRvbS5jb250YWlucyhlbHQubm9kZVR5cGUgIT0gMSA/IGVsdC5wYXJlbnROb2RlIDogZWx0KSkge1xuICAgICAgICBsZXQgYm94ID0gdmlldy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmICghaW5SZWN0KGNvb3JkcywgYm94KSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBlbHQgPSBlbGVtZW50RnJvbVBvaW50KHZpZXcuZG9tLCBjb29yZHMsIGJveCk7XG4gICAgICAgIGlmICghZWx0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFNhZmFyaSdzIGNhcmV0UmFuZ2VGcm9tUG9pbnQgcmV0dXJucyBub25zZW5zZSB3aGVuIG9uIGEgZHJhZ2dhYmxlIGVsZW1lbnRcbiAgICBpZiAoc2FmYXJpKSB7XG4gICAgICAgIGZvciAobGV0IHAgPSBlbHQ7IG5vZGUgJiYgcDsgcCA9IHBhcmVudE5vZGUocCkpXG4gICAgICAgICAgICBpZiAocC5kcmFnZ2FibGUpXG4gICAgICAgICAgICAgICAgbm9kZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZWx0ID0gdGFyZ2V0S2x1ZGdlKGVsdCwgY29vcmRzKTtcbiAgICBpZiAobm9kZSkge1xuICAgICAgICBpZiAoZ2Vja28gJiYgbm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICAvLyBGaXJlZm94IHdpbGwgc29tZXRpbWVzIHJldHVybiBvZmZzZXRzIGludG8gPGlucHV0PiBub2Rlcywgd2hpY2hcbiAgICAgICAgICAgIC8vIGhhdmUgbm8gYWN0dWFsIGNoaWxkcmVuLCBmcm9tIGNhcmV0UG9zaXRpb25Gcm9tUG9pbnQgKCM5NTMpXG4gICAgICAgICAgICBvZmZzZXQgPSBNYXRoLm1pbihvZmZzZXQsIG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpO1xuICAgICAgICAgICAgLy8gSXQnbGwgYWxzbyBtb3ZlIHRoZSByZXR1cm5lZCBwb3NpdGlvbiBiZWZvcmUgaW1hZ2Ugbm9kZXMsXG4gICAgICAgICAgICAvLyBldmVuIGlmIHRob3NlIGFyZSBiZWhpbmQgaXQuXG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF0sIGJveDtcbiAgICAgICAgICAgICAgICBpZiAobmV4dC5ub2RlTmFtZSA9PSBcIklNR1wiICYmIChib3ggPSBuZXh0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKS5yaWdodCA8PSBjb29yZHMubGVmdCAmJlxuICAgICAgICAgICAgICAgICAgICBib3guYm90dG9tID4gY29vcmRzLnRvcClcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByZXY7XG4gICAgICAgIC8vIFdoZW4gY2xpY2tpbmcgYWJvdmUgdGhlIHJpZ2h0IHNpZGUgb2YgYW4gdW5lZGl0YWJsZSBub2RlLCBDaHJvbWUgd2lsbCByZXBvcnQgYSBjdXJzb3IgcG9zaXRpb24gYWZ0ZXIgdGhhdCBub2RlLlxuICAgICAgICBpZiAod2Via2l0ICYmIG9mZnNldCAmJiBub2RlLm5vZGVUeXBlID09IDEgJiYgKHByZXYgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV0pLm5vZGVUeXBlID09IDEgJiZcbiAgICAgICAgICAgIHByZXYuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIiAmJiBwcmV2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCA+PSBjb29yZHMudG9wKVxuICAgICAgICAgICAgb2Zmc2V0LS07XG4gICAgICAgIC8vIFN1c3BpY2lvdXNseSBzcGVjaWZpYyBrbHVkZ2UgdG8gd29yayBhcm91bmQgY2FyZXQqRnJvbVBvaW50XG4gICAgICAgIC8vIG5ldmVyIHJldHVybmluZyBhIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50XG4gICAgICAgIGlmIChub2RlID09IHZpZXcuZG9tICYmIG9mZnNldCA9PSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoIC0gMSAmJiBub2RlLmxhc3RDaGlsZC5ub2RlVHlwZSA9PSAxICYmXG4gICAgICAgICAgICBjb29yZHMudG9wID4gbm9kZS5sYXN0Q2hpbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tKVxuICAgICAgICAgICAgcG9zID0gdmlldy5zdGF0ZS5kb2MuY29udGVudC5zaXplO1xuICAgICAgICAvLyBJZ25vcmUgcG9zaXRpb25zIGRpcmVjdGx5IGFmdGVyIGEgQlIsIHNpbmNlIGNhcmV0KkZyb21Qb2ludFxuICAgICAgICAvLyAncm91bmQgdXAnIHBvc2l0aW9ucyB0aGF0IHdvdWxkIGJlIG1vcmUgYWNjdXJhdGVseSBwbGFjZWRcbiAgICAgICAgLy8gYmVmb3JlIHRoZSBCUiBub2RlLlxuICAgICAgICBlbHNlIGlmIChvZmZzZXQgPT0gMCB8fCBub2RlLm5vZGVUeXBlICE9IDEgfHwgbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdLm5vZGVOYW1lICE9IFwiQlJcIilcbiAgICAgICAgICAgIHBvcyA9IHBvc0Zyb21DYXJldCh2aWV3LCBub2RlLCBvZmZzZXQsIGNvb3Jkcyk7XG4gICAgfVxuICAgIGlmIChwb3MgPT0gbnVsbClcbiAgICAgICAgcG9zID0gcG9zRnJvbUVsZW1lbnQodmlldywgZWx0LCBjb29yZHMpO1xuICAgIGxldCBkZXNjID0gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGVsdCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHsgcG9zLCBpbnNpZGU6IGRlc2MgPyBkZXNjLnBvc0F0U3RhcnQgLSBkZXNjLmJvcmRlciA6IC0xIH07XG59XG5mdW5jdGlvbiBub25aZXJvKHJlY3QpIHtcbiAgICByZXR1cm4gcmVjdC50b3AgPCByZWN0LmJvdHRvbSB8fCByZWN0LmxlZnQgPCByZWN0LnJpZ2h0O1xufVxuZnVuY3Rpb24gc2luZ2xlUmVjdCh0YXJnZXQsIGJpYXMpIHtcbiAgICBsZXQgcmVjdHMgPSB0YXJnZXQuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICBpZiAocmVjdHMubGVuZ3RoKSB7XG4gICAgICAgIGxldCBmaXJzdCA9IHJlY3RzW2JpYXMgPCAwID8gMCA6IHJlY3RzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobm9uWmVybyhmaXJzdCkpXG4gICAgICAgICAgICByZXR1cm4gZmlyc3Q7XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuZmluZC5jYWxsKHJlY3RzLCBub25aZXJvKSB8fCB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG59XG5jb25zdCBCSURJID0gL1tcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUwNzAwLVxcdTA4YWNdLztcbi8vIEdpdmVuIGEgcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50IG1vZGVsLCBnZXQgYSBib3VuZGluZyBib3ggb2YgdGhlXG4vLyBjaGFyYWN0ZXIgYXQgdGhhdCBwb3NpdGlvbiwgcmVsYXRpdmUgdG8gdGhlIHdpbmRvdy5cbmZ1bmN0aW9uIGNvb3Jkc0F0UG9zKHZpZXcsIHBvcywgc2lkZSkge1xuICAgIGxldCB7IG5vZGUsIG9mZnNldCwgYXRvbSB9ID0gdmlldy5kb2NWaWV3LmRvbUZyb21Qb3MocG9zLCBzaWRlIDwgMCA/IC0xIDogMSk7XG4gICAgbGV0IHN1cHBvcnRFbXB0eVJhbmdlID0gd2Via2l0IHx8IGdlY2tvO1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgLy8gVGhlc2UgYnJvd3NlcnMgc3VwcG9ydCBxdWVyeWluZyBlbXB0eSB0ZXh0IHJhbmdlcy4gUHJlZmVyIHRoYXQgaW5cbiAgICAgICAgLy8gYmlkaSBjb250ZXh0IG9yIHdoZW4gYXQgdGhlIGVuZCBvZiBhIG5vZGUuXG4gICAgICAgIGlmIChzdXBwb3J0RW1wdHlSYW5nZSAmJiAoQklESS50ZXN0KG5vZGUubm9kZVZhbHVlKSB8fCAoc2lkZSA8IDAgPyAhb2Zmc2V0IDogb2Zmc2V0ID09IG5vZGUubm9kZVZhbHVlLmxlbmd0aCkpKSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IHNpbmdsZVJlY3QodGV4dFJhbmdlKG5vZGUsIG9mZnNldCwgb2Zmc2V0KSwgc2lkZSk7XG4gICAgICAgICAgICAvLyBGaXJlZm94IHJldHVybnMgYmFkIHJlc3VsdHMgKHRoZSBwb3NpdGlvbiBiZWZvcmUgdGhlIHNwYWNlKVxuICAgICAgICAgICAgLy8gd2hlbiBxdWVyeWluZyBhIHBvc2l0aW9uIGRpcmVjdGx5IGFmdGVyIGxpbmUtYnJva2VuXG4gICAgICAgICAgICAvLyB3aGl0ZXNwYWNlLiBEZXRlY3QgdGhpcyBzaXR1YXRpb24gYW5kIGFuZCBrbHVkZ2UgYXJvdW5kIGl0XG4gICAgICAgICAgICBpZiAoZ2Vja28gJiYgb2Zmc2V0ICYmIC9cXHMvLnRlc3Qobm9kZS5ub2RlVmFsdWVbb2Zmc2V0IC0gMV0pICYmIG9mZnNldCA8IG5vZGUubm9kZVZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCByZWN0QmVmb3JlID0gc2luZ2xlUmVjdCh0ZXh0UmFuZ2Uobm9kZSwgb2Zmc2V0IC0gMSwgb2Zmc2V0IC0gMSksIC0xKTtcbiAgICAgICAgICAgICAgICBpZiAocmVjdEJlZm9yZS50b3AgPT0gcmVjdC50b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3RBZnRlciA9IHNpbmdsZVJlY3QodGV4dFJhbmdlKG5vZGUsIG9mZnNldCwgb2Zmc2V0ICsgMSksIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY3RBZnRlci50b3AgIT0gcmVjdC50b3ApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmxhdHRlblYocmVjdEFmdGVyLCByZWN0QWZ0ZXIubGVmdCA8IHJlY3RCZWZvcmUubGVmdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IG9mZnNldCwgdG8gPSBvZmZzZXQsIHRha2VTaWRlID0gc2lkZSA8IDAgPyAxIDogLTE7XG4gICAgICAgICAgICBpZiAoc2lkZSA8IDAgJiYgIW9mZnNldCkge1xuICAgICAgICAgICAgICAgIHRvKys7XG4gICAgICAgICAgICAgICAgdGFrZVNpZGUgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNpZGUgPj0gMCAmJiBvZmZzZXQgPT0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZnJvbS0tO1xuICAgICAgICAgICAgICAgIHRha2VTaWRlID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNpZGUgPCAwKSB7XG4gICAgICAgICAgICAgICAgZnJvbS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdG8rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmbGF0dGVuVihzaW5nbGVSZWN0KHRleHRSYW5nZShub2RlLCBmcm9tLCB0byksIHRha2VTaWRlKSwgdGFrZVNpZGUgPCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgJGRvbSA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUocG9zIC0gKGF0b20gfHwgMCkpO1xuICAgIC8vIFJldHVybiBhIGhvcml6b250YWwgbGluZSBpbiBibG9jayBjb250ZXh0XG4gICAgaWYgKCEkZG9tLnBhcmVudC5pbmxpbmVDb250ZW50KSB7XG4gICAgICAgIGlmIChhdG9tID09IG51bGwgJiYgb2Zmc2V0ICYmIChzaWRlIDwgMCB8fCBvZmZzZXQgPT0gbm9kZVNpemUobm9kZSkpKSB7XG4gICAgICAgICAgICBsZXQgYmVmb3JlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgaWYgKGJlZm9yZS5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBmbGF0dGVuSChiZWZvcmUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXRvbSA9PSBudWxsICYmIG9mZnNldCA8IG5vZGVTaXplKG5vZGUpKSB7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgIGlmIChhZnRlci5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBmbGF0dGVuSChhZnRlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZsYXR0ZW5IKG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHNpZGUgPj0gMCk7XG4gICAgfVxuICAgIC8vIElubGluZSwgbm90IGluIHRleHQgbm9kZSAodGhpcyBpcyBub3QgQmlkaS1zYWZlKVxuICAgIGlmIChhdG9tID09IG51bGwgJiYgb2Zmc2V0ICYmIChzaWRlIDwgMCB8fCBvZmZzZXQgPT0gbm9kZVNpemUobm9kZSkpKSB7XG4gICAgICAgIGxldCBiZWZvcmUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgIGxldCB0YXJnZXQgPSBiZWZvcmUubm9kZVR5cGUgPT0gMyA/IHRleHRSYW5nZShiZWZvcmUsIG5vZGVTaXplKGJlZm9yZSkgLSAoc3VwcG9ydEVtcHR5UmFuZ2UgPyAwIDogMSkpXG4gICAgICAgICAgICAvLyBCUiBub2RlcyB0ZW5kIHRvIG9ubHkgcmV0dXJuIHRoZSByZWN0YW5nbGUgYmVmb3JlIHRoZW0uXG4gICAgICAgICAgICAvLyBPbmx5IHVzZSB0aGVtIGlmIHRoZXkgYXJlIHRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlaXIgcGFyZW50XG4gICAgICAgICAgICA6IGJlZm9yZS5ub2RlVHlwZSA9PSAxICYmIChiZWZvcmUubm9kZU5hbWUgIT0gXCJCUlwiIHx8ICFiZWZvcmUubmV4dFNpYmxpbmcpID8gYmVmb3JlIDogbnVsbDtcbiAgICAgICAgaWYgKHRhcmdldClcbiAgICAgICAgICAgIHJldHVybiBmbGF0dGVuVihzaW5nbGVSZWN0KHRhcmdldCwgMSksIGZhbHNlKTtcbiAgICB9XG4gICAgaWYgKGF0b20gPT0gbnVsbCAmJiBvZmZzZXQgPCBub2RlU2l6ZShub2RlKSkge1xuICAgICAgICBsZXQgYWZ0ZXIgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgd2hpbGUgKGFmdGVyLnBtVmlld0Rlc2MgJiYgYWZ0ZXIucG1WaWV3RGVzYy5pZ25vcmVGb3JDb29yZHMpXG4gICAgICAgICAgICBhZnRlciA9IGFmdGVyLm5leHRTaWJsaW5nO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gIWFmdGVyID8gbnVsbCA6IGFmdGVyLm5vZGVUeXBlID09IDMgPyB0ZXh0UmFuZ2UoYWZ0ZXIsIDAsIChzdXBwb3J0RW1wdHlSYW5nZSA/IDAgOiAxKSlcbiAgICAgICAgICAgIDogYWZ0ZXIubm9kZVR5cGUgPT0gMSA/IGFmdGVyIDogbnVsbDtcbiAgICAgICAgaWYgKHRhcmdldClcbiAgICAgICAgICAgIHJldHVybiBmbGF0dGVuVihzaW5nbGVSZWN0KHRhcmdldCwgLTEpLCB0cnVlKTtcbiAgICB9XG4gICAgLy8gQWxsIGVsc2UgZmFpbGVkLCBqdXN0IHRyeSB0byBnZXQgYSByZWN0YW5nbGUgZm9yIHRoZSB0YXJnZXQgbm9kZVxuICAgIHJldHVybiBmbGF0dGVuVihzaW5nbGVSZWN0KG5vZGUubm9kZVR5cGUgPT0gMyA/IHRleHRSYW5nZShub2RlKSA6IG5vZGUsIC1zaWRlKSwgc2lkZSA+PSAwKTtcbn1cbmZ1bmN0aW9uIGZsYXR0ZW5WKHJlY3QsIGxlZnQpIHtcbiAgICBpZiAocmVjdC53aWR0aCA9PSAwKVxuICAgICAgICByZXR1cm4gcmVjdDtcbiAgICBsZXQgeCA9IGxlZnQgPyByZWN0LmxlZnQgOiByZWN0LnJpZ2h0O1xuICAgIHJldHVybiB7IHRvcDogcmVjdC50b3AsIGJvdHRvbTogcmVjdC5ib3R0b20sIGxlZnQ6IHgsIHJpZ2h0OiB4IH07XG59XG5mdW5jdGlvbiBmbGF0dGVuSChyZWN0LCB0b3ApIHtcbiAgICBpZiAocmVjdC5oZWlnaHQgPT0gMClcbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgbGV0IHkgPSB0b3AgPyByZWN0LnRvcCA6IHJlY3QuYm90dG9tO1xuICAgIHJldHVybiB7IHRvcDogeSwgYm90dG9tOiB5LCBsZWZ0OiByZWN0LmxlZnQsIHJpZ2h0OiByZWN0LnJpZ2h0IH07XG59XG5mdW5jdGlvbiB3aXRoRmx1c2hlZFN0YXRlKHZpZXcsIHN0YXRlLCBmKSB7XG4gICAgbGV0IHZpZXdTdGF0ZSA9IHZpZXcuc3RhdGUsIGFjdGl2ZSA9IHZpZXcucm9vdC5hY3RpdmVFbGVtZW50O1xuICAgIGlmICh2aWV3U3RhdGUgIT0gc3RhdGUpXG4gICAgICAgIHZpZXcudXBkYXRlU3RhdGUoc3RhdGUpO1xuICAgIGlmIChhY3RpdmUgIT0gdmlldy5kb20pXG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZigpO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHZpZXdTdGF0ZSAhPSBzdGF0ZSlcbiAgICAgICAgICAgIHZpZXcudXBkYXRlU3RhdGUodmlld1N0YXRlKTtcbiAgICAgICAgaWYgKGFjdGl2ZSAhPSB2aWV3LmRvbSAmJiBhY3RpdmUpXG4gICAgICAgICAgICBhY3RpdmUuZm9jdXMoKTtcbiAgICB9XG59XG4vLyBXaGV0aGVyIHZlcnRpY2FsIHBvc2l0aW9uIG1vdGlvbiBpbiBhIGdpdmVuIGRpcmVjdGlvblxuLy8gZnJvbSBhIHBvc2l0aW9uIHdvdWxkIGxlYXZlIGEgdGV4dCBibG9jay5cbmZ1bmN0aW9uIGVuZE9mVGV4dGJsb2NrVmVydGljYWwodmlldywgc3RhdGUsIGRpcikge1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0ICRwb3MgPSBkaXIgPT0gXCJ1cFwiID8gc2VsLiRmcm9tIDogc2VsLiR0bztcbiAgICByZXR1cm4gd2l0aEZsdXNoZWRTdGF0ZSh2aWV3LCBzdGF0ZSwgKCkgPT4ge1xuICAgICAgICBsZXQgeyBub2RlOiBkb20gfSA9IHZpZXcuZG9jVmlldy5kb21Gcm9tUG9zKCRwb3MucG9zLCBkaXIgPT0gXCJ1cFwiID8gLTEgOiAxKTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IG5lYXJlc3QgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoZG9tLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICghbmVhcmVzdClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChuZWFyZXN0Lm5vZGUuaXNCbG9jaykge1xuICAgICAgICAgICAgICAgIGRvbSA9IG5lYXJlc3QuY29udGVudERPTSB8fCBuZWFyZXN0LmRvbTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbSA9IG5lYXJlc3QuZG9tLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvb3JkcyA9IGNvb3Jkc0F0UG9zKHZpZXcsICRwb3MucG9zLCAxKTtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgPSBkb20uZmlyc3RDaGlsZDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIGxldCBib3hlcztcbiAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgICAgIGJveGVzID0gY2hpbGQuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICAgICAgYm94ZXMgPSB0ZXh0UmFuZ2UoY2hpbGQsIDAsIGNoaWxkLm5vZGVWYWx1ZS5sZW5ndGgpLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJveGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJveCA9IGJveGVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChib3guYm90dG9tID4gYm94LnRvcCArIDEgJiZcbiAgICAgICAgICAgICAgICAgICAgKGRpciA9PSBcInVwXCIgPyBjb29yZHMudG9wIC0gYm94LnRvcCA+IChib3guYm90dG9tIC0gY29vcmRzLnRvcCkgKiAyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGJveC5ib3R0b20gLSBjb29yZHMuYm90dG9tID4gKGNvb3Jkcy5ib3R0b20gLSBib3gudG9wKSAqIDIpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG59XG5jb25zdCBtYXliZVJUTCA9IC9bXFx1MDU5MC1cXHUwOGFjXS87XG5mdW5jdGlvbiBlbmRPZlRleHRibG9ja0hvcml6b250YWwodmlldywgc3RhdGUsIGRpcikge1xuICAgIGxldCB7ICRoZWFkIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkaGVhZC5wYXJlbnQuaXNUZXh0YmxvY2spXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgb2Zmc2V0ID0gJGhlYWQucGFyZW50T2Zmc2V0LCBhdFN0YXJ0ID0gIW9mZnNldCwgYXRFbmQgPSBvZmZzZXQgPT0gJGhlYWQucGFyZW50LmNvbnRlbnQuc2l6ZTtcbiAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb24oKTtcbiAgICBpZiAoIXNlbClcbiAgICAgICAgcmV0dXJuICRoZWFkLnBvcyA9PSAkaGVhZC5zdGFydCgpIHx8ICRoZWFkLnBvcyA9PSAkaGVhZC5lbmQoKTtcbiAgICAvLyBJZiB0aGUgdGV4dGJsb2NrIGlzIGFsbCBMVFIsIG9yIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydFxuICAgIC8vIFNlbGVjdGlvbi5tb2RpZnkgKEVkZ2UpLCBmYWxsIGJhY2sgdG8gYSBwcmltaXRpdmUgYXBwcm9hY2hcbiAgICBpZiAoIW1heWJlUlRMLnRlc3QoJGhlYWQucGFyZW50LnRleHRDb250ZW50KSB8fCAhc2VsLm1vZGlmeSlcbiAgICAgICAgcmV0dXJuIGRpciA9PSBcImxlZnRcIiB8fCBkaXIgPT0gXCJiYWNrd2FyZFwiID8gYXRTdGFydCA6IGF0RW5kO1xuICAgIHJldHVybiB3aXRoRmx1c2hlZFN0YXRlKHZpZXcsIHN0YXRlLCAoKSA9PiB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBodWdlIGhhY2ssIGJ1dCBhcHBlYXJzIHRvIGJlIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBjdXJyZW50bHkgZG86IHVzZSBgU2VsZWN0aW9uLm1vZGlmeWAgdG8gbW92ZSB0aGUgc2VsZWN0aW9uIGJ5XG4gICAgICAgIC8vIG9uZSBjaGFyYWN0ZXIsIGFuZCBzZWUgaWYgdGhhdCBtb3ZlcyB0aGUgY3Vyc29yIG91dCBvZiB0aGVcbiAgICAgICAgLy8gdGV4dGJsb2NrIChvciBkb2Vzbid0IG1vdmUgaXQgYXQgYWxsLCB3aGVuIGF0IHRoZSBzdGFydC9lbmQgb2ZcbiAgICAgICAgLy8gdGhlIGRvY3VtZW50KS5cbiAgICAgICAgbGV0IHsgZm9jdXNOb2RlOiBvbGROb2RlLCBmb2N1c09mZnNldDogb2xkT2ZmLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQgfSA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgbGV0IG9sZEJpZGlMZXZlbCA9IHNlbC5jYXJldEJpZGlMZXZlbCAvLyBPbmx5IGZvciBGaXJlZm94XG4gICAgICAgIDtcbiAgICAgICAgc2VsLm1vZGlmeShcIm1vdmVcIiwgZGlyLCBcImNoYXJhY3RlclwiKTtcbiAgICAgICAgbGV0IHBhcmVudERPTSA9ICRoZWFkLmRlcHRoID8gdmlldy5kb2NWaWV3LmRvbUFmdGVyUG9zKCRoZWFkLmJlZm9yZSgpKSA6IHZpZXcuZG9tO1xuICAgICAgICBsZXQgeyBmb2N1c05vZGU6IG5ld05vZGUsIGZvY3VzT2Zmc2V0OiBuZXdPZmYgfSA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG5ld05vZGUgJiYgIXBhcmVudERPTS5jb250YWlucyhuZXdOb2RlLm5vZGVUeXBlID09IDEgPyBuZXdOb2RlIDogbmV3Tm9kZS5wYXJlbnROb2RlKSB8fFxuICAgICAgICAgICAgKG9sZE5vZGUgPT0gbmV3Tm9kZSAmJiBvbGRPZmYgPT0gbmV3T2ZmKTtcbiAgICAgICAgLy8gUmVzdG9yZSB0aGUgcHJldmlvdXMgc2VsZWN0aW9uXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZWwuY29sbGFwc2UoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChvbGROb2RlICYmIChvbGROb2RlICE9IGFuY2hvck5vZGUgfHwgb2xkT2ZmICE9IGFuY2hvck9mZnNldCkgJiYgc2VsLmV4dGVuZClcbiAgICAgICAgICAgICAgICBzZWwuZXh0ZW5kKG9sZE5vZGUsIG9sZE9mZik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICBpZiAob2xkQmlkaUxldmVsICE9IG51bGwpXG4gICAgICAgICAgICBzZWwuY2FyZXRCaWRpTGV2ZWwgPSBvbGRCaWRpTGV2ZWw7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG59XG5sZXQgY2FjaGVkU3RhdGUgPSBudWxsO1xubGV0IGNhY2hlZERpciA9IG51bGw7XG5sZXQgY2FjaGVkUmVzdWx0ID0gZmFsc2U7XG5mdW5jdGlvbiBlbmRPZlRleHRibG9jayh2aWV3LCBzdGF0ZSwgZGlyKSB7XG4gICAgaWYgKGNhY2hlZFN0YXRlID09IHN0YXRlICYmIGNhY2hlZERpciA9PSBkaXIpXG4gICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQ7XG4gICAgY2FjaGVkU3RhdGUgPSBzdGF0ZTtcbiAgICBjYWNoZWREaXIgPSBkaXI7XG4gICAgcmV0dXJuIGNhY2hlZFJlc3VsdCA9IGRpciA9PSBcInVwXCIgfHwgZGlyID09IFwiZG93blwiXG4gICAgICAgID8gZW5kT2ZUZXh0YmxvY2tWZXJ0aWNhbCh2aWV3LCBzdGF0ZSwgZGlyKVxuICAgICAgICA6IGVuZE9mVGV4dGJsb2NrSG9yaXpvbnRhbCh2aWV3LCBzdGF0ZSwgZGlyKTtcbn1cblxuLy8gVmlldyBkZXNjcmlwdGlvbnMgYXJlIGRhdGEgc3RydWN0dXJlcyB0aGF0IGRlc2NyaWJlIHRoZSBET00gdGhhdCBpc1xuLy8gdXNlZCB0byByZXByZXNlbnQgdGhlIGVkaXRvcidzIGNvbnRlbnQuIFRoZXkgYXJlIHVzZWQgZm9yOlxuLy9cbi8vIC0gSW5jcmVtZW50YWwgcmVkcmF3aW5nIHdoZW4gdGhlIGRvY3VtZW50IGNoYW5nZXNcbi8vXG4vLyAtIEZpZ3VyaW5nIG91dCB3aGF0IHBhcnQgb2YgdGhlIGRvY3VtZW50IGEgZ2l2ZW4gRE9NIHBvc2l0aW9uXG4vLyAgIGNvcnJlc3BvbmRzIHRvXG4vL1xuLy8gLSBXaXJpbmcgaW4gY3VzdG9tIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgZWRpdGluZyBpbnRlcmZhY2UgZm9yIGFcbi8vICAgZ2l2ZW4gbm9kZVxuLy9cbi8vIFRoZXkgZm9ybSBhIGRvdWJseS1saW5rZWQgbXV0YWJsZSB0cmVlLCBzdGFydGluZyBhdCBgdmlldy5kb2NWaWV3YC5cbmNvbnN0IE5PVF9ESVJUWSA9IDAsIENISUxEX0RJUlRZID0gMSwgQ09OVEVOVF9ESVJUWSA9IDIsIE5PREVfRElSVFkgPSAzO1xuLy8gU3VwZXJjbGFzcyBmb3IgdGhlIHZhcmlvdXMga2luZHMgb2YgZGVzY3JpcHRpb25zLiBEZWZpbmVzIHRoZWlyXG4vLyBiYXNpYyBzdHJ1Y3R1cmUgYW5kIHNoYXJlZCBtZXRob2RzLlxuY2xhc3MgVmlld0Rlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgY2hpbGRyZW4sIGRvbSwgXG4gICAgLy8gVGhpcyBpcyB0aGUgbm9kZSB0aGF0IGhvbGRzIHRoZSBjaGlsZCB2aWV3cy4gSXQgbWF5IGJlIG51bGwgZm9yXG4gICAgLy8gZGVzY3MgdGhhdCBkb24ndCBoYXZlIGNoaWxkcmVuLlxuICAgIGNvbnRlbnRET00pIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5kb20gPSBkb207XG4gICAgICAgIHRoaXMuY29udGVudERPTSA9IGNvbnRlbnRET007XG4gICAgICAgIHRoaXMuZGlydHkgPSBOT1RfRElSVFk7XG4gICAgICAgIC8vIEFuIGV4cGFuZG8gcHJvcGVydHkgb24gdGhlIERPTSBub2RlIHByb3ZpZGVzIGEgbGluayBiYWNrIHRvIGl0c1xuICAgICAgICAvLyBkZXNjcmlwdGlvbi5cbiAgICAgICAgZG9tLnBtVmlld0Rlc2MgPSB0aGlzO1xuICAgIH1cbiAgICAvLyBVc2VkIHRvIGNoZWNrIHdoZXRoZXIgYSBnaXZlbiBkZXNjcmlwdGlvbiBjb3JyZXNwb25kcyB0byBhXG4gICAgLy8gd2lkZ2V0L21hcmsvbm9kZS5cbiAgICBtYXRjaGVzV2lkZ2V0KHdpZGdldCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBtYXRjaGVzTWFyayhtYXJrKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIG1hdGNoZXNOb2RlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIG1hdGNoZXNIYWNrKG5vZGVOYW1lKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8vIFdoZW4gcGFyc2luZyBpbi1lZGl0b3IgY29udGVudCAoaW4gZG9tY2hhbmdlLmpzKSwgd2UgYWxsb3dcbiAgICAvLyBkZXNjcmlwdGlvbnMgdG8gZGV0ZXJtaW5lIHRoZSBwYXJzZSBydWxlcyB0aGF0IHNob3VsZCBiZSB1c2VkIHRvXG4gICAgLy8gcGFyc2UgdGhlbS5cbiAgICBwYXJzZVJ1bGUoKSB7IHJldHVybiBudWxsOyB9XG4gICAgLy8gVXNlZCBieSB0aGUgZWRpdG9yJ3MgZXZlbnQgaGFuZGxlciB0byBpZ25vcmUgZXZlbnRzIHRoYXQgY29tZVxuICAgIC8vIGZyb20gY2VydGFpbiBkZXNjcy5cbiAgICBzdG9wRXZlbnQoZXZlbnQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLy8gVGhlIHNpemUgb2YgdGhlIGNvbnRlbnQgcmVwcmVzZW50ZWQgYnkgdGhpcyBkZXNjLlxuICAgIGdldCBzaXplKCkge1xuICAgICAgICBsZXQgc2l6ZSA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHNpemUgKz0gdGhpcy5jaGlsZHJlbltpXS5zaXplO1xuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG4gICAgLy8gRm9yIGJsb2NrIG5vZGVzLCB0aGlzIHJlcHJlc2VudHMgdGhlIHNwYWNlIHRha2VuIHVwIGJ5IHRoZWlyXG4gICAgLy8gc3RhcnQvZW5kIHRva2Vucy5cbiAgICBnZXQgYm9yZGVyKCkgeyByZXR1cm4gMDsgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodGhpcy5kb20ucG1WaWV3RGVzYyA9PSB0aGlzKVxuICAgICAgICAgICAgdGhpcy5kb20ucG1WaWV3RGVzYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHBvc0JlZm9yZUNoaWxkKGNoaWxkKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSB0aGlzLnBvc0F0U3RhcnQ7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXIgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGN1ciA9PSBjaGlsZClcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgICAgcG9zICs9IGN1ci5zaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBwb3NCZWZvcmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5wb3NCZWZvcmVDaGlsZCh0aGlzKTtcbiAgICB9XG4gICAgZ2V0IHBvc0F0U3RhcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LnBvc0JlZm9yZUNoaWxkKHRoaXMpICsgdGhpcy5ib3JkZXIgOiAwO1xuICAgIH1cbiAgICBnZXQgcG9zQWZ0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc0JlZm9yZSArIHRoaXMuc2l6ZTtcbiAgICB9XG4gICAgZ2V0IHBvc0F0RW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NBdFN0YXJ0ICsgdGhpcy5zaXplIC0gMiAqIHRoaXMuYm9yZGVyO1xuICAgIH1cbiAgICBsb2NhbFBvc0Zyb21ET00oZG9tLCBvZmZzZXQsIGJpYXMpIHtcbiAgICAgICAgLy8gSWYgdGhlIERPTSBwb3NpdGlvbiBpcyBpbiB0aGUgY29udGVudCwgdXNlIHRoZSBjaGlsZCBkZXNjIGFmdGVyXG4gICAgICAgIC8vIGl0IHRvIGZpZ3VyZSBvdXQgYSBwb3NpdGlvbi5cbiAgICAgICAgaWYgKHRoaXMuY29udGVudERPTSAmJiB0aGlzLmNvbnRlbnRET00uY29udGFpbnMoZG9tLm5vZGVUeXBlID09IDEgPyBkb20gOiBkb20ucGFyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgIGlmIChiaWFzIDwgMCkge1xuICAgICAgICAgICAgICAgIGxldCBkb21CZWZvcmUsIGRlc2M7XG4gICAgICAgICAgICAgICAgaWYgKGRvbSA9PSB0aGlzLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tQmVmb3JlID0gZG9tLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZG9tLnBhcmVudE5vZGUgIT0gdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tID0gZG9tLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGRvbUJlZm9yZSA9IGRvbS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChkb21CZWZvcmUgJiYgISgoZGVzYyA9IGRvbUJlZm9yZS5wbVZpZXdEZXNjKSAmJiBkZXNjLnBhcmVudCA9PSB0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgZG9tQmVmb3JlID0gZG9tQmVmb3JlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tQmVmb3JlID8gdGhpcy5wb3NCZWZvcmVDaGlsZChkZXNjKSArIGRlc2Muc2l6ZSA6IHRoaXMucG9zQXRTdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBkb21BZnRlciwgZGVzYztcbiAgICAgICAgICAgICAgICBpZiAoZG9tID09IHRoaXMuY29udGVudERPTSkge1xuICAgICAgICAgICAgICAgICAgICBkb21BZnRlciA9IGRvbS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZG9tLnBhcmVudE5vZGUgIT0gdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tID0gZG9tLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGRvbUFmdGVyID0gZG9tLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoZG9tQWZ0ZXIgJiYgISgoZGVzYyA9IGRvbUFmdGVyLnBtVmlld0Rlc2MpICYmIGRlc2MucGFyZW50ID09IHRoaXMpKVxuICAgICAgICAgICAgICAgICAgICBkb21BZnRlciA9IGRvbUFmdGVyLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIHJldHVybiBkb21BZnRlciA/IHRoaXMucG9zQmVmb3JlQ2hpbGQoZGVzYykgOiB0aGlzLnBvc0F0RW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgdXNlIHZhcmlvdXMgaGV1cmlzdGljcywgZmFsbGluZyBiYWNrIG9uIHRoZSBiaWFzXG4gICAgICAgIC8vIHBhcmFtZXRlciwgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcmV0dXJuIHRoZSBwb3NpdGlvbiBhdCB0aGVcbiAgICAgICAgLy8gc3RhcnQgb3IgYXQgdGhlIGVuZCBvZiB0aGlzIHZpZXcgZGVzYy5cbiAgICAgICAgbGV0IGF0RW5kO1xuICAgICAgICBpZiAoZG9tID09IHRoaXMuZG9tICYmIHRoaXMuY29udGVudERPTSkge1xuICAgICAgICAgICAgYXRFbmQgPSBvZmZzZXQgPiBkb21JbmRleCh0aGlzLmNvbnRlbnRET00pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY29udGVudERPTSAmJiB0aGlzLmNvbnRlbnRET00gIT0gdGhpcy5kb20gJiYgdGhpcy5kb20uY29udGFpbnModGhpcy5jb250ZW50RE9NKSkge1xuICAgICAgICAgICAgYXRFbmQgPSBkb20uY29tcGFyZURvY3VtZW50UG9zaXRpb24odGhpcy5jb250ZW50RE9NKSAmIDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kb20uZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgaWYgKG9mZnNldCA9PSAwKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHNlYXJjaCA9IGRvbTs7IHNlYXJjaCA9IHNlYXJjaC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2ggPT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0RW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VhcmNoLnByZXZpb3VzU2libGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdEVuZCA9PSBudWxsICYmIG9mZnNldCA9PSBkb20uY2hpbGROb2Rlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc2VhcmNoID0gZG9tOzsgc2VhcmNoID0gc2VhcmNoLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlYXJjaCA9PSB0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXRFbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlYXJjaC5uZXh0U2libGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGF0RW5kID09IG51bGwgPyBiaWFzID4gMCA6IGF0RW5kKSA/IHRoaXMucG9zQXRFbmQgOiB0aGlzLnBvc0F0U3RhcnQ7XG4gICAgfVxuICAgIG5lYXJlc3REZXNjKGRvbSwgb25seU5vZGVzID0gZmFsc2UpIHtcbiAgICAgICAgZm9yIChsZXQgZmlyc3QgPSB0cnVlLCBjdXIgPSBkb207IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGxldCBkZXNjID0gdGhpcy5nZXREZXNjKGN1ciksIG5vZGVET007XG4gICAgICAgICAgICBpZiAoZGVzYyAmJiAoIW9ubHlOb2RlcyB8fCBkZXNjLm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgZG9tIGlzIG91dHNpZGUgb2YgdGhpcyBkZXNjJ3Mgbm9kZURPTSwgZG9uJ3QgY291bnQgaXQuXG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0ICYmIChub2RlRE9NID0gZGVzYy5ub2RlRE9NKSAmJlxuICAgICAgICAgICAgICAgICAgICAhKG5vZGVET00ubm9kZVR5cGUgPT0gMSA/IG5vZGVET00uY29udGFpbnMoZG9tLm5vZGVUeXBlID09IDEgPyBkb20gOiBkb20ucGFyZW50Tm9kZSkgOiBub2RlRE9NID09IGRvbSkpXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVzYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXREZXNjKGRvbSkge1xuICAgICAgICBsZXQgZGVzYyA9IGRvbS5wbVZpZXdEZXNjO1xuICAgICAgICBmb3IgKGxldCBjdXIgPSBkZXNjOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnQpXG4gICAgICAgICAgICBpZiAoY3VyID09IHRoaXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgfVxuICAgIHBvc0Zyb21ET00oZG9tLCBvZmZzZXQsIGJpYXMpIHtcbiAgICAgICAgZm9yIChsZXQgc2NhbiA9IGRvbTsgc2Nhbjsgc2NhbiA9IHNjYW4ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgbGV0IGRlc2MgPSB0aGlzLmdldERlc2Moc2Nhbik7XG4gICAgICAgICAgICBpZiAoZGVzYylcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzYy5sb2NhbFBvc0Zyb21ET00oZG9tLCBvZmZzZXQsIGJpYXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgLy8gRmluZCB0aGUgZGVzYyBmb3IgdGhlIG5vZGUgYWZ0ZXIgdGhlIGdpdmVuIHBvcywgaWYgYW55LiAoV2hlbiBhXG4gICAgLy8gcGFyZW50IG5vZGUgb3ZlcnJvZGUgcmVuZGVyaW5nLCB0aGVyZSBtaWdodCBub3QgYmUgb25lLilcbiAgICBkZXNjQXQocG9zKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBvZmZzZXQgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gb2Zmc2V0ICsgY2hpbGQuc2l6ZTtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gcG9zICYmIGVuZCAhPSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoIWNoaWxkLmJvcmRlciAmJiBjaGlsZC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlubmVyID0gY2hpbGQuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkID0gaW5uZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvcyA8IGVuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuZGVzY0F0KHBvcyAtIG9mZnNldCAtIGNoaWxkLmJvcmRlcik7XG4gICAgICAgICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZG9tRnJvbVBvcyhwb3MsIHNpZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRlbnRET00pXG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmRvbSwgb2Zmc2V0OiAwLCBhdG9tOiBwb3MgKyAxIH07XG4gICAgICAgIC8vIEZpcnN0IGZpbmQgdGhlIHBvc2l0aW9uIGluIHRoZSBjaGlsZCBhcnJheVxuICAgICAgICBsZXQgaSA9IDAsIG9mZnNldCA9IDA7XG4gICAgICAgIGZvciAobGV0IGN1clBvcyA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBjdXJQb3MgKyBjaGlsZC5zaXplO1xuICAgICAgICAgICAgaWYgKGVuZCA+IHBvcyB8fCBjaGlsZCBpbnN0YW5jZW9mIFRyYWlsaW5nSGFja1ZpZXdEZXNjKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gcG9zIC0gY3VyUG9zO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyUG9zID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoaXMgcG9pbnRzIGludG8gdGhlIG1pZGRsZSBvZiBhIGNoaWxkLCBjYWxsIHRocm91Z2hcbiAgICAgICAgaWYgKG9mZnNldClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2ldLmRvbUZyb21Qb3Mob2Zmc2V0IC0gdGhpcy5jaGlsZHJlbltpXS5ib3JkZXIsIHNpZGUpO1xuICAgICAgICAvLyBHbyBiYWNrIGlmIHRoZXJlIHdlcmUgYW55IHplcm8tbGVuZ3RoIHdpZGdldHMgd2l0aCBzaWRlID49IDAgYmVmb3JlIHRoaXMgcG9pbnRcbiAgICAgICAgZm9yIChsZXQgcHJldjsgaSAmJiAhKHByZXYgPSB0aGlzLmNoaWxkcmVuW2kgLSAxXSkuc2l6ZSAmJiBwcmV2IGluc3RhbmNlb2YgV2lkZ2V0Vmlld0Rlc2MgJiYgcHJldi5zaWRlID49IDA7IGktLSkgeyB9XG4gICAgICAgIC8vIFNjYW4gdG93YXJkcyB0aGUgZmlyc3QgdXNlYWJsZSBub2RlXG4gICAgICAgIGlmIChzaWRlIDw9IDApIHtcbiAgICAgICAgICAgIGxldCBwcmV2LCBlbnRlciA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKDs7IGktLSwgZW50ZXIgPSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHByZXYgPSBpID8gdGhpcy5jaGlsZHJlbltpIC0gMV0gOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghcHJldiB8fCBwcmV2LmRvbS5wYXJlbnROb2RlID09IHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldiAmJiBzaWRlICYmIGVudGVyICYmICFwcmV2LmJvcmRlciAmJiAhcHJldi5kb21BdG9tKVxuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2LmRvbUZyb21Qb3MocHJldi5zaXplLCBzaWRlKTtcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMuY29udGVudERPTSwgb2Zmc2V0OiBwcmV2ID8gZG9tSW5kZXgocHJldi5kb20pICsgMSA6IDAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBuZXh0LCBlbnRlciA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKDs7IGkrKywgZW50ZXIgPSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG5leHQgPSBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGggPyB0aGlzLmNoaWxkcmVuW2ldIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIW5leHQgfHwgbmV4dC5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgJiYgZW50ZXIgJiYgIW5leHQuYm9yZGVyICYmICFuZXh0LmRvbUF0b20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQuZG9tRnJvbVBvcygwLCBzaWRlKTtcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMuY29udGVudERPTSwgb2Zmc2V0OiBuZXh0ID8gZG9tSW5kZXgobmV4dC5kb20pIDogdGhpcy5jb250ZW50RE9NLmNoaWxkTm9kZXMubGVuZ3RoIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVXNlZCB0byBmaW5kIGEgRE9NIHJhbmdlIGluIGEgc2luZ2xlIHBhcmVudCBmb3IgYSBnaXZlbiBjaGFuZ2VkXG4gICAgLy8gcmFuZ2UuXG4gICAgcGFyc2VSYW5nZShmcm9tLCB0bywgYmFzZSA9IDApIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmNvbnRlbnRET00sIGZyb20sIHRvLCBmcm9tT2Zmc2V0OiAwLCB0b09mZnNldDogdGhpcy5jb250ZW50RE9NLmNoaWxkTm9kZXMubGVuZ3RoIH07XG4gICAgICAgIGxldCBmcm9tT2Zmc2V0ID0gLTEsIHRvT2Zmc2V0ID0gLTE7XG4gICAgICAgIGZvciAobGV0IG9mZnNldCA9IGJhc2UsIGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBvZmZzZXQgKyBjaGlsZC5zaXplO1xuICAgICAgICAgICAgaWYgKGZyb21PZmZzZXQgPT0gLTEgJiYgZnJvbSA8PSBlbmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRCYXNlID0gb2Zmc2V0ICsgY2hpbGQuYm9yZGVyO1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FIG1heWJlIGRlc2NlbmQgbWFyayB2aWV3cyB0byBwYXJzZSBhIG5hcnJvd2VyIHJhbmdlP1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID49IGNoaWxkQmFzZSAmJiB0byA8PSBlbmQgLSBjaGlsZC5ib3JkZXIgJiYgY2hpbGQubm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5jb250ZW50RE9NICYmIHRoaXMuY29udGVudERPTS5jb250YWlucyhjaGlsZC5jb250ZW50RE9NKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLnBhcnNlUmFuZ2UoZnJvbSwgdG8sIGNoaWxkQmFzZSk7XG4gICAgICAgICAgICAgICAgZnJvbSA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA+IDA7IGotLSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHJldiA9IHRoaXMuY2hpbGRyZW5baiAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldi5zaXplICYmIHByZXYuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NICYmICFwcmV2LmVtcHR5Q2hpbGRBdCgxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbU9mZnNldCA9IGRvbUluZGV4KHByZXYuZG9tKSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmcm9tIC09IHByZXYuc2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZyb21PZmZzZXQgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGZyb21PZmZzZXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZyb21PZmZzZXQgPiAtMSAmJiAoZW5kID4gdG8gfHwgaSA9PSB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgdG8gPSBlbmQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMuY2hpbGRyZW5bal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LnNpemUgJiYgbmV4dC5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00gJiYgIW5leHQuZW1wdHlDaGlsZEF0KC0xKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9PZmZzZXQgPSBkb21JbmRleChuZXh0LmRvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0byArPSBuZXh0LnNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0b09mZnNldCA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgdG9PZmZzZXQgPSB0aGlzLmNvbnRlbnRET00uY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5jb250ZW50RE9NLCBmcm9tLCB0bywgZnJvbU9mZnNldCwgdG9PZmZzZXQgfTtcbiAgICB9XG4gICAgZW1wdHlDaGlsZEF0KHNpZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuYm9yZGVyIHx8ICF0aGlzLmNvbnRlbnRET00gfHwgIXRoaXMuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW3NpZGUgPCAwID8gMCA6IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiBjaGlsZC5zaXplID09IDAgfHwgY2hpbGQuZW1wdHlDaGlsZEF0KHNpZGUpO1xuICAgIH1cbiAgICBkb21BZnRlclBvcyhwb3MpIHtcbiAgICAgICAgbGV0IHsgbm9kZSwgb2Zmc2V0IH0gPSB0aGlzLmRvbUZyb21Qb3MocG9zLCAwKTtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMSB8fCBvZmZzZXQgPT0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm8gbm9kZSBhZnRlciBwb3MgXCIgKyBwb3MpO1xuICAgICAgICByZXR1cm4gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgfVxuICAgIC8vIFZpZXcgZGVzY3MgYXJlIHJlc3BvbnNpYmxlIGZvciBzZXR0aW5nIGFueSBzZWxlY3Rpb24gdGhhdCBmYWxsc1xuICAgIC8vIGVudGlyZWx5IGluc2lkZSBvZiB0aGVtLCBzbyB0aGF0IGN1c3RvbSBpbXBsZW1lbnRhdGlvbnMgY2FuIGRvXG4gICAgLy8gY3VzdG9tIHRoaW5ncyB3aXRoIHRoZSBzZWxlY3Rpb24uIE5vdGUgdGhhdCB0aGlzIGZhbGxzIGFwYXJ0IHdoZW5cbiAgICAvLyBhIHNlbGVjdGlvbiBzdGFydHMgaW4gc3VjaCBhIG5vZGUgYW5kIGVuZHMgaW4gYW5vdGhlciwgaW4gd2hpY2hcbiAgICAvLyBjYXNlIHdlIGp1c3QgdXNlIHdoYXRldmVyIGRvbUZyb21Qb3MgcHJvZHVjZXMgYXMgYSBiZXN0IGVmZm9ydC5cbiAgICBzZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkLCB2aWV3LCBmb3JjZSA9IGZhbHNlKSB7XG4gICAgICAgIC8vIElmIHRoZSBzZWxlY3Rpb24gZmFsbHMgZW50aXJlbHkgaW4gYSBjaGlsZCwgZ2l2ZSBpdCB0byB0aGF0IGNoaWxkXG4gICAgICAgIGxldCBmcm9tID0gTWF0aC5taW4oYW5jaG9yLCBoZWFkKSwgdG8gPSBNYXRoLm1heChhbmNob3IsIGhlYWQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgb2Zmc2V0ID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLnNpemU7XG4gICAgICAgICAgICBpZiAoZnJvbSA+IG9mZnNldCAmJiB0byA8IGVuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuc2V0U2VsZWN0aW9uKGFuY2hvciAtIG9mZnNldCAtIGNoaWxkLmJvcmRlciwgaGVhZCAtIG9mZnNldCAtIGNoaWxkLmJvcmRlciwgdmlldywgZm9yY2UpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhbmNob3JET00gPSB0aGlzLmRvbUZyb21Qb3MoYW5jaG9yLCBhbmNob3IgPyAtMSA6IDEpO1xuICAgICAgICBsZXQgaGVhZERPTSA9IGhlYWQgPT0gYW5jaG9yID8gYW5jaG9yRE9NIDogdGhpcy5kb21Gcm9tUG9zKGhlYWQsIGhlYWQgPyAtMSA6IDEpO1xuICAgICAgICBsZXQgZG9tU2VsID0gdmlldy5yb290LmdldFNlbGVjdGlvbigpO1xuICAgICAgICBsZXQgc2VsUmFuZ2UgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCBicktsdWRnZSA9IGZhbHNlO1xuICAgICAgICAvLyBPbiBGaXJlZm94LCB1c2luZyBTZWxlY3Rpb24uY29sbGFwc2UgdG8gcHV0IHRoZSBjdXJzb3IgYWZ0ZXIgYVxuICAgICAgICAvLyBCUiBub2RlIGZvciBzb21lIHJlYXNvbiBkb2Vzbid0IGFsd2F5cyB3b3JrICgjMTA3MykuIE9uIFNhZmFyaSxcbiAgICAgICAgLy8gdGhlIGN1cnNvciBzb21ldGltZXMgaW5leHBsaWNhYmxlIHZpc3VhbGx5IGxhZ3MgYmVoaW5kIGl0c1xuICAgICAgICAvLyByZXBvcnRlZCBwb3NpdGlvbiBpbiBzdWNoIHNpdHVhdGlvbnMgKCMxMDkyKS5cbiAgICAgICAgaWYgKChnZWNrbyB8fCBzYWZhcmkpICYmIGFuY2hvciA9PSBoZWFkKSB7XG4gICAgICAgICAgICBsZXQgeyBub2RlLCBvZmZzZXQgfSA9IGFuY2hvckRPTTtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgICAgICAgICBicktsdWRnZSA9ICEhKG9mZnNldCAmJiBub2RlLm5vZGVWYWx1ZVtvZmZzZXQgLSAxXSA9PSBcIlxcblwiKTtcbiAgICAgICAgICAgICAgICAvLyBJc3N1ZSAjMTEyOFxuICAgICAgICAgICAgICAgIGlmIChicktsdWRnZSAmJiBvZmZzZXQgPT0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHNjYW4gPSBub2RlLCBhZnRlcjsgc2Nhbjsgc2NhbiA9IHNjYW4ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFmdGVyID0gc2Nhbi5uZXh0U2libGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZnRlci5ub2RlTmFtZSA9PSBcIkJSXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvckRPTSA9IGhlYWRET00gPSB7IG5vZGU6IGFmdGVyLnBhcmVudE5vZGUsIG9mZnNldDogZG9tSW5kZXgoYWZ0ZXIpICsgMSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRlc2MgPSBzY2FuLnBtVmlld0Rlc2M7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVzYyAmJiBkZXNjLm5vZGUgJiYgZGVzYy5ub2RlLmlzQmxvY2spXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJldiA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgICAgICBicktsdWRnZSA9IHByZXYgJiYgKHByZXYubm9kZU5hbWUgPT0gXCJCUlwiIHx8IHByZXYuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlyZWZveCBjYW4gYWN0IHN0cmFuZ2VseSB3aGVuIHRoZSBzZWxlY3Rpb24gaXMgaW4gZnJvbnQgb2YgYW5cbiAgICAgICAgLy8gdW5lZGl0YWJsZSBub2RlLiBTZWUgIzExNjMgYW5kIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE3MDk1MzZcbiAgICAgICAgaWYgKGdlY2tvICYmIHNlbFJhbmdlLmZvY3VzTm9kZSAmJiBzZWxSYW5nZS5mb2N1c05vZGUgIT0gaGVhZERPTS5ub2RlICYmIHNlbFJhbmdlLmZvY3VzTm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSBzZWxSYW5nZS5mb2N1c05vZGUuY2hpbGROb2Rlc1tzZWxSYW5nZS5mb2N1c09mZnNldF07XG4gICAgICAgICAgICBpZiAoYWZ0ZXIgJiYgYWZ0ZXIuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICBmb3JjZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoZm9yY2UgfHwgYnJLbHVkZ2UgJiYgc2FmYXJpKSAmJlxuICAgICAgICAgICAgaXNFcXVpdmFsZW50UG9zaXRpb24oYW5jaG9yRE9NLm5vZGUsIGFuY2hvckRPTS5vZmZzZXQsIHNlbFJhbmdlLmFuY2hvck5vZGUsIHNlbFJhbmdlLmFuY2hvck9mZnNldCkgJiZcbiAgICAgICAgICAgIGlzRXF1aXZhbGVudFBvc2l0aW9uKGhlYWRET00ubm9kZSwgaGVhZERPTS5vZmZzZXQsIHNlbFJhbmdlLmZvY3VzTm9kZSwgc2VsUmFuZ2UuZm9jdXNPZmZzZXQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBTZWxlY3Rpb24uZXh0ZW5kIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhbiAnaW52ZXJ0ZWQnIHNlbGVjdGlvblxuICAgICAgICAvLyAob25lIHdoZXJlIHRoZSBmb2N1cyBpcyBiZWZvcmUgdGhlIGFuY2hvciksIGJ1dCBub3QgYWxsXG4gICAgICAgIC8vIGJyb3dzZXJzIHN1cHBvcnQgaXQgeWV0LlxuICAgICAgICBsZXQgZG9tU2VsRXh0ZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKChkb21TZWwuZXh0ZW5kIHx8IGFuY2hvciA9PSBoZWFkKSAmJiAhKGJyS2x1ZGdlICYmIGdlY2tvKSkge1xuICAgICAgICAgICAgZG9tU2VsLmNvbGxhcHNlKGFuY2hvckRPTS5ub2RlLCBhbmNob3JET00ub2Zmc2V0KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGFuY2hvciAhPSBoZWFkKVxuICAgICAgICAgICAgICAgICAgICBkb21TZWwuZXh0ZW5kKGhlYWRET00ubm9kZSwgaGVhZERPTS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGRvbVNlbEV4dGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gc29tZSBjYXNlcyB3aXRoIENocm9tZSB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFmdGVyIGNhbGxpbmdcbiAgICAgICAgICAgICAgICAvLyBjb2xsYXBzZSwgZXZlbiB3aGVuIGl0IHNob3VsZCBiZSB2YWxpZC4gVGhpcyBhcHBlYXJzIHRvIGJlIGEgYnVnLCBidXRcbiAgICAgICAgICAgICAgICAvLyBpdCBpcyBkaWZmaWN1bHQgdG8gaXNvbGF0ZS4gSWYgdGhpcyBoYXBwZW5zIGZhbGxiYWNrIHRvIHRoZSBvbGQgcGF0aFxuICAgICAgICAgICAgICAgIC8vIHdpdGhvdXQgdXNpbmcgZXh0ZW5kLlxuICAgICAgICAgICAgICAgIC8vIFNpbWlsYXJseSwgdGhpcyBjb3VsZCBjcmFzaCBvbiBTYWZhcmkgaWYgdGhlIGVkaXRvciBpcyBoaWRkZW4sIGFuZFxuICAgICAgICAgICAgICAgIC8vIHRoZXJlIHdhcyBubyBzZWxlY3Rpb24uXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkb21TZWxFeHRlbmRlZCkge1xuICAgICAgICAgICAgaWYgKGFuY2hvciA+IGhlYWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgdG1wID0gYW5jaG9yRE9NO1xuICAgICAgICAgICAgICAgIGFuY2hvckRPTSA9IGhlYWRET007XG4gICAgICAgICAgICAgICAgaGVhZERPTSA9IHRtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICByYW5nZS5zZXRFbmQoaGVhZERPTS5ub2RlLCBoZWFkRE9NLm9mZnNldCk7XG4gICAgICAgICAgICByYW5nZS5zZXRTdGFydChhbmNob3JET00ubm9kZSwgYW5jaG9yRE9NLm9mZnNldCk7XG4gICAgICAgICAgICBkb21TZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgICBkb21TZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jb250ZW50RE9NICYmIG11dGF0aW9uLnR5cGUgIT0gXCJzZWxlY3Rpb25cIjtcbiAgICB9XG4gICAgZ2V0IGNvbnRlbnRMb3N0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50RE9NICYmIHRoaXMuY29udGVudERPTSAhPSB0aGlzLmRvbSAmJiAhdGhpcy5kb20uY29udGFpbnModGhpcy5jb250ZW50RE9NKTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGEgc3VidHJlZSBvZiB0aGUgZWxlbWVudCB0cmVlIHRoYXQgaGFzIGJlZW4gdG91Y2hlZFxuICAgIC8vIGJ5IGEgRE9NIGNoYW5nZSwgc28gdGhhdCB0aGUgbmV4dCB1cGRhdGUgd2lsbCByZWRyYXcgaXQuXG4gICAgbWFya0RpcnR5KGZyb20sIHRvKSB7XG4gICAgICAgIGZvciAobGV0IG9mZnNldCA9IDAsIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gb2Zmc2V0ICsgY2hpbGQuc2l6ZTtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gZW5kID8gZnJvbSA8PSBlbmQgJiYgdG8gPj0gb2Zmc2V0IDogZnJvbSA8IGVuZCAmJiB0byA+IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydEluc2lkZSA9IG9mZnNldCArIGNoaWxkLmJvcmRlciwgZW5kSW5zaWRlID0gZW5kIC0gY2hpbGQuYm9yZGVyO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID49IHN0YXJ0SW5zaWRlICYmIHRvIDw9IGVuZEluc2lkZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcnR5ID0gZnJvbSA9PSBvZmZzZXQgfHwgdG8gPT0gZW5kID8gQ09OVEVOVF9ESVJUWSA6IENISUxEX0RJUlRZO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSA9PSBzdGFydEluc2lkZSAmJiB0byA9PSBlbmRJbnNpZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChjaGlsZC5jb250ZW50TG9zdCB8fCBjaGlsZC5kb20ucGFyZW50Tm9kZSAhPSB0aGlzLmNvbnRlbnRET00pKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuZGlydHkgPSBOT0RFX0RJUlRZO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5tYXJrRGlydHkoZnJvbSAtIHN0YXJ0SW5zaWRlLCB0byAtIHN0YXJ0SW5zaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuZGlydHkgPSBjaGlsZC5kb20gPT0gY2hpbGQuY29udGVudERPTSAmJiBjaGlsZC5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00gJiYgIWNoaWxkLmNoaWxkcmVuLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBDT05URU5UX0RJUlRZIDogTk9ERV9ESVJUWTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXJ0eSA9IENPTlRFTlRfRElSVFk7XG4gICAgfVxuICAgIG1hcmtQYXJlbnRzRGlydHkoKSB7XG4gICAgICAgIGxldCBsZXZlbCA9IDE7XG4gICAgICAgIGZvciAobGV0IG5vZGUgPSB0aGlzLnBhcmVudDsgbm9kZTsgbm9kZSA9IG5vZGUucGFyZW50LCBsZXZlbCsrKSB7XG4gICAgICAgICAgICBsZXQgZGlydHkgPSBsZXZlbCA9PSAxID8gQ09OVEVOVF9ESVJUWSA6IENISUxEX0RJUlRZO1xuICAgICAgICAgICAgaWYgKG5vZGUuZGlydHkgPCBkaXJ0eSlcbiAgICAgICAgICAgICAgICBub2RlLmRpcnR5ID0gZGlydHk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBpZ25vcmVGb3JDb29yZHMoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBpZ25vcmVGb3JTZWxlY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlzVGV4dCh0ZXh0KSB7IHJldHVybiBmYWxzZTsgfVxufVxuLy8gQSB3aWRnZXQgZGVzYyByZXByZXNlbnRzIGEgd2lkZ2V0IGRlY29yYXRpb24sIHdoaWNoIGlzIGEgRE9NIG5vZGVcbi8vIGRyYXduIGJldHdlZW4gdGhlIGRvY3VtZW50IG5vZGVzLlxuY2xhc3MgV2lkZ2V0Vmlld0Rlc2MgZXh0ZW5kcyBWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCB3aWRnZXQsIHZpZXcsIHBvcykge1xuICAgICAgICBsZXQgc2VsZiwgZG9tID0gd2lkZ2V0LnR5cGUudG9ET007XG4gICAgICAgIGlmICh0eXBlb2YgZG9tID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIGRvbSA9IGRvbSh2aWV3LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxmKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLnBhcmVudClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucGFyZW50LnBvc0JlZm9yZUNoaWxkKHNlbGYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmICghd2lkZ2V0LnR5cGUuc3BlYy5yYXcpIHtcbiAgICAgICAgICAgIGlmIChkb20ubm9kZVR5cGUgIT0gMSkge1xuICAgICAgICAgICAgICAgIGxldCB3cmFwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICAgICAgd3JhcC5hcHBlbmRDaGlsZChkb20pO1xuICAgICAgICAgICAgICAgIGRvbSA9IHdyYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb20uY29udGVudEVkaXRhYmxlID0gXCJmYWxzZVwiO1xuICAgICAgICAgICAgZG9tLmNsYXNzTGlzdC5hZGQoXCJQcm9zZU1pcnJvci13aWRnZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIocGFyZW50LCBbXSwgZG9tLCBudWxsKTtcbiAgICAgICAgdGhpcy53aWRnZXQgPSB3aWRnZXQ7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xuICAgICAgICBzZWxmID0gdGhpcztcbiAgICB9XG4gICAgbWF0Y2hlc1dpZGdldCh3aWRnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlydHkgPT0gTk9UX0RJUlRZICYmIHdpZGdldC50eXBlLmVxKHRoaXMud2lkZ2V0LnR5cGUpO1xuICAgIH1cbiAgICBwYXJzZVJ1bGUoKSB7IHJldHVybiB7IGlnbm9yZTogdHJ1ZSB9OyB9XG4gICAgc3RvcEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGxldCBzdG9wID0gdGhpcy53aWRnZXQuc3BlYy5zdG9wRXZlbnQ7XG4gICAgICAgIHJldHVybiBzdG9wID8gc3RvcChldmVudCkgOiBmYWxzZTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24obXV0YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uLnR5cGUgIT0gXCJzZWxlY3Rpb25cIiB8fCB0aGlzLndpZGdldC5zcGVjLmlnbm9yZVNlbGVjdGlvbjtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy53aWRnZXQudHlwZS5kZXN0cm95KHRoaXMuZG9tKTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICBnZXQgZG9tQXRvbSgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBnZXQgaWdub3JlRm9yU2VsZWN0aW9uKCkgeyByZXR1cm4gISF0aGlzLndpZGdldC50eXBlLnNwZWMucmVsYXhlZFNpZGU7IH1cbiAgICBnZXQgc2lkZSgpIHsgcmV0dXJuIHRoaXMud2lkZ2V0LnR5cGUuc2lkZTsgfVxufVxuY2xhc3MgQ29tcG9zaXRpb25WaWV3RGVzYyBleHRlbmRzIFZpZXdEZXNjIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGRvbSwgdGV4dERPTSwgdGV4dCkge1xuICAgICAgICBzdXBlcihwYXJlbnQsIFtdLCBkb20sIG51bGwpO1xuICAgICAgICB0aGlzLnRleHRET00gPSB0ZXh0RE9NO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHsgcmV0dXJuIHRoaXMudGV4dC5sZW5ndGg7IH1cbiAgICBsb2NhbFBvc0Zyb21ET00oZG9tLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKGRvbSAhPSB0aGlzLnRleHRET00pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3NBdFN0YXJ0ICsgKG9mZnNldCA/IHRoaXMuc2l6ZSA6IDApO1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NBdFN0YXJ0ICsgb2Zmc2V0O1xuICAgIH1cbiAgICBkb21Gcm9tUG9zKHBvcykge1xuICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLnRleHRET00sIG9mZnNldDogcG9zIH07XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKG11dCkge1xuICAgICAgICByZXR1cm4gbXV0LnR5cGUgPT09ICdjaGFyYWN0ZXJEYXRhJyAmJiBtdXQudGFyZ2V0Lm5vZGVWYWx1ZSA9PSBtdXQub2xkVmFsdWU7XG4gICAgfVxufVxuLy8gQSBtYXJrIGRlc2MgcmVwcmVzZW50cyBhIG1hcmsuIE1heSBoYXZlIG11bHRpcGxlIGNoaWxkcmVuLFxuLy8gZGVwZW5kaW5nIG9uIGhvdyB0aGUgbWFyayBpcyBzcGxpdC4gTm90ZSB0aGF0IG1hcmtzIGFyZSBkcmF3biB1c2luZ1xuLy8gYSBmaXhlZCBuZXN0aW5nIG9yZGVyLCBmb3Igc2ltcGxpY2l0eSBhbmQgcHJlZGljdGFiaWxpdHksIHNvIGluXG4vLyBzb21lIGNhc2VzIHRoZXkgd2lsbCBiZSBzcGxpdCBtb3JlIG9mdGVuIHRoYW4gd291bGQgYXBwZWFyXG4vLyBuZWNlc3NhcnkuXG5jbGFzcyBNYXJrVmlld0Rlc2MgZXh0ZW5kcyBWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBtYXJrLCBkb20sIGNvbnRlbnRET00sIHNwZWMpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBbXSwgZG9tLCBjb250ZW50RE9NKTtcbiAgICAgICAgdGhpcy5tYXJrID0gbWFyaztcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShwYXJlbnQsIG1hcmssIGlubGluZSwgdmlldykge1xuICAgICAgICBsZXQgY3VzdG9tID0gdmlldy5ub2RlVmlld3NbbWFyay50eXBlLm5hbWVdO1xuICAgICAgICBsZXQgc3BlYyA9IGN1c3RvbSAmJiBjdXN0b20obWFyaywgdmlldywgaW5saW5lKTtcbiAgICAgICAgaWYgKCFzcGVjIHx8ICFzcGVjLmRvbSlcbiAgICAgICAgICAgIHNwZWMgPSBET01TZXJpYWxpemVyLnJlbmRlclNwZWMoZG9jdW1lbnQsIG1hcmsudHlwZS5zcGVjLnRvRE9NKG1hcmssIGlubGluZSksIG51bGwsIG1hcmsuYXR0cnMpO1xuICAgICAgICByZXR1cm4gbmV3IE1hcmtWaWV3RGVzYyhwYXJlbnQsIG1hcmssIHNwZWMuZG9tLCBzcGVjLmNvbnRlbnRET00gfHwgc3BlYy5kb20sIHNwZWMpO1xuICAgIH1cbiAgICBwYXJzZVJ1bGUoKSB7XG4gICAgICAgIGlmICgodGhpcy5kaXJ0eSAmIE5PREVfRElSVFkpIHx8IHRoaXMubWFyay50eXBlLnNwZWMucmVwYXJzZUluVmlldylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4geyBtYXJrOiB0aGlzLm1hcmsudHlwZS5uYW1lLCBhdHRyczogdGhpcy5tYXJrLmF0dHJzLCBjb250ZW50RWxlbWVudDogdGhpcy5jb250ZW50RE9NIH07XG4gICAgfVxuICAgIG1hdGNoZXNNYXJrKG1hcmspIHsgcmV0dXJuIHRoaXMuZGlydHkgIT0gTk9ERV9ESVJUWSAmJiB0aGlzLm1hcmsuZXEobWFyayk7IH1cbiAgICBtYXJrRGlydHkoZnJvbSwgdG8pIHtcbiAgICAgICAgc3VwZXIubWFya0RpcnR5KGZyb20sIHRvKTtcbiAgICAgICAgLy8gTW92ZSBkaXJ0eSBpbmZvIHRvIG5lYXJlc3Qgbm9kZSB2aWV3XG4gICAgICAgIGlmICh0aGlzLmRpcnR5ICE9IE5PVF9ESVJUWSkge1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICAgICAgd2hpbGUgKCFwYXJlbnQubm9kZSlcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICAgICAgaWYgKHBhcmVudC5kaXJ0eSA8IHRoaXMuZGlydHkpXG4gICAgICAgICAgICAgICAgcGFyZW50LmRpcnR5ID0gdGhpcy5kaXJ0eTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBOT1RfRElSVFk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2xpY2UoZnJvbSwgdG8sIHZpZXcpIHtcbiAgICAgICAgbGV0IGNvcHkgPSBNYXJrVmlld0Rlc2MuY3JlYXRlKHRoaXMucGFyZW50LCB0aGlzLm1hcmssIHRydWUsIHZpZXcpO1xuICAgICAgICBsZXQgbm9kZXMgPSB0aGlzLmNoaWxkcmVuLCBzaXplID0gdGhpcy5zaXplO1xuICAgICAgICBpZiAodG8gPCBzaXplKVxuICAgICAgICAgICAgbm9kZXMgPSByZXBsYWNlTm9kZXMobm9kZXMsIHRvLCBzaXplLCB2aWV3KTtcbiAgICAgICAgaWYgKGZyb20gPiAwKVxuICAgICAgICAgICAgbm9kZXMgPSByZXBsYWNlTm9kZXMobm9kZXMsIDAsIGZyb20sIHZpZXcpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgbm9kZXNbaV0ucGFyZW50ID0gY29weTtcbiAgICAgICAgY29weS5jaGlsZHJlbiA9IG5vZGVzO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24obXV0YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlYy5pZ25vcmVNdXRhdGlvbiA/IHRoaXMuc3BlYy5pZ25vcmVNdXRhdGlvbihtdXRhdGlvbikgOiBzdXBlci5pZ25vcmVNdXRhdGlvbihtdXRhdGlvbik7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnNwZWMuZGVzdHJveSlcbiAgICAgICAgICAgIHRoaXMuc3BlYy5kZXN0cm95KCk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG59XG4vLyBOb2RlIHZpZXcgZGVzY3MgYXJlIHRoZSBtYWluLCBtb3N0IGNvbW1vbiB0eXBlIG9mIHZpZXcgZGVzYywgYW5kXG4vLyBjb3JyZXNwb25kIHRvIGFuIGFjdHVhbCBub2RlIGluIHRoZSBkb2N1bWVudC4gVW5saWtlIG1hcmsgZGVzY3MsXG4vLyB0aGV5IHBvcHVsYXRlIHRoZWlyIGNoaWxkIGFycmF5IHRoZW1zZWx2ZXMuXG5jbGFzcyBOb2RlVmlld0Rlc2MgZXh0ZW5kcyBWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBjb250ZW50RE9NLCBub2RlRE9NLCB2aWV3LCBwb3MpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBbXSwgZG9tLCBjb250ZW50RE9NKTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5vdXRlckRlY28gPSBvdXRlckRlY287XG4gICAgICAgIHRoaXMuaW5uZXJEZWNvID0gaW5uZXJEZWNvO1xuICAgICAgICB0aGlzLm5vZGVET00gPSBub2RlRE9NO1xuICAgIH1cbiAgICAvLyBCeSBkZWZhdWx0LCBhIG5vZGUgaXMgcmVuZGVyZWQgdXNpbmcgdGhlIGB0b0RPTWAgbWV0aG9kIGZyb20gdGhlXG4gICAgLy8gbm9kZSB0eXBlIHNwZWMuIEJ1dCBjbGllbnQgY29kZSBjYW4gdXNlIHRoZSBgbm9kZVZpZXdzYCBzcGVjIHRvXG4gICAgLy8gc3VwcGx5IGEgY3VzdG9tIG5vZGUgdmlldywgd2hpY2ggY2FuIGluZmx1ZW5jZSB2YXJpb3VzIGFzcGVjdHMgb2ZcbiAgICAvLyB0aGUgd2F5IHRoZSBub2RlIHdvcmtzLlxuICAgIC8vXG4gICAgLy8gKFVzaW5nIHN1YmNsYXNzaW5nIGZvciB0aGlzIHdhcyBpbnRlbnRpb25hbGx5IGRlY2lkZWQgYWdhaW5zdCxcbiAgICAvLyBzaW5jZSBpdCdkIHJlcXVpcmUgZXhwb3NpbmcgYSB3aG9sZSBzbGV3IG9mIGZpbmlja3lcbiAgICAvLyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIHRvIHRoZSB1c2VyIGNvZGUgdGhhdCB0aGV5IHByb2JhYmx5IHdpbGxcbiAgICAvLyBuZXZlciBuZWVkLilcbiAgICBzdGF0aWMgY3JlYXRlKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIHBvcykge1xuICAgICAgICBsZXQgY3VzdG9tID0gdmlldy5ub2RlVmlld3Nbbm9kZS50eXBlLm5hbWVdLCBkZXNjT2JqO1xuICAgICAgICBsZXQgc3BlYyA9IGN1c3RvbSAmJiBjdXN0b20obm9kZSwgdmlldywgKCkgPT4ge1xuICAgICAgICAgICAgLy8gKFRoaXMgaXMgYSBmdW5jdGlvbiB0aGF0IGFsbG93cyB0aGUgY3VzdG9tIHZpZXcgdG8gZmluZCBpdHNcbiAgICAgICAgICAgIC8vIG93biBwb3NpdGlvbilcbiAgICAgICAgICAgIGlmICghZGVzY09iailcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgICAgaWYgKGRlc2NPYmoucGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjT2JqLnBhcmVudC5wb3NCZWZvcmVDaGlsZChkZXNjT2JqKTtcbiAgICAgICAgfSwgb3V0ZXJEZWNvLCBpbm5lckRlY28pO1xuICAgICAgICBsZXQgZG9tID0gc3BlYyAmJiBzcGVjLmRvbSwgY29udGVudERPTSA9IHNwZWMgJiYgc3BlYy5jb250ZW50RE9NO1xuICAgICAgICBpZiAobm9kZS5pc1RleHQpIHtcbiAgICAgICAgICAgIGlmICghZG9tKVxuICAgICAgICAgICAgICAgIGRvbSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5vZGUudGV4dCk7XG4gICAgICAgICAgICBlbHNlIGlmIChkb20ubm9kZVR5cGUgIT0gMylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRleHQgbXVzdCBiZSByZW5kZXJlZCBhcyBhIERPTSB0ZXh0IG5vZGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWRvbSkge1xuICAgICAgICAgICAgbGV0IHNwZWMgPSBET01TZXJpYWxpemVyLnJlbmRlclNwZWMoZG9jdW1lbnQsIG5vZGUudHlwZS5zcGVjLnRvRE9NKG5vZGUpLCBudWxsLCBub2RlLmF0dHJzKTtcbiAgICAgICAgICAgICh7IGRvbSwgY29udGVudERPTSB9ID0gc3BlYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb250ZW50RE9NICYmICFub2RlLmlzVGV4dCAmJiBkb20ubm9kZU5hbWUgIT0gXCJCUlwiKSB7IC8vIENocm9tZSBnZXRzIGNvbmZ1c2VkIGJ5IDxiciBjb250ZW50ZWRpdGFibGU9ZmFsc2U+XG4gICAgICAgICAgICBpZiAoIWRvbS5oYXNBdHRyaWJ1dGUoXCJjb250ZW50ZWRpdGFibGVcIikpXG4gICAgICAgICAgICAgICAgZG9tLmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUuc3BlYy5kcmFnZ2FibGUpXG4gICAgICAgICAgICAgICAgZG9tLmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5vZGVET00gPSBkb207XG4gICAgICAgIGRvbSA9IGFwcGx5T3V0ZXJEZWNvKGRvbSwgb3V0ZXJEZWNvLCBub2RlKTtcbiAgICAgICAgaWYgKHNwZWMpXG4gICAgICAgICAgICByZXR1cm4gZGVzY09iaiA9IG5ldyBDdXN0b21Ob2RlVmlld0Rlc2MocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBjb250ZW50RE9NIHx8IG51bGwsIG5vZGVET00sIHNwZWMsIHZpZXcsIHBvcyArIDEpO1xuICAgICAgICBlbHNlIGlmIChub2RlLmlzVGV4dClcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dFZpZXdEZXNjKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgbm9kZURPTSwgdmlldyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm9kZVZpZXdEZXNjKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSB8fCBudWxsLCBub2RlRE9NLCB2aWV3LCBwb3MgKyAxKTtcbiAgICB9XG4gICAgcGFyc2VSdWxlKCkge1xuICAgICAgICAvLyBFeHBlcmltZW50YWwga2x1ZGdlIHRvIGFsbG93IG9wdC1pbiByZS1wYXJzaW5nIG9mIG5vZGVzXG4gICAgICAgIGlmICh0aGlzLm5vZGUudHlwZS5zcGVjLnJlcGFyc2VJblZpZXcpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgLy8gRklYTUUgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGlzIGNhbiBhbHdheXMgcmV0dXJuIHRoZSBjdXJyZW50XG4gICAgICAgIC8vIGF0dHJzIG1lYW5zIHRoYXQgaWYgdGhlIHVzZXIgc29tZWhvdyBtYW5hZ2VzIHRvIGNoYW5nZSB0aGVcbiAgICAgICAgLy8gYXR0cnMgaW4gdGhlIGRvbSwgdGhhdCB3b24ndCBiZSBwaWNrZWQgdXAuIE5vdCBlbnRpcmVseSBzdXJlXG4gICAgICAgIC8vIHdoZXRoZXIgdGhpcyBpcyBhIHByb2JsZW1cbiAgICAgICAgbGV0IHJ1bGUgPSB7IG5vZGU6IHRoaXMubm9kZS50eXBlLm5hbWUsIGF0dHJzOiB0aGlzLm5vZGUuYXR0cnMgfTtcbiAgICAgICAgaWYgKHRoaXMubm9kZS50eXBlLndoaXRlc3BhY2UgPT0gXCJwcmVcIilcbiAgICAgICAgICAgIHJ1bGUucHJlc2VydmVXaGl0ZXNwYWNlID0gXCJmdWxsXCI7XG4gICAgICAgIGlmICghdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICBydWxlLmdldENvbnRlbnQgPSAoKSA9PiB0aGlzLm5vZGUuY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5jb250ZW50TG9zdCkge1xuICAgICAgICAgICAgcnVsZS5jb250ZW50RWxlbWVudCA9IHRoaXMuY29udGVudERPTTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIENocm9tZSBsaWtlcyB0byByYW5kb21seSByZWNyZWF0ZSBwYXJlbnQgbm9kZXMgd2hlblxuICAgICAgICAgICAgLy8gYmFja3NwYWNpbmcgdGhpbmdzLiBXaGVuIHRoYXQgaGFwcGVucywgdGhpcyB0cmllcyB0byBmaW5kIHRoZVxuICAgICAgICAgICAgLy8gbmV3IHBhcmVudC5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kb20uY29udGFpbnMoY2hpbGQuZG9tLnBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGUuY29udGVudEVsZW1lbnQgPSBjaGlsZC5kb20ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFydWxlLmNvbnRlbnRFbGVtZW50KVxuICAgICAgICAgICAgICAgIHJ1bGUuZ2V0Q29udGVudCA9ICgpID0+IEZyYWdtZW50LmVtcHR5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydWxlO1xuICAgIH1cbiAgICBtYXRjaGVzTm9kZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbykge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXJ0eSA9PSBOT1RfRElSVFkgJiYgbm9kZS5lcSh0aGlzLm5vZGUpICYmXG4gICAgICAgICAgICBzYW1lT3V0ZXJEZWNvKG91dGVyRGVjbywgdGhpcy5vdXRlckRlY28pICYmIGlubmVyRGVjby5lcSh0aGlzLmlubmVyRGVjbyk7XG4gICAgfVxuICAgIGdldCBzaXplKCkgeyByZXR1cm4gdGhpcy5ub2RlLm5vZGVTaXplOyB9XG4gICAgZ2V0IGJvcmRlcigpIHsgcmV0dXJuIHRoaXMubm9kZS5pc0xlYWYgPyAwIDogMTsgfVxuICAgIC8vIFN5bmNzIGB0aGlzLmNoaWxkcmVuYCB0byBtYXRjaCBgdGhpcy5ub2RlLmNvbnRlbnRgIGFuZCB0aGUgbG9jYWxcbiAgICAvLyBkZWNvcmF0aW9ucywgcG9zc2libHkgaW50cm9kdWNpbmcgbmVzdGluZyBmb3IgbWFya3MuIFRoZW4sIGluIGFcbiAgICAvLyBzZXBhcmF0ZSBzdGVwLCBzeW5jcyB0aGUgRE9NIGluc2lkZSBgdGhpcy5jb250ZW50RE9NYCB0b1xuICAgIC8vIGB0aGlzLmNoaWxkcmVuYC5cbiAgICB1cGRhdGVDaGlsZHJlbih2aWV3LCBwb3MpIHtcbiAgICAgICAgbGV0IGlubGluZSA9IHRoaXMubm9kZS5pbmxpbmVDb250ZW50LCBvZmYgPSBwb3M7XG4gICAgICAgIGxldCBjb21wb3NpdGlvbiA9IHZpZXcuY29tcG9zaW5nID8gdGhpcy5sb2NhbENvbXBvc2l0aW9uSW5mbyh2aWV3LCBwb3MpIDogbnVsbDtcbiAgICAgICAgbGV0IGxvY2FsQ29tcG9zaXRpb24gPSBjb21wb3NpdGlvbiAmJiBjb21wb3NpdGlvbi5wb3MgPiAtMSA/IGNvbXBvc2l0aW9uIDogbnVsbDtcbiAgICAgICAgbGV0IGNvbXBvc2l0aW9uSW5DaGlsZCA9IGNvbXBvc2l0aW9uICYmIGNvbXBvc2l0aW9uLnBvcyA8IDA7XG4gICAgICAgIGxldCB1cGRhdGVyID0gbmV3IFZpZXdUcmVlVXBkYXRlcih0aGlzLCBsb2NhbENvbXBvc2l0aW9uICYmIGxvY2FsQ29tcG9zaXRpb24ubm9kZSwgdmlldyk7XG4gICAgICAgIGl0ZXJEZWNvKHRoaXMubm9kZSwgdGhpcy5pbm5lckRlY28sICh3aWRnZXQsIGksIGluc2lkZU5vZGUpID0+IHtcbiAgICAgICAgICAgIGlmICh3aWRnZXQuc3BlYy5tYXJrcylcbiAgICAgICAgICAgICAgICB1cGRhdGVyLnN5bmNUb01hcmtzKHdpZGdldC5zcGVjLm1hcmtzLCBpbmxpbmUsIHZpZXcsIGkpO1xuICAgICAgICAgICAgZWxzZSBpZiAod2lkZ2V0LnR5cGUuc2lkZSA+PSAwICYmICFpbnNpZGVOb2RlKVxuICAgICAgICAgICAgICAgIHVwZGF0ZXIuc3luY1RvTWFya3MoaSA9PSB0aGlzLm5vZGUuY2hpbGRDb3VudCA/IE1hcmsubm9uZSA6IHRoaXMubm9kZS5jaGlsZChpKS5tYXJrcywgaW5saW5lLCB2aWV3LCBpKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBuZXh0IG5vZGUgaXMgYSBkZXNjIG1hdGNoaW5nIHRoaXMgd2lkZ2V0LCByZXVzZSBpdCxcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBpbnNlcnQgdGhlIHdpZGdldCBhcyBhIG5ldyB2aWV3IGRlc2MuXG4gICAgICAgICAgICB1cGRhdGVyLnBsYWNlV2lkZ2V0KHdpZGdldCwgdmlldywgb2ZmKTtcbiAgICAgICAgfSwgKGNoaWxkLCBvdXRlckRlY28sIGlubmVyRGVjbywgaSkgPT4ge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSB3cmFwcGluZyBtYXJrIGRlc2NzIG1hdGNoIHRoZSBub2RlJ3MgbWFya3MuXG4gICAgICAgICAgICB1cGRhdGVyLnN5bmNUb01hcmtzKGNoaWxkLm1hcmtzLCBpbmxpbmUsIHZpZXcsIGkpO1xuICAgICAgICAgICAgLy8gVHJ5IHNldmVyYWwgc3RyYXRlZ2llcyBmb3IgZHJhd2luZyB0aGlzIG5vZGVcbiAgICAgICAgICAgIGxldCBjb21wSW5kZXg7XG4gICAgICAgICAgICBpZiAodXBkYXRlci5maW5kTm9kZU1hdGNoKGNoaWxkLCBvdXRlckRlY28sIGlubmVyRGVjbywgaSkpIDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbXBvc2l0aW9uSW5DaGlsZCAmJiB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tID4gb2ZmICYmXG4gICAgICAgICAgICAgICAgdmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gPCBvZmYgKyBjaGlsZC5ub2RlU2l6ZSAmJlxuICAgICAgICAgICAgICAgIChjb21wSW5kZXggPSB1cGRhdGVyLmZpbmRJbmRleFdpdGhDaGlsZChjb21wb3NpdGlvbi5ub2RlKSkgPiAtMSAmJlxuICAgICAgICAgICAgICAgIHVwZGF0ZXIudXBkYXRlTm9kZUF0KGNoaWxkLCBvdXRlckRlY28sIGlubmVyRGVjbywgY29tcEluZGV4LCB2aWV3KSkgO1xuICAgICAgICAgICAgZWxzZSBpZiAodXBkYXRlci51cGRhdGVOZXh0Tm9kZShjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIGksIG9mZikpIDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBpdCBhcyBhIG5ldyB2aWV3XG4gICAgICAgICAgICAgICAgdXBkYXRlci5hZGROb2RlKGNoaWxkLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgb2ZmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZiArPSBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIERyb3AgYWxsIHJlbWFpbmluZyBkZXNjcyBhZnRlciB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgICAgdXBkYXRlci5zeW5jVG9NYXJrcyhbXSwgaW5saW5lLCB2aWV3LCAwKTtcbiAgICAgICAgaWYgKHRoaXMubm9kZS5pc1RleHRibG9jaylcbiAgICAgICAgICAgIHVwZGF0ZXIuYWRkVGV4dGJsb2NrSGFja3MoKTtcbiAgICAgICAgdXBkYXRlci5kZXN0cm95UmVzdCgpO1xuICAgICAgICAvLyBTeW5jIHRoZSBET00gaWYgYW55dGhpbmcgY2hhbmdlZFxuICAgICAgICBpZiAodXBkYXRlci5jaGFuZ2VkIHx8IHRoaXMuZGlydHkgPT0gQ09OVEVOVF9ESVJUWSkge1xuICAgICAgICAgICAgLy8gTWF5IGhhdmUgdG8gcHJvdGVjdCBmb2N1c2VkIERPTSBmcm9tIGJlaW5nIGNoYW5nZWQgaWYgYSBjb21wb3NpdGlvbiBpcyBhY3RpdmVcbiAgICAgICAgICAgIGlmIChsb2NhbENvbXBvc2l0aW9uKVxuICAgICAgICAgICAgICAgIHRoaXMucHJvdGVjdExvY2FsQ29tcG9zaXRpb24odmlldywgbG9jYWxDb21wb3NpdGlvbik7XG4gICAgICAgICAgICByZW5kZXJEZXNjcyh0aGlzLmNvbnRlbnRET00sIHRoaXMuY2hpbGRyZW4sIHZpZXcpO1xuICAgICAgICAgICAgaWYgKGlvcylcbiAgICAgICAgICAgICAgICBpb3NIYWNrcyh0aGlzLmRvbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9jYWxDb21wb3NpdGlvbkluZm8odmlldywgcG9zKSB7XG4gICAgICAgIC8vIE9ubHkgZG8gc29tZXRoaW5nIGlmIGJvdGggdGhlIHNlbGVjdGlvbiBhbmQgYSBmb2N1c2VkIHRleHQgbm9kZVxuICAgICAgICAvLyBhcmUgaW5zaWRlIG9mIHRoaXMgbm9kZVxuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGlmICghKHZpZXcuc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikgfHwgZnJvbSA8IHBvcyB8fCB0byA+IHBvcyArIHRoaXMubm9kZS5jb250ZW50LnNpemUpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHRleHROb2RlID0gdmlldy5pbnB1dC5jb21wb3NpdGlvbk5vZGU7XG4gICAgICAgIGlmICghdGV4dE5vZGUgfHwgIXRoaXMuZG9tLmNvbnRhaW5zKHRleHROb2RlLnBhcmVudE5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICh0aGlzLm5vZGUuaW5saW5lQ29udGVudCkge1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgdGV4dCBpbiB0aGUgZm9jdXNlZCBub2RlIGluIHRoZSBub2RlLCBzdG9wIGlmIGl0J3Mgbm90XG4gICAgICAgICAgICAvLyB0aGVyZSAobWF5IGhhdmUgYmVlbiBtb2RpZmllZCB0aHJvdWdoIG90aGVyIG1lYW5zLCBpbiB3aGljaFxuICAgICAgICAgICAgLy8gY2FzZSBpdCBzaG91bGQgb3ZlcndyaXR0ZW4pXG4gICAgICAgICAgICBsZXQgdGV4dCA9IHRleHROb2RlLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgIGxldCB0ZXh0UG9zID0gZmluZFRleHRJbkZyYWdtZW50KHRoaXMubm9kZS5jb250ZW50LCB0ZXh0LCBmcm9tIC0gcG9zLCB0byAtIHBvcyk7XG4gICAgICAgICAgICByZXR1cm4gdGV4dFBvcyA8IDAgPyBudWxsIDogeyBub2RlOiB0ZXh0Tm9kZSwgcG9zOiB0ZXh0UG9zLCB0ZXh0IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0ZXh0Tm9kZSwgcG9zOiAtMSwgdGV4dDogXCJcIiB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb3RlY3RMb2NhbENvbXBvc2l0aW9uKHZpZXcsIHsgbm9kZSwgcG9zLCB0ZXh0IH0pIHtcbiAgICAgICAgLy8gVGhlIG5vZGUgaXMgYWxyZWFkeSBwYXJ0IG9mIGEgbG9jYWwgdmlldyBkZXNjLCBsZWF2ZSBpdCB0aGVyZVxuICAgICAgICBpZiAodGhpcy5nZXREZXNjKG5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBDcmVhdGUgYSBjb21wb3NpdGlvbiB2aWV3IGZvciB0aGUgb3JwaGFuZWQgbm9kZXNcbiAgICAgICAgbGV0IHRvcE5vZGUgPSBub2RlO1xuICAgICAgICBmb3IgKDs7IHRvcE5vZGUgPSB0b3BOb2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGlmICh0b3BOb2RlLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgd2hpbGUgKHRvcE5vZGUucHJldmlvdXNTaWJsaW5nKVxuICAgICAgICAgICAgICAgIHRvcE5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0b3BOb2RlLnByZXZpb3VzU2libGluZyk7XG4gICAgICAgICAgICB3aGlsZSAodG9wTm9kZS5uZXh0U2libGluZylcbiAgICAgICAgICAgICAgICB0b3BOb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodG9wTm9kZS5uZXh0U2libGluZyk7XG4gICAgICAgICAgICBpZiAodG9wTm9kZS5wbVZpZXdEZXNjKVxuICAgICAgICAgICAgICAgIHRvcE5vZGUucG1WaWV3RGVzYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVzYyA9IG5ldyBDb21wb3NpdGlvblZpZXdEZXNjKHRoaXMsIHRvcE5vZGUsIG5vZGUsIHRleHQpO1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uTm9kZXMucHVzaChkZXNjKTtcbiAgICAgICAgLy8gUGF0Y2ggdXAgdGhpcy5jaGlsZHJlbiB0byBjb250YWluIHRoZSBjb21wb3NpdGlvbiB2aWV3XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSByZXBsYWNlTm9kZXModGhpcy5jaGlsZHJlbiwgcG9zLCBwb3MgKyB0ZXh0Lmxlbmd0aCwgdmlldywgZGVzYyk7XG4gICAgfVxuICAgIC8vIElmIHRoaXMgZGVzYyBtdXN0IGJlIHVwZGF0ZWQgdG8gbWF0Y2ggdGhlIGdpdmVuIG5vZGUgZGVjb3JhdGlvbixcbiAgICAvLyBkbyBzbyBhbmQgcmV0dXJuIHRydWUuXG4gICAgdXBkYXRlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSB7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5ID09IE5PREVfRElSVFkgfHxcbiAgICAgICAgICAgICFub2RlLnNhbWVNYXJrdXAodGhpcy5ub2RlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy51cGRhdGVJbm5lcihub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB1cGRhdGVJbm5lcihub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykge1xuICAgICAgICB0aGlzLnVwZGF0ZU91dGVyRGVjbyhvdXRlckRlY28pO1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLmlubmVyRGVjbyA9IGlubmVyRGVjbztcbiAgICAgICAgaWYgKHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4odmlldywgdGhpcy5wb3NBdFN0YXJ0KTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IE5PVF9ESVJUWTtcbiAgICB9XG4gICAgdXBkYXRlT3V0ZXJEZWNvKG91dGVyRGVjbykge1xuICAgICAgICBpZiAoc2FtZU91dGVyRGVjbyhvdXRlckRlY28sIHRoaXMub3V0ZXJEZWNvKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IG5lZWRzV3JhcCA9IHRoaXMubm9kZURPTS5ub2RlVHlwZSAhPSAxO1xuICAgICAgICBsZXQgb2xkRE9NID0gdGhpcy5kb207XG4gICAgICAgIHRoaXMuZG9tID0gcGF0Y2hPdXRlckRlY28odGhpcy5kb20sIHRoaXMubm9kZURPTSwgY29tcHV0ZU91dGVyRGVjbyh0aGlzLm91dGVyRGVjbywgdGhpcy5ub2RlLCBuZWVkc1dyYXApLCBjb21wdXRlT3V0ZXJEZWNvKG91dGVyRGVjbywgdGhpcy5ub2RlLCBuZWVkc1dyYXApKTtcbiAgICAgICAgaWYgKHRoaXMuZG9tICE9IG9sZERPTSkge1xuICAgICAgICAgICAgb2xkRE9NLnBtVmlld0Rlc2MgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmRvbS5wbVZpZXdEZXNjID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm91dGVyRGVjbyA9IG91dGVyRGVjbztcbiAgICB9XG4gICAgLy8gTWFyayB0aGlzIG5vZGUgYXMgYmVpbmcgdGhlIHNlbGVjdGVkIG5vZGUuXG4gICAgc2VsZWN0Tm9kZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZURPTS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVET00uY2xhc3NMaXN0LmFkZChcIlByb3NlTWlycm9yLXNlbGVjdGVkbm9kZVwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRlbnRET00gfHwgIXRoaXMubm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlKVxuICAgICAgICAgICAgICAgIHRoaXMubm9kZURPTS5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFJlbW92ZSBzZWxlY3RlZCBub2RlIG1hcmtpbmcgZnJvbSB0aGlzIG5vZGUuXG4gICAgZGVzZWxlY3ROb2RlKCkge1xuICAgICAgICBpZiAodGhpcy5ub2RlRE9NLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZURPTS5jbGFzc0xpc3QucmVtb3ZlKFwiUHJvc2VNaXJyb3Itc2VsZWN0ZWRub2RlXCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGVudERPTSB8fCAhdGhpcy5ub2RlLnR5cGUuc3BlYy5kcmFnZ2FibGUpXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlRE9NLnJlbW92ZUF0dHJpYnV0ZShcImRyYWdnYWJsZVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZG9tQXRvbSgpIHsgcmV0dXJuIHRoaXMubm9kZS5pc0F0b207IH1cbn1cbi8vIENyZWF0ZSBhIHZpZXcgZGVzYyBmb3IgdGhlIHRvcC1sZXZlbCBkb2N1bWVudCBub2RlLCB0byBiZSBleHBvcnRlZFxuLy8gYW5kIHVzZWQgYnkgdGhlIHZpZXcgY2xhc3MuXG5mdW5jdGlvbiBkb2NWaWV3RGVzYyhkb2MsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIHZpZXcpIHtcbiAgICBhcHBseU91dGVyRGVjbyhkb20sIG91dGVyRGVjbywgZG9jKTtcbiAgICBsZXQgZG9jVmlldyA9IG5ldyBOb2RlVmlld0Rlc2ModW5kZWZpbmVkLCBkb2MsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIGRvbSwgZG9tLCB2aWV3LCAwKTtcbiAgICBpZiAoZG9jVmlldy5jb250ZW50RE9NKVxuICAgICAgICBkb2NWaWV3LnVwZGF0ZUNoaWxkcmVuKHZpZXcsIDApO1xuICAgIHJldHVybiBkb2NWaWV3O1xufVxuY2xhc3MgVGV4dFZpZXdEZXNjIGV4dGVuZHMgTm9kZVZpZXdEZXNjIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIG5vZGVET00sIHZpZXcpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBudWxsLCBub2RlRE9NLCB2aWV3LCAwKTtcbiAgICB9XG4gICAgcGFyc2VSdWxlKCkge1xuICAgICAgICBsZXQgc2tpcCA9IHRoaXMubm9kZURPTS5wYXJlbnROb2RlO1xuICAgICAgICB3aGlsZSAoc2tpcCAmJiBza2lwICE9IHRoaXMuZG9tICYmICFza2lwLnBtSXNEZWNvKVxuICAgICAgICAgICAgc2tpcCA9IHNraXAucGFyZW50Tm9kZTtcbiAgICAgICAgcmV0dXJuIHsgc2tpcDogKHNraXAgfHwgdHJ1ZSkgfTtcbiAgICB9XG4gICAgdXBkYXRlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSB7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5ID09IE5PREVfRElSVFkgfHwgKHRoaXMuZGlydHkgIT0gTk9UX0RJUlRZICYmICF0aGlzLmluUGFyZW50KCkpIHx8XG4gICAgICAgICAgICAhbm9kZS5zYW1lTWFya3VwKHRoaXMubm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMudXBkYXRlT3V0ZXJEZWNvKG91dGVyRGVjbyk7XG4gICAgICAgIGlmICgodGhpcy5kaXJ0eSAhPSBOT1RfRElSVFkgfHwgbm9kZS50ZXh0ICE9IHRoaXMubm9kZS50ZXh0KSAmJiBub2RlLnRleHQgIT0gdGhpcy5ub2RlRE9NLm5vZGVWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5ub2RlRE9NLm5vZGVWYWx1ZSA9IG5vZGUudGV4dDtcbiAgICAgICAgICAgIGlmICh2aWV3LnRyYWNrV3JpdGVzID09IHRoaXMubm9kZURPTSlcbiAgICAgICAgICAgICAgICB2aWV3LnRyYWNrV3JpdGVzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaW5QYXJlbnQoKSB7XG4gICAgICAgIGxldCBwYXJlbnRET00gPSB0aGlzLnBhcmVudC5jb250ZW50RE9NO1xuICAgICAgICBmb3IgKGxldCBuID0gdGhpcy5ub2RlRE9NOyBuOyBuID0gbi5wYXJlbnROb2RlKVxuICAgICAgICAgICAgaWYgKG4gPT0gcGFyZW50RE9NKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRvbUZyb21Qb3MocG9zKSB7XG4gICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMubm9kZURPTSwgb2Zmc2V0OiBwb3MgfTtcbiAgICB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKGRvbSwgb2Zmc2V0LCBiaWFzKSB7XG4gICAgICAgIGlmIChkb20gPT0gdGhpcy5ub2RlRE9NKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIE1hdGgubWluKG9mZnNldCwgdGhpcy5ub2RlLnRleHQubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmxvY2FsUG9zRnJvbURPTShkb20sIG9mZnNldCwgYmlhcyk7XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBtdXRhdGlvbi50eXBlICE9IFwiY2hhcmFjdGVyRGF0YVwiICYmIG11dGF0aW9uLnR5cGUgIT0gXCJzZWxlY3Rpb25cIjtcbiAgICB9XG4gICAgc2xpY2UoZnJvbSwgdG8sIHZpZXcpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLm5vZGUuY3V0KGZyb20sIHRvKSwgZG9tID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobm9kZS50ZXh0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0Vmlld0Rlc2ModGhpcy5wYXJlbnQsIG5vZGUsIHRoaXMub3V0ZXJEZWNvLCB0aGlzLmlubmVyRGVjbywgZG9tLCBkb20sIHZpZXcpO1xuICAgIH1cbiAgICBtYXJrRGlydHkoZnJvbSwgdG8pIHtcbiAgICAgICAgc3VwZXIubWFya0RpcnR5KGZyb20sIHRvKTtcbiAgICAgICAgaWYgKHRoaXMuZG9tICE9IHRoaXMubm9kZURPTSAmJiAoZnJvbSA9PSAwIHx8IHRvID09IHRoaXMubm9kZURPTS5ub2RlVmFsdWUubGVuZ3RoKSlcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBOT0RFX0RJUlRZO1xuICAgIH1cbiAgICBnZXQgZG9tQXRvbSgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaXNUZXh0KHRleHQpIHsgcmV0dXJuIHRoaXMubm9kZS50ZXh0ID09IHRleHQ7IH1cbn1cbi8vIEEgZHVtbXkgZGVzYyB1c2VkIHRvIHRhZyB0cmFpbGluZyBCUiBvciBJTUcgbm9kZXMgY3JlYXRlZCB0byB3b3JrXG4vLyBhcm91bmQgY29udGVudEVkaXRhYmxlIHRlcnJpYmxlbmVzcy5cbmNsYXNzIFRyYWlsaW5nSGFja1ZpZXdEZXNjIGV4dGVuZHMgVmlld0Rlc2Mge1xuICAgIHBhcnNlUnVsZSgpIHsgcmV0dXJuIHsgaWdub3JlOiB0cnVlIH07IH1cbiAgICBtYXRjaGVzSGFjayhub2RlTmFtZSkgeyByZXR1cm4gdGhpcy5kaXJ0eSA9PSBOT1RfRElSVFkgJiYgdGhpcy5kb20ubm9kZU5hbWUgPT0gbm9kZU5hbWU7IH1cbiAgICBnZXQgZG9tQXRvbSgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBnZXQgaWdub3JlRm9yQ29vcmRzKCkgeyByZXR1cm4gdGhpcy5kb20ubm9kZU5hbWUgPT0gXCJJTUdcIjsgfVxufVxuLy8gQSBzZXBhcmF0ZSBzdWJjbGFzcyBpcyB1c2VkIGZvciBjdXN0b21pemVkIG5vZGUgdmlld3MsIHNvIHRoYXQgdGhlXG4vLyBleHRyYSBjaGVja3Mgb25seSBoYXZlIHRvIGJlIG1hZGUgZm9yIG5vZGVzIHRoYXQgYXJlIGFjdHVhbGx5XG4vLyBjdXN0b21pemVkLlxuY2xhc3MgQ3VzdG9tTm9kZVZpZXdEZXNjIGV4dGVuZHMgTm9kZVZpZXdEZXNjIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIGNvbnRlbnRET00sIG5vZGVET00sIHNwZWMsIHZpZXcsIHBvcykge1xuICAgICAgICBzdXBlcihwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIGNvbnRlbnRET00sIG5vZGVET00sIHZpZXcsIHBvcyk7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgfVxuICAgIC8vIEEgY3VzdG9tIGB1cGRhdGVgIG1ldGhvZCBnZXRzIHRvIGRlY2lkZSB3aGV0aGVyIHRoZSB1cGRhdGUgZ29lc1xuICAgIC8vIHRocm91Z2guIElmIGl0IGRvZXMsIGFuZCB0aGVyZSdzIGEgYGNvbnRlbnRET01gIG5vZGUsIG91ciBsb2dpY1xuICAgIC8vIHVwZGF0ZXMgdGhlIGNoaWxkcmVuLlxuICAgIHVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykge1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSA9PSBOT0RFX0RJUlRZKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5zcGVjLnVwZGF0ZSAmJiAodGhpcy5ub2RlLnR5cGUgPT0gbm9kZS50eXBlIHx8IHRoaXMuc3BlYy5tdWx0aVR5cGUpKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5zcGVjLnVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlSW5uZXIobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5jb250ZW50RE9NICYmICFub2RlLmlzTGVhZikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLnVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0Tm9kZSgpIHtcbiAgICAgICAgdGhpcy5zcGVjLnNlbGVjdE5vZGUgPyB0aGlzLnNwZWMuc2VsZWN0Tm9kZSgpIDogc3VwZXIuc2VsZWN0Tm9kZSgpO1xuICAgIH1cbiAgICBkZXNlbGVjdE5vZGUoKSB7XG4gICAgICAgIHRoaXMuc3BlYy5kZXNlbGVjdE5vZGUgPyB0aGlzLnNwZWMuZGVzZWxlY3ROb2RlKCkgOiBzdXBlci5kZXNlbGVjdE5vZGUoKTtcbiAgICB9XG4gICAgc2V0U2VsZWN0aW9uKGFuY2hvciwgaGVhZCwgdmlldywgZm9yY2UpIHtcbiAgICAgICAgdGhpcy5zcGVjLnNldFNlbGVjdGlvbiA/IHRoaXMuc3BlYy5zZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkLCB2aWV3LnJvb3QpXG4gICAgICAgICAgICA6IHN1cGVyLnNldFNlbGVjdGlvbihhbmNob3IsIGhlYWQsIHZpZXcsIGZvcmNlKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3BlYy5kZXN0cm95KVxuICAgICAgICAgICAgdGhpcy5zcGVjLmRlc3Ryb3koKTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICBzdG9wRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlYy5zdG9wRXZlbnQgPyB0aGlzLnNwZWMuc3RvcEV2ZW50KGV2ZW50KSA6IGZhbHNlO1xuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbihtdXRhdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGVjLmlnbm9yZU11dGF0aW9uID8gdGhpcy5zcGVjLmlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSA6IHN1cGVyLmlnbm9yZU11dGF0aW9uKG11dGF0aW9uKTtcbiAgICB9XG59XG4vLyBTeW5jIHRoZSBjb250ZW50IG9mIHRoZSBnaXZlbiBET00gbm9kZSB3aXRoIHRoZSBub2RlcyBhc3NvY2lhdGVkXG4vLyB3aXRoIHRoZSBnaXZlbiBhcnJheSBvZiB2aWV3IGRlc2NzLCByZWN1cnNpbmcgaW50byBtYXJrIGRlc2NzXG4vLyBiZWNhdXNlIHRoaXMgc2hvdWxkIHN5bmMgdGhlIHN1YnRyZWUgZm9yIGEgd2hvbGUgbm9kZSBhdCBhIHRpbWUuXG5mdW5jdGlvbiByZW5kZXJEZXNjcyhwYXJlbnRET00sIGRlc2NzLCB2aWV3KSB7XG4gICAgbGV0IGRvbSA9IHBhcmVudERPTS5maXJzdENoaWxkLCB3cml0dGVuID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXNjcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgZGVzYyA9IGRlc2NzW2ldLCBjaGlsZERPTSA9IGRlc2MuZG9tO1xuICAgICAgICBpZiAoY2hpbGRET00ucGFyZW50Tm9kZSA9PSBwYXJlbnRET00pIHtcbiAgICAgICAgICAgIHdoaWxlIChjaGlsZERPTSAhPSBkb20pIHtcbiAgICAgICAgICAgICAgICBkb20gPSBybShkb20pO1xuICAgICAgICAgICAgICAgIHdyaXR0ZW4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tID0gZG9tLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd3JpdHRlbiA9IHRydWU7XG4gICAgICAgICAgICBwYXJlbnRET00uaW5zZXJ0QmVmb3JlKGNoaWxkRE9NLCBkb20pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXNjIGluc3RhbmNlb2YgTWFya1ZpZXdEZXNjKSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gZG9tID8gZG9tLnByZXZpb3VzU2libGluZyA6IHBhcmVudERPTS5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICByZW5kZXJEZXNjcyhkZXNjLmNvbnRlbnRET00sIGRlc2MuY2hpbGRyZW4sIHZpZXcpO1xuICAgICAgICAgICAgZG9tID0gcG9zID8gcG9zLm5leHRTaWJsaW5nIDogcGFyZW50RE9NLmZpcnN0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKGRvbSkge1xuICAgICAgICBkb20gPSBybShkb20pO1xuICAgICAgICB3cml0dGVuID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHdyaXR0ZW4gJiYgdmlldy50cmFja1dyaXRlcyA9PSBwYXJlbnRET00pXG4gICAgICAgIHZpZXcudHJhY2tXcml0ZXMgPSBudWxsO1xufVxuY29uc3QgT3V0ZXJEZWNvTGV2ZWwgPSBmdW5jdGlvbiAobm9kZU5hbWUpIHtcbiAgICBpZiAobm9kZU5hbWUpXG4gICAgICAgIHRoaXMubm9kZU5hbWUgPSBub2RlTmFtZTtcbn07XG5PdXRlckRlY29MZXZlbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuY29uc3Qgbm9EZWNvID0gW25ldyBPdXRlckRlY29MZXZlbF07XG5mdW5jdGlvbiBjb21wdXRlT3V0ZXJEZWNvKG91dGVyRGVjbywgbm9kZSwgbmVlZHNXcmFwKSB7XG4gICAgaWYgKG91dGVyRGVjby5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuIG5vRGVjbztcbiAgICBsZXQgdG9wID0gbmVlZHNXcmFwID8gbm9EZWNvWzBdIDogbmV3IE91dGVyRGVjb0xldmVsLCByZXN1bHQgPSBbdG9wXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dGVyRGVjby5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgYXR0cnMgPSBvdXRlckRlY29baV0udHlwZS5hdHRycztcbiAgICAgICAgaWYgKCFhdHRycylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoYXR0cnMubm9kZU5hbWUpXG4gICAgICAgICAgICByZXN1bHQucHVzaCh0b3AgPSBuZXcgT3V0ZXJEZWNvTGV2ZWwoYXR0cnMubm9kZU5hbWUpKTtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBhdHRycykge1xuICAgICAgICAgICAgbGV0IHZhbCA9IGF0dHJzW25hbWVdO1xuICAgICAgICAgICAgaWYgKHZhbCA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKG5lZWRzV3JhcCAmJiByZXN1bHQubGVuZ3RoID09IDEpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godG9wID0gbmV3IE91dGVyRGVjb0xldmVsKG5vZGUuaXNJbmxpbmUgPyBcInNwYW5cIiA6IFwiZGl2XCIpKTtcbiAgICAgICAgICAgIGlmIChuYW1lID09IFwiY2xhc3NcIilcbiAgICAgICAgICAgICAgICB0b3AuY2xhc3MgPSAodG9wLmNsYXNzID8gdG9wLmNsYXNzICsgXCIgXCIgOiBcIlwiKSArIHZhbDtcbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgPT0gXCJzdHlsZVwiKVxuICAgICAgICAgICAgICAgIHRvcC5zdHlsZSA9ICh0b3Auc3R5bGUgPyB0b3Auc3R5bGUgKyBcIjtcIiA6IFwiXCIpICsgdmFsO1xuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSAhPSBcIm5vZGVOYW1lXCIpXG4gICAgICAgICAgICAgICAgdG9wW25hbWVdID0gdmFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXRjaE91dGVyRGVjbyhvdXRlckRPTSwgbm9kZURPTSwgcHJldkNvbXB1dGVkLCBjdXJDb21wdXRlZCkge1xuICAgIC8vIFNob3J0Y3V0IGZvciB0cml2aWFsIGNhc2VcbiAgICBpZiAocHJldkNvbXB1dGVkID09IG5vRGVjbyAmJiBjdXJDb21wdXRlZCA9PSBub0RlY28pXG4gICAgICAgIHJldHVybiBub2RlRE9NO1xuICAgIGxldCBjdXJET00gPSBub2RlRE9NO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VyQ29tcHV0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGRlY28gPSBjdXJDb21wdXRlZFtpXSwgcHJldiA9IHByZXZDb21wdXRlZFtpXTtcbiAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQ7XG4gICAgICAgICAgICBpZiAocHJldiAmJiBwcmV2Lm5vZGVOYW1lID09IGRlY28ubm9kZU5hbWUgJiYgY3VyRE9NICE9IG91dGVyRE9NICYmXG4gICAgICAgICAgICAgICAgKHBhcmVudCA9IGN1ckRPTS5wYXJlbnROb2RlKSAmJiBwYXJlbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PSBkZWNvLm5vZGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgY3VyRE9NID0gcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChkZWNvLm5vZGVOYW1lKTtcbiAgICAgICAgICAgICAgICBwYXJlbnQucG1Jc0RlY28gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChjdXJET00pO1xuICAgICAgICAgICAgICAgIHByZXYgPSBub0RlY29bMF07XG4gICAgICAgICAgICAgICAgY3VyRE9NID0gcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBhdGNoQXR0cmlidXRlcyhjdXJET00sIHByZXYgfHwgbm9EZWNvWzBdLCBkZWNvKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1ckRPTTtcbn1cbmZ1bmN0aW9uIHBhdGNoQXR0cmlidXRlcyhkb20sIHByZXYsIGN1cikge1xuICAgIGZvciAobGV0IG5hbWUgaW4gcHJldilcbiAgICAgICAgaWYgKG5hbWUgIT0gXCJjbGFzc1wiICYmIG5hbWUgIT0gXCJzdHlsZVwiICYmIG5hbWUgIT0gXCJub2RlTmFtZVwiICYmICEobmFtZSBpbiBjdXIpKVxuICAgICAgICAgICAgZG9tLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICBmb3IgKGxldCBuYW1lIGluIGN1cilcbiAgICAgICAgaWYgKG5hbWUgIT0gXCJjbGFzc1wiICYmIG5hbWUgIT0gXCJzdHlsZVwiICYmIG5hbWUgIT0gXCJub2RlTmFtZVwiICYmIGN1cltuYW1lXSAhPSBwcmV2W25hbWVdKVxuICAgICAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShuYW1lLCBjdXJbbmFtZV0pO1xuICAgIGlmIChwcmV2LmNsYXNzICE9IGN1ci5jbGFzcykge1xuICAgICAgICBsZXQgcHJldkxpc3QgPSBwcmV2LmNsYXNzID8gcHJldi5jbGFzcy5zcGxpdChcIiBcIikuZmlsdGVyKEJvb2xlYW4pIDogW107XG4gICAgICAgIGxldCBjdXJMaXN0ID0gY3VyLmNsYXNzID8gY3VyLmNsYXNzLnNwbGl0KFwiIFwiKS5maWx0ZXIoQm9vbGVhbikgOiBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2TGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChjdXJMaXN0LmluZGV4T2YocHJldkxpc3RbaV0pID09IC0xKVxuICAgICAgICAgICAgICAgIGRvbS5jbGFzc0xpc3QucmVtb3ZlKHByZXZMaXN0W2ldKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJMaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHByZXZMaXN0LmluZGV4T2YoY3VyTGlzdFtpXSkgPT0gLTEpXG4gICAgICAgICAgICAgICAgZG9tLmNsYXNzTGlzdC5hZGQoY3VyTGlzdFtpXSk7XG4gICAgICAgIGlmIChkb20uY2xhc3NMaXN0Lmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgZG9tLnJlbW92ZUF0dHJpYnV0ZShcImNsYXNzXCIpO1xuICAgIH1cbiAgICBpZiAocHJldi5zdHlsZSAhPSBjdXIuc3R5bGUpIHtcbiAgICAgICAgaWYgKHByZXYuc3R5bGUpIHtcbiAgICAgICAgICAgIGxldCBwcm9wID0gL1xccyooW1xcd1xcLVxceGExLVxcdWZmZmZdKylcXHMqOig/OlwiKD86XFxcXC58W15cIl0pKlwifCcoPzpcXFxcLnxbXiddKSonfFxcKC4qP1xcKXxbXjtdKSovZywgbTtcbiAgICAgICAgICAgIHdoaWxlIChtID0gcHJvcC5leGVjKHByZXYuc3R5bGUpKVxuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShtWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VyLnN0eWxlKVxuICAgICAgICAgICAgZG9tLnN0eWxlLmNzc1RleHQgKz0gY3VyLnN0eWxlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5T3V0ZXJEZWNvKGRvbSwgZGVjbywgbm9kZSkge1xuICAgIHJldHVybiBwYXRjaE91dGVyRGVjbyhkb20sIGRvbSwgbm9EZWNvLCBjb21wdXRlT3V0ZXJEZWNvKGRlY28sIG5vZGUsIGRvbS5ub2RlVHlwZSAhPSAxKSk7XG59XG5mdW5jdGlvbiBzYW1lT3V0ZXJEZWNvKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICghYVtpXS50eXBlLmVxKGJbaV0udHlwZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBSZW1vdmUgYSBET00gbm9kZSBhbmQgcmV0dXJuIGl0cyBuZXh0IHNpYmxpbmcuXG5mdW5jdGlvbiBybShkb20pIHtcbiAgICBsZXQgbmV4dCA9IGRvbS5uZXh0U2libGluZztcbiAgICBkb20ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkb20pO1xuICAgIHJldHVybiBuZXh0O1xufVxuLy8gSGVscGVyIGNsYXNzIGZvciBpbmNyZW1lbnRhbGx5IHVwZGF0aW5nIGEgdHJlZSBvZiBtYXJrIGRlc2NzIGFuZFxuLy8gdGhlIHdpZGdldCBhbmQgbm9kZSBkZXNjcyBpbnNpZGUgb2YgdGhlbS5cbmNsYXNzIFZpZXdUcmVlVXBkYXRlciB7XG4gICAgY29uc3RydWN0b3IodG9wLCBsb2NrLCB2aWV3KSB7XG4gICAgICAgIHRoaXMubG9jayA9IGxvY2s7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIC8vIEluZGV4IGludG8gYHRoaXMudG9wYCdzIGNoaWxkIGFycmF5LCByZXByZXNlbnRzIHRoZSBjdXJyZW50XG4gICAgICAgIC8vIHVwZGF0ZSBwb3NpdGlvbi5cbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIC8vIFdoZW4gZW50ZXJpbmcgYSBtYXJrLCB0aGUgY3VycmVudCB0b3AgYW5kIGluZGV4IGFyZSBwdXNoZWRcbiAgICAgICAgLy8gb250byB0aGlzLlxuICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICAgIC8vIFRyYWNrcyB3aGV0aGVyIGFueXRoaW5nIHdhcyBjaGFuZ2VkXG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgdGhpcy5wcmVNYXRjaCA9IHByZU1hdGNoKHRvcC5ub2RlLmNvbnRlbnQsIHRvcCk7XG4gICAgfVxuICAgIC8vIERlc3Ryb3kgYW5kIHJlbW92ZSB0aGUgY2hpbGRyZW4gYmV0d2VlbiB0aGUgZ2l2ZW4gaW5kaWNlcyBpblxuICAgIC8vIGB0aGlzLnRvcGAuXG4gICAgZGVzdHJveUJldHdlZW4oc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoc3RhcnQgPT0gZW5kKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKylcbiAgICAgICAgICAgIHRoaXMudG9wLmNoaWxkcmVuW2ldLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy50b3AuY2hpbGRyZW4uc3BsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCk7XG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgfVxuICAgIC8vIERlc3Ryb3kgYWxsIHJlbWFpbmluZyBjaGlsZHJlbiBpbiBgdGhpcy50b3BgLlxuICAgIGRlc3Ryb3lSZXN0KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aCk7XG4gICAgfVxuICAgIC8vIFN5bmMgdGhlIGN1cnJlbnQgc3RhY2sgb2YgbWFyayBkZXNjcyB3aXRoIHRoZSBnaXZlbiBhcnJheSBvZlxuICAgIC8vIG1hcmtzLCByZXVzaW5nIGV4aXN0aW5nIG1hcmsgZGVzY3Mgd2hlbiBwb3NzaWJsZS5cbiAgICBzeW5jVG9NYXJrcyhtYXJrcywgaW5saW5lLCB2aWV3LCBwYXJlbnRJbmRleCkge1xuICAgICAgICBsZXQga2VlcCA9IDAsIGRlcHRoID0gdGhpcy5zdGFjay5sZW5ndGggPj4gMTtcbiAgICAgICAgbGV0IG1heEtlZXAgPSBNYXRoLm1pbihkZXB0aCwgbWFya3MubGVuZ3RoKTtcbiAgICAgICAgd2hpbGUgKGtlZXAgPCBtYXhLZWVwICYmXG4gICAgICAgICAgICAoa2VlcCA9PSBkZXB0aCAtIDEgPyB0aGlzLnRvcCA6IHRoaXMuc3RhY2tbKGtlZXAgKyAxKSA8PCAxXSlcbiAgICAgICAgICAgICAgICAubWF0Y2hlc01hcmsobWFya3Nba2VlcF0pICYmIG1hcmtzW2tlZXBdLnR5cGUuc3BlYy5zcGFubmluZyAhPT0gZmFsc2UpXG4gICAgICAgICAgICBrZWVwKys7XG4gICAgICAgIHdoaWxlIChrZWVwIDwgZGVwdGgpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveVJlc3QoKTtcbiAgICAgICAgICAgIHRoaXMudG9wLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICB0aGlzLnRvcCA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChkZXB0aCA8IG1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMudG9wLCB0aGlzLmluZGV4ICsgMSk7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSAtMSwgc2NhblRvID0gdGhpcy50b3AuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHBhcmVudEluZGV4IDwgdGhpcy5wcmVNYXRjaC5pbmRleClcbiAgICAgICAgICAgICAgICBzY2FuVG8gPSBNYXRoLm1pbih0aGlzLmluZGV4ICsgMywgc2NhblRvKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmluZGV4OyBpIDwgc2NhblRvOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMudG9wLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0Lm1hdGNoZXNNYXJrKG1hcmtzW2RlcHRoXSkgJiYgIXRoaXMuaXNMb2NrZWQobmV4dC5kb20pKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvdW5kID4gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQgPiB0aGlzLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveUJldHdlZW4odGhpcy5pbmRleCwgZm91bmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnRvcCA9IHRoaXMudG9wLmNoaWxkcmVuW3RoaXMuaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hcmtEZXNjID0gTWFya1ZpZXdEZXNjLmNyZWF0ZSh0aGlzLnRvcCwgbWFya3NbZGVwdGhdLCBpbmxpbmUsIHZpZXcpO1xuICAgICAgICAgICAgICAgIHRoaXMudG9wLmNoaWxkcmVuLnNwbGljZSh0aGlzLmluZGV4LCAwLCBtYXJrRGVzYyk7XG4gICAgICAgICAgICAgICAgdGhpcy50b3AgPSBtYXJrRGVzYztcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRyeSB0byBmaW5kIGEgbm9kZSBkZXNjIG1hdGNoaW5nIHRoZSBnaXZlbiBkYXRhLiBTa2lwIG92ZXIgaXQgYW5kXG4gICAgLy8gcmV0dXJuIHRydWUgd2hlbiBzdWNjZXNzZnVsLlxuICAgIGZpbmROb2RlTWF0Y2gobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGluZGV4KSB7XG4gICAgICAgIGxldCBmb3VuZCA9IC0xLCB0YXJnZXREZXNjO1xuICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5wcmVNYXRjaC5pbmRleCAmJlxuICAgICAgICAgICAgKHRhcmdldERlc2MgPSB0aGlzLnByZU1hdGNoLm1hdGNoZXNbaW5kZXggLSB0aGlzLnByZU1hdGNoLmluZGV4XSkucGFyZW50ID09IHRoaXMudG9wICYmXG4gICAgICAgICAgICB0YXJnZXREZXNjLm1hdGNoZXNOb2RlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvKSkge1xuICAgICAgICAgICAgZm91bmQgPSB0aGlzLnRvcC5jaGlsZHJlbi5pbmRleE9mKHRhcmdldERlc2MsIHRoaXMuaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaW5kZXgsIGUgPSBNYXRoLm1pbih0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGgsIGkgKyA1KTsgaSA8IGU7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMudG9wLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5tYXRjaGVzTm9kZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbykgJiYgIXRoaXMucHJlTWF0Y2gubWF0Y2hlZC5oYXMoY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmb3VuZCA8IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveUJldHdlZW4odGhpcy5pbmRleCwgZm91bmQpO1xuICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB1cGRhdGVOb2RlQXQobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGluZGV4LCB2aWV3KSB7XG4gICAgICAgIGxldCBjaGlsZCA9IHRoaXMudG9wLmNoaWxkcmVuW2luZGV4XTtcbiAgICAgICAgaWYgKGNoaWxkLmRpcnR5ID09IE5PREVfRElSVFkgJiYgY2hpbGQuZG9tID09IGNoaWxkLmNvbnRlbnRET00pXG4gICAgICAgICAgICBjaGlsZC5kaXJ0eSA9IENPTlRFTlRfRElSVFk7XG4gICAgICAgIGlmICghY2hpbGQudXBkYXRlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCBpbmRleCk7XG4gICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZpbmRJbmRleFdpdGhDaGlsZChkb21Ob2RlKSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBkb21Ob2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICBpZiAocGFyZW50ID09IHRoaXMudG9wLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgICAgICBsZXQgZGVzYyA9IGRvbU5vZGUucG1WaWV3RGVzYztcbiAgICAgICAgICAgICAgICBpZiAoZGVzYylcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaW5kZXg7IGkgPCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudG9wLmNoaWxkcmVuW2ldID09IGRlc2MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb21Ob2RlID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRyeSB0byB1cGRhdGUgdGhlIG5leHQgbm9kZSwgaWYgYW55LCB0byB0aGUgZ2l2ZW4gZGF0YS4gQ2hlY2tzXG4gICAgLy8gcHJlLW1hdGNoZXMgdG8gYXZvaWQgb3ZlcndyaXRpbmcgbm9kZXMgdGhhdCBjb3VsZCBzdGlsbCBiZSB1c2VkLlxuICAgIHVwZGF0ZU5leHROb2RlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBpbmRleCwgcG9zKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmluZGV4OyBpIDwgdGhpcy50b3AuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy50b3AuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAobmV4dCBpbnN0YW5jZW9mIE5vZGVWaWV3RGVzYykge1xuICAgICAgICAgICAgICAgIGxldCBwcmVNYXRjaCA9IHRoaXMucHJlTWF0Y2gubWF0Y2hlZC5nZXQobmV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKHByZU1hdGNoICE9IG51bGwgJiYgcHJlTWF0Y2ggIT0gaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dERPTSA9IG5leHQuZG9tLCB1cGRhdGVkO1xuICAgICAgICAgICAgICAgIC8vIENhbid0IHVwZGF0ZSBpZiBuZXh0RE9NIGlzIG9yIGNvbnRhaW5zIHRoaXMubG9jaywgZXhjZXB0IGlmXG4gICAgICAgICAgICAgICAgLy8gaXQncyBhIHRleHQgbm9kZSB3aG9zZSBjb250ZW50IGFscmVhZHkgbWF0Y2hlcyB0aGUgbmV3IHRleHRcbiAgICAgICAgICAgICAgICAvLyBhbmQgd2hvc2UgZGVjb3JhdGlvbnMgbWF0Y2ggdGhlIG5ldyBvbmVzLlxuICAgICAgICAgICAgICAgIGxldCBsb2NrZWQgPSB0aGlzLmlzTG9ja2VkKG5leHRET00pICYmXG4gICAgICAgICAgICAgICAgICAgICEobm9kZS5pc1RleHQgJiYgbmV4dC5ub2RlICYmIG5leHQubm9kZS5pc1RleHQgJiYgbmV4dC5ub2RlRE9NLm5vZGVWYWx1ZSA9PSBub2RlLnRleHQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQuZGlydHkgIT0gTk9ERV9ESVJUWSAmJiBzYW1lT3V0ZXJEZWNvKG91dGVyRGVjbywgbmV4dC5vdXRlckRlY28pKTtcbiAgICAgICAgICAgICAgICBpZiAoIWxvY2tlZCAmJiBuZXh0LnVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQuZG9tICE9IG5leHRET00pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghbG9ja2VkICYmICh1cGRhdGVkID0gdGhpcy5yZWNyZWF0ZVdyYXBwZXIobmV4dCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIHBvcykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveUJldHdlZW4odGhpcy5pbmRleCwgaSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9wLmNoaWxkcmVuW3RoaXMuaW5kZXhdID0gdXBkYXRlZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZWQuY29udGVudERPTSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZC5kaXJ0eSA9IENPTlRFTlRfRElSVFk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLnVwZGF0ZUNoaWxkcmVuKHZpZXcsIHBvcyArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZC5kaXJ0eSA9IE5PVF9ESVJUWTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIFdoZW4gYSBub2RlIHdpdGggY29udGVudCBpcyByZXBsYWNlZCBieSBhIGRpZmZlcmVudCBub2RlIHdpdGhcbiAgICAvLyBpZGVudGljYWwgY29udGVudCwgbW92ZSBvdmVyIGl0cyBjaGlsZHJlbi5cbiAgICByZWNyZWF0ZVdyYXBwZXIobmV4dCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIHBvcykge1xuICAgICAgICBpZiAobmV4dC5kaXJ0eSB8fCBub2RlLmlzQXRvbSB8fCAhbmV4dC5jaGlsZHJlbi5sZW5ndGggfHxcbiAgICAgICAgICAgICFuZXh0Lm5vZGUuY29udGVudC5lcShub2RlLmNvbnRlbnQpIHx8XG4gICAgICAgICAgICAhc2FtZU91dGVyRGVjbyhvdXRlckRlY28sIG5leHQub3V0ZXJEZWNvKSB8fCAhaW5uZXJEZWNvLmVxKG5leHQuaW5uZXJEZWNvKSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgd3JhcHBlciA9IE5vZGVWaWV3RGVzYy5jcmVhdGUodGhpcy50b3AsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpO1xuICAgICAgICBpZiAod3JhcHBlci5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICB3cmFwcGVyLmNoaWxkcmVuID0gbmV4dC5jaGlsZHJlbjtcbiAgICAgICAgICAgIG5leHQuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGNoIG9mIHdyYXBwZXIuY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgY2gucGFyZW50ID0gd3JhcHBlcjtcbiAgICAgICAgfVxuICAgICAgICBuZXh0LmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuICAgIC8vIEluc2VydCB0aGUgbm9kZSBhcyBhIG5ld2x5IGNyZWF0ZWQgbm9kZSBkZXNjLlxuICAgIGFkZE5vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIHBvcykge1xuICAgICAgICBsZXQgZGVzYyA9IE5vZGVWaWV3RGVzYy5jcmVhdGUodGhpcy50b3AsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpO1xuICAgICAgICBpZiAoZGVzYy5jb250ZW50RE9NKVxuICAgICAgICAgICAgZGVzYy51cGRhdGVDaGlsZHJlbih2aWV3LCBwb3MgKyAxKTtcbiAgICAgICAgdGhpcy50b3AuY2hpbGRyZW4uc3BsaWNlKHRoaXMuaW5kZXgrKywgMCwgZGVzYyk7XG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgfVxuICAgIHBsYWNlV2lkZ2V0KHdpZGdldCwgdmlldywgcG9zKSB7XG4gICAgICAgIGxldCBuZXh0ID0gdGhpcy5pbmRleCA8IHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aCA/IHRoaXMudG9wLmNoaWxkcmVuW3RoaXMuaW5kZXhdIDogbnVsbDtcbiAgICAgICAgaWYgKG5leHQgJiYgbmV4dC5tYXRjaGVzV2lkZ2V0KHdpZGdldCkgJiZcbiAgICAgICAgICAgICh3aWRnZXQgPT0gbmV4dC53aWRnZXQgfHwgIW5leHQud2lkZ2V0LnR5cGUudG9ET00ucGFyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBkZXNjID0gbmV3IFdpZGdldFZpZXdEZXNjKHRoaXMudG9wLCB3aWRnZXQsIHZpZXcsIHBvcyk7XG4gICAgICAgICAgICB0aGlzLnRvcC5jaGlsZHJlbi5zcGxpY2UodGhpcy5pbmRleCsrLCAwLCBkZXNjKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIGEgdGV4dGJsb2NrIGxvb2tzIGFuZCBiZWhhdmVzIGNvcnJlY3RseSBpblxuICAgIC8vIGNvbnRlbnRFZGl0YWJsZS5cbiAgICBhZGRUZXh0YmxvY2tIYWNrcygpIHtcbiAgICAgICAgbGV0IGxhc3RDaGlsZCA9IHRoaXMudG9wLmNoaWxkcmVuW3RoaXMuaW5kZXggLSAxXSwgcGFyZW50ID0gdGhpcy50b3A7XG4gICAgICAgIHdoaWxlIChsYXN0Q2hpbGQgaW5zdGFuY2VvZiBNYXJrVmlld0Rlc2MpIHtcbiAgICAgICAgICAgIHBhcmVudCA9IGxhc3RDaGlsZDtcbiAgICAgICAgICAgIGxhc3RDaGlsZCA9IHBhcmVudC5jaGlsZHJlbltwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsYXN0Q2hpbGQgfHwgLy8gRW1wdHkgdGV4dGJsb2NrXG4gICAgICAgICAgICAhKGxhc3RDaGlsZCBpbnN0YW5jZW9mIFRleHRWaWV3RGVzYykgfHxcbiAgICAgICAgICAgIC9cXG4kLy50ZXN0KGxhc3RDaGlsZC5ub2RlLnRleHQpIHx8XG4gICAgICAgICAgICAodGhpcy52aWV3LnJlcXVpcmVzR2Vja29IYWNrTm9kZSAmJiAvXFxzJC8udGVzdChsYXN0Q2hpbGQubm9kZS50ZXh0KSkpIHtcbiAgICAgICAgICAgIC8vIEF2b2lkIGJ1Z3MgaW4gU2FmYXJpJ3MgY3Vyc29yIGRyYXdpbmcgKCMxMTY1KSBhbmQgQ2hyb21lJ3MgbW91c2Ugc2VsZWN0aW9uICgjMTE1MilcbiAgICAgICAgICAgIGlmICgoc2FmYXJpIHx8IGNocm9tZSkgJiYgbGFzdENoaWxkICYmIGxhc3RDaGlsZC5kb20uY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEhhY2tOb2RlKFwiSU1HXCIsIHBhcmVudCk7XG4gICAgICAgICAgICB0aGlzLmFkZEhhY2tOb2RlKFwiQlJcIiwgdGhpcy50b3ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEhhY2tOb2RlKG5vZGVOYW1lLCBwYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudCA9PSB0aGlzLnRvcCAmJiB0aGlzLmluZGV4IDwgcGFyZW50LmNoaWxkcmVuLmxlbmd0aCAmJiBwYXJlbnQuY2hpbGRyZW5bdGhpcy5pbmRleF0ubWF0Y2hlc0hhY2sobm9kZU5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChub2RlTmFtZSk7XG4gICAgICAgICAgICBpZiAobm9kZU5hbWUgPT0gXCJJTUdcIikge1xuICAgICAgICAgICAgICAgIGRvbS5jbGFzc05hbWUgPSBcIlByb3NlTWlycm9yLXNlcGFyYXRvclwiO1xuICAgICAgICAgICAgICAgIGRvbS5hbHQgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGVOYW1lID09IFwiQlJcIilcbiAgICAgICAgICAgICAgICBkb20uY2xhc3NOYW1lID0gXCJQcm9zZU1pcnJvci10cmFpbGluZ0JyZWFrXCI7XG4gICAgICAgICAgICBsZXQgaGFjayA9IG5ldyBUcmFpbGluZ0hhY2tWaWV3RGVzYyh0aGlzLnRvcCwgW10sIGRvbSwgbnVsbCk7XG4gICAgICAgICAgICBpZiAocGFyZW50ICE9IHRoaXMudG9wKVxuICAgICAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKGhhY2spO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5zcGxpY2UodGhpcy5pbmRleCsrLCAwLCBoYWNrKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNMb2NrZWQobm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NrICYmIChub2RlID09IHRoaXMubG9jayB8fCBub2RlLm5vZGVUeXBlID09IDEgJiYgbm9kZS5jb250YWlucyh0aGlzLmxvY2sucGFyZW50Tm9kZSkpO1xuICAgIH1cbn1cbi8vIEl0ZXJhdGUgZnJvbSB0aGUgZW5kIG9mIHRoZSBmcmFnbWVudCBhbmQgYXJyYXkgb2YgZGVzY3MgdG8gZmluZFxuLy8gZGlyZWN0bHkgbWF0Y2hpbmcgb25lcywgaW4gb3JkZXIgdG8gYXZvaWQgb3ZlcmVhZ2VybHkgcmV1c2luZyB0aG9zZVxuLy8gZm9yIG90aGVyIG5vZGVzLlxuZnVuY3Rpb24gcHJlTWF0Y2goZnJhZywgcGFyZW50RGVzYykge1xuICAgIGxldCBjdXJEZXNjID0gcGFyZW50RGVzYywgZGVzY0kgPSBjdXJEZXNjLmNoaWxkcmVuLmxlbmd0aDtcbiAgICBsZXQgZkkgPSBmcmFnLmNoaWxkQ291bnQsIG1hdGNoZWQgPSBuZXcgTWFwLCBtYXRjaGVzID0gW107XG4gICAgb3V0ZXI6IHdoaWxlIChmSSA+IDApIHtcbiAgICAgICAgbGV0IGRlc2M7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmIChkZXNjSSkge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gY3VyRGVzYy5jaGlsZHJlbltkZXNjSSAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgTWFya1ZpZXdEZXNjKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ckRlc2MgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBkZXNjSSA9IG5leHQuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzYyA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NJLS07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1ckRlc2MgPT0gcGFyZW50RGVzYykge1xuICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVzY0kgPSBjdXJEZXNjLnBhcmVudC5jaGlsZHJlbi5pbmRleE9mKGN1ckRlc2MpO1xuICAgICAgICAgICAgICAgIGN1ckRlc2MgPSBjdXJEZXNjLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbm9kZSA9IGRlc2Mubm9kZTtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChub2RlICE9IGZyYWcuY2hpbGQoZkkgLSAxKSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAtLWZJO1xuICAgICAgICBtYXRjaGVkLnNldChkZXNjLCBmSSk7XG4gICAgICAgIG1hdGNoZXMucHVzaChkZXNjKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgaW5kZXg6IGZJLCBtYXRjaGVkLCBtYXRjaGVzOiBtYXRjaGVzLnJldmVyc2UoKSB9O1xufVxuZnVuY3Rpb24gY29tcGFyZVNpZGUoYSwgYikge1xuICAgIHJldHVybiBhLnR5cGUuc2lkZSAtIGIudHlwZS5zaWRlO1xufVxuLy8gVGhpcyBmdW5jdGlvbiBhYnN0cmFjdHMgaXRlcmF0aW5nIG92ZXIgdGhlIG5vZGVzIGFuZCBkZWNvcmF0aW9ucyBpblxuLy8gYSBmcmFnbWVudC4gQ2FsbHMgYG9uTm9kZWAgZm9yIGVhY2ggbm9kZSwgd2l0aCBpdHMgbG9jYWwgYW5kIGNoaWxkXG4vLyBkZWNvcmF0aW9ucy4gU3BsaXRzIHRleHQgbm9kZXMgd2hlbiB0aGVyZSBpcyBhIGRlY29yYXRpb24gc3RhcnRpbmdcbi8vIG9yIGVuZGluZyBpbnNpZGUgb2YgdGhlbS4gQ2FsbHMgYG9uV2lkZ2V0YCBmb3IgZWFjaCB3aWRnZXQuXG5mdW5jdGlvbiBpdGVyRGVjbyhwYXJlbnQsIGRlY28sIG9uV2lkZ2V0LCBvbk5vZGUpIHtcbiAgICBsZXQgbG9jYWxzID0gZGVjby5sb2NhbHMocGFyZW50KSwgb2Zmc2V0ID0gMDtcbiAgICAvLyBTaW1wbGUsIGNoZWFwIHZhcmlhbnQgZm9yIHdoZW4gdGhlcmUgYXJlIG5vIGxvY2FsIGRlY29yYXRpb25zXG4gICAgaWYgKGxvY2Fscy5sZW5ndGggPT0gMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmVudC5jaGlsZENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHBhcmVudC5jaGlsZChpKTtcbiAgICAgICAgICAgIG9uTm9kZShjaGlsZCwgbG9jYWxzLCBkZWNvLmZvckNoaWxkKG9mZnNldCwgY2hpbGQpLCBpKTtcbiAgICAgICAgICAgIG9mZnNldCArPSBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBkZWNvSW5kZXggPSAwLCBhY3RpdmUgPSBbXSwgcmVzdE5vZGUgPSBudWxsO1xuICAgIGZvciAobGV0IHBhcmVudEluZGV4ID0gMDs7KSB7XG4gICAgICAgIGxldCB3aWRnZXQsIHdpZGdldHM7XG4gICAgICAgIHdoaWxlIChkZWNvSW5kZXggPCBsb2NhbHMubGVuZ3RoICYmIGxvY2Fsc1tkZWNvSW5kZXhdLnRvID09IG9mZnNldCkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBsb2NhbHNbZGVjb0luZGV4KytdO1xuICAgICAgICAgICAgaWYgKG5leHQud2lkZ2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF3aWRnZXQpXG4gICAgICAgICAgICAgICAgICAgIHdpZGdldCA9IG5leHQ7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAod2lkZ2V0cyB8fCAod2lkZ2V0cyA9IFt3aWRnZXRdKSkucHVzaChuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod2lkZ2V0KSB7XG4gICAgICAgICAgICBpZiAod2lkZ2V0cykge1xuICAgICAgICAgICAgICAgIHdpZGdldHMuc29ydChjb21wYXJlU2lkZSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aWRnZXRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBvbldpZGdldCh3aWRnZXRzW2ldLCBwYXJlbnRJbmRleCwgISFyZXN0Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvbldpZGdldCh3aWRnZXQsIHBhcmVudEluZGV4LCAhIXJlc3ROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hpbGQsIGluZGV4O1xuICAgICAgICBpZiAocmVzdE5vZGUpIHtcbiAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgICAgICBjaGlsZCA9IHJlc3ROb2RlO1xuICAgICAgICAgICAgcmVzdE5vZGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcmVudEluZGV4IDwgcGFyZW50LmNoaWxkQ291bnQpIHtcbiAgICAgICAgICAgIGluZGV4ID0gcGFyZW50SW5kZXg7XG4gICAgICAgICAgICBjaGlsZCA9IHBhcmVudC5jaGlsZChwYXJlbnRJbmRleCsrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWN0aXZlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKGFjdGl2ZVtpXS50byA8PSBvZmZzZXQpXG4gICAgICAgICAgICAgICAgYWN0aXZlLnNwbGljZShpLS0sIDEpO1xuICAgICAgICB3aGlsZSAoZGVjb0luZGV4IDwgbG9jYWxzLmxlbmd0aCAmJiBsb2NhbHNbZGVjb0luZGV4XS5mcm9tIDw9IG9mZnNldCAmJiBsb2NhbHNbZGVjb0luZGV4XS50byA+IG9mZnNldClcbiAgICAgICAgICAgIGFjdGl2ZS5wdXNoKGxvY2Fsc1tkZWNvSW5kZXgrK10pO1xuICAgICAgICBsZXQgZW5kID0gb2Zmc2V0ICsgY2hpbGQubm9kZVNpemU7XG4gICAgICAgIGlmIChjaGlsZC5pc1RleHQpIHtcbiAgICAgICAgICAgIGxldCBjdXRBdCA9IGVuZDtcbiAgICAgICAgICAgIGlmIChkZWNvSW5kZXggPCBsb2NhbHMubGVuZ3RoICYmIGxvY2Fsc1tkZWNvSW5kZXhdLmZyb20gPCBjdXRBdClcbiAgICAgICAgICAgICAgICBjdXRBdCA9IGxvY2Fsc1tkZWNvSW5kZXhdLmZyb207XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdGl2ZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlW2ldLnRvIDwgY3V0QXQpXG4gICAgICAgICAgICAgICAgICAgIGN1dEF0ID0gYWN0aXZlW2ldLnRvO1xuICAgICAgICAgICAgaWYgKGN1dEF0IDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgcmVzdE5vZGUgPSBjaGlsZC5jdXQoY3V0QXQgLSBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGQuY3V0KDAsIGN1dEF0IC0gb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBlbmQgPSBjdXRBdDtcbiAgICAgICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKGRlY29JbmRleCA8IGxvY2Fscy5sZW5ndGggJiYgbG9jYWxzW2RlY29JbmRleF0udG8gPCBlbmQpXG4gICAgICAgICAgICAgICAgZGVjb0luZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG91dGVyRGVjbyA9IGNoaWxkLmlzSW5saW5lICYmICFjaGlsZC5pc0xlYWYgPyBhY3RpdmUuZmlsdGVyKGQgPT4gIWQuaW5saW5lKSA6IGFjdGl2ZS5zbGljZSgpO1xuICAgICAgICBvbk5vZGUoY2hpbGQsIG91dGVyRGVjbywgZGVjby5mb3JDaGlsZChvZmZzZXQsIGNoaWxkKSwgaW5kZXgpO1xuICAgICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgfVxufVxuLy8gTGlzdCBtYXJrZXJzIGluIE1vYmlsZSBTYWZhcmkgd2lsbCBteXN0ZXJpb3VzbHkgZGlzYXBwZWFyXG4vLyBzb21ldGltZXMuIFRoaXMgd29ya3MgYXJvdW5kIHRoYXQuXG5mdW5jdGlvbiBpb3NIYWNrcyhkb20pIHtcbiAgICBpZiAoZG9tLm5vZGVOYW1lID09IFwiVUxcIiB8fCBkb20ubm9kZU5hbWUgPT0gXCJPTFwiKSB7XG4gICAgICAgIGxldCBvbGRDU1MgPSBkb20uc3R5bGUuY3NzVGV4dDtcbiAgICAgICAgZG9tLnN0eWxlLmNzc1RleHQgPSBvbGRDU1MgKyBcIjsgbGlzdC1zdHlsZTogc3F1YXJlICFpbXBvcnRhbnRcIjtcbiAgICAgICAgd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9tKS5saXN0U3R5bGU7XG4gICAgICAgIGRvbS5zdHlsZS5jc3NUZXh0ID0gb2xkQ1NTO1xuICAgIH1cbn1cbi8vIEZpbmQgYSBwaWVjZSBvZiB0ZXh0IGluIGFuIGlubGluZSBmcmFnbWVudCwgb3ZlcmxhcHBpbmcgZnJvbS10b1xuZnVuY3Rpb24gZmluZFRleHRJbkZyYWdtZW50KGZyYWcsIHRleHQsIGZyb20sIHRvKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IGkgPCBmcmFnLmNoaWxkQ291bnQgJiYgcG9zIDw9IHRvOykge1xuICAgICAgICBsZXQgY2hpbGQgPSBmcmFnLmNoaWxkKGkrKyksIGNoaWxkU3RhcnQgPSBwb3M7XG4gICAgICAgIHBvcyArPSBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgaWYgKCFjaGlsZC5pc1RleHQpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGV0IHN0ciA9IGNoaWxkLnRleHQ7XG4gICAgICAgIHdoaWxlIChpIDwgZnJhZy5jaGlsZENvdW50KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGZyYWcuY2hpbGQoaSsrKTtcbiAgICAgICAgICAgIHBvcyArPSBuZXh0Lm5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKCFuZXh0LmlzVGV4dClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN0ciArPSBuZXh0LnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA+PSBmcm9tKSB7XG4gICAgICAgICAgICBpZiAocG9zID49IHRvICYmIHN0ci5zbGljZSh0byAtIHRleHQubGVuZ3RoIC0gY2hpbGRTdGFydCwgdG8gLSBjaGlsZFN0YXJ0KSA9PSB0ZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0byAtIHRleHQubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gY2hpbGRTdGFydCA8IHRvID8gc3RyLmxhc3RJbmRleE9mKHRleHQsIHRvIC0gY2hpbGRTdGFydCAtIDEpIDogLTE7XG4gICAgICAgICAgICBpZiAoZm91bmQgPj0gMCAmJiBmb3VuZCArIHRleHQubGVuZ3RoICsgY2hpbGRTdGFydCA+PSBmcm9tKVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZFN0YXJ0ICsgZm91bmQ7XG4gICAgICAgICAgICBpZiAoZnJvbSA9PSB0byAmJiBzdHIubGVuZ3RoID49ICh0byArIHRleHQubGVuZ3RoKSAtIGNoaWxkU3RhcnQgJiZcbiAgICAgICAgICAgICAgICBzdHIuc2xpY2UodG8gLSBjaGlsZFN0YXJ0LCB0byAtIGNoaWxkU3RhcnQgKyB0ZXh0Lmxlbmd0aCkgPT0gdGV4dClcbiAgICAgICAgICAgICAgICByZXR1cm4gdG87XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuLy8gUmVwbGFjZSByYW5nZSBmcm9tLXRvIGluIGFuIGFycmF5IG9mIHZpZXcgZGVzY3Mgd2l0aCByZXBsYWNlbWVudFxuLy8gKG1heSBiZSBudWxsIHRvIGp1c3QgZGVsZXRlKS4gVGhpcyBnb2VzIHZlcnkgbXVjaCBhZ2FpbnN0IHRoZSBncmFpblxuLy8gb2YgdGhlIHJlc3Qgb2YgdGhpcyBjb2RlLCB3aGljaCB0ZW5kcyB0byBjcmVhdGUgbm9kZXMgd2l0aCB0aGVcbi8vIHJpZ2h0IHNoYXBlIGluIG9uZSBnbywgcmF0aGVyIHRoYW4gbWVzc2luZyB3aXRoIHRoZW0gYWZ0ZXJcbi8vIGNyZWF0aW9uLCBidXQgaXMgbmVjZXNzYXJ5IGluIHRoZSBjb21wb3NpdGlvbiBoYWNrLlxuZnVuY3Rpb24gcmVwbGFjZU5vZGVzKG5vZGVzLCBmcm9tLCB0bywgdmlldywgcmVwbGFjZW1lbnQpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIG9mZiA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgY2hpbGQgPSBub2Rlc1tpXSwgc3RhcnQgPSBvZmYsIGVuZCA9IG9mZiArPSBjaGlsZC5zaXplO1xuICAgICAgICBpZiAoc3RhcnQgPj0gdG8gfHwgZW5kIDw9IGZyb20pIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzdGFydCA8IGZyb20pXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGQuc2xpY2UoMCwgZnJvbSAtIHN0YXJ0LCB2aWV3KSk7XG4gICAgICAgICAgICBpZiAocmVwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChyZXBsYWNlbWVudCk7XG4gICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kID4gdG8pXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGQuc2xpY2UodG8gLSBzdGFydCwgY2hpbGQuc2l6ZSwgdmlldykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbkZyb21ET00odmlldywgb3JpZ2luID0gbnVsbCkge1xuICAgIGxldCBkb21TZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCksIGRvYyA9IHZpZXcuc3RhdGUuZG9jO1xuICAgIGlmICghZG9tU2VsLmZvY3VzTm9kZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IG5lYXJlc3REZXNjID0gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGRvbVNlbC5mb2N1c05vZGUpLCBpbldpZGdldCA9IG5lYXJlc3REZXNjICYmIG5lYXJlc3REZXNjLnNpemUgPT0gMDtcbiAgICBsZXQgaGVhZCA9IHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKGRvbVNlbC5mb2N1c05vZGUsIGRvbVNlbC5mb2N1c09mZnNldCwgMSk7XG4gICAgaWYgKGhlYWQgPCAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgJGhlYWQgPSBkb2MucmVzb2x2ZShoZWFkKSwgYW5jaG9yLCBzZWxlY3Rpb247XG4gICAgaWYgKHNlbGVjdGlvbkNvbGxhcHNlZChkb21TZWwpKSB7XG4gICAgICAgIGFuY2hvciA9IGhlYWQ7XG4gICAgICAgIHdoaWxlIChuZWFyZXN0RGVzYyAmJiAhbmVhcmVzdERlc2Mubm9kZSlcbiAgICAgICAgICAgIG5lYXJlc3REZXNjID0gbmVhcmVzdERlc2MucGFyZW50O1xuICAgICAgICBsZXQgbmVhcmVzdERlc2NOb2RlID0gbmVhcmVzdERlc2Mubm9kZTtcbiAgICAgICAgaWYgKG5lYXJlc3REZXNjICYmIG5lYXJlc3REZXNjTm9kZS5pc0F0b20gJiYgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobmVhcmVzdERlc2NOb2RlKSAmJiBuZWFyZXN0RGVzYy5wYXJlbnRcbiAgICAgICAgICAgICYmICEobmVhcmVzdERlc2NOb2RlLmlzSW5saW5lICYmIGlzT25FZGdlKGRvbVNlbC5mb2N1c05vZGUsIGRvbVNlbC5mb2N1c09mZnNldCwgbmVhcmVzdERlc2MuZG9tKSkpIHtcbiAgICAgICAgICAgIGxldCBwb3MgPSBuZWFyZXN0RGVzYy5wb3NCZWZvcmU7XG4gICAgICAgICAgICBzZWxlY3Rpb24gPSBuZXcgTm9kZVNlbGVjdGlvbihoZWFkID09IHBvcyA/ICRoZWFkIDogZG9jLnJlc29sdmUocG9zKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChkb21TZWwgaW5zdGFuY2VvZiB2aWV3LmRvbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LlNlbGVjdGlvbiAmJiBkb21TZWwucmFuZ2VDb3VudCA+IDEpIHtcbiAgICAgICAgICAgIGxldCBtaW4gPSBoZWFkLCBtYXggPSBoZWFkO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkb21TZWwucmFuZ2VDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gZG9tU2VsLmdldFJhbmdlQXQoaSk7XG4gICAgICAgICAgICAgICAgbWluID0gTWF0aC5taW4obWluLCB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQsIDEpKTtcbiAgICAgICAgICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0LCAtMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1pbiA8IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBbYW5jaG9yLCBoZWFkXSA9IG1heCA9PSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5hbmNob3IgPyBbbWF4LCBtaW5dIDogW21pbiwgbWF4XTtcbiAgICAgICAgICAgICRoZWFkID0gZG9jLnJlc29sdmUoaGVhZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhbmNob3IgPSB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFuY2hvciA8IDApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0ICRhbmNob3IgPSBkb2MucmVzb2x2ZShhbmNob3IpO1xuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICAgIGxldCBiaWFzID0gb3JpZ2luID09IFwicG9pbnRlclwiIHx8ICh2aWV3LnN0YXRlLnNlbGVjdGlvbi5oZWFkIDwgJGhlYWQucG9zICYmICFpbldpZGdldCkgPyAxIDogLTE7XG4gICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbkJldHdlZW4odmlldywgJGFuY2hvciwgJGhlYWQsIGJpYXMpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0aW9uO1xufVxuZnVuY3Rpb24gZWRpdG9yT3duc1NlbGVjdGlvbih2aWV3KSB7XG4gICAgcmV0dXJuIHZpZXcuZWRpdGFibGUgPyB2aWV3Lmhhc0ZvY3VzKCkgOlxuICAgICAgICBoYXNTZWxlY3Rpb24odmlldykgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmNvbnRhaW5zKHZpZXcuZG9tKTtcbn1cbmZ1bmN0aW9uIHNlbGVjdGlvblRvRE9NKHZpZXcsIGZvcmNlID0gZmFsc2UpIHtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgc3luY05vZGVTZWxlY3Rpb24odmlldywgc2VsKTtcbiAgICBpZiAoIWVkaXRvck93bnNTZWxlY3Rpb24odmlldykpXG4gICAgICAgIHJldHVybjtcbiAgICAvLyBUaGUgZGVsYXllZCBkcmFnIHNlbGVjdGlvbiBjYXVzZXMgaXNzdWVzIHdpdGggQ2VsbCBTZWxlY3Rpb25zXG4gICAgLy8gaW4gU2FmYXJpLiBBbmQgdGhlIGRyYWcgc2VsZWN0aW9uIGRlbGF5IGlzIHRvIHdvcmthcm9uZCBpc3N1ZXNcbiAgICAvLyB3aGljaCBvbmx5IHByZXNlbnQgaW4gQ2hyb21lLlxuICAgIGlmICghZm9yY2UgJiYgdmlldy5pbnB1dC5tb3VzZURvd24gJiYgdmlldy5pbnB1dC5tb3VzZURvd24uYWxsb3dEZWZhdWx0ICYmIGNocm9tZSkge1xuICAgICAgICBsZXQgZG9tU2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpLCBjdXJTZWwgPSB2aWV3LmRvbU9ic2VydmVyLmN1cnJlbnRTZWxlY3Rpb247XG4gICAgICAgIGlmIChkb21TZWwuYW5jaG9yTm9kZSAmJiBjdXJTZWwuYW5jaG9yTm9kZSAmJlxuICAgICAgICAgICAgaXNFcXVpdmFsZW50UG9zaXRpb24oZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQsIGN1clNlbC5hbmNob3JOb2RlLCBjdXJTZWwuYW5jaG9yT2Zmc2V0KSkge1xuICAgICAgICAgICAgdmlldy5pbnB1dC5tb3VzZURvd24uZGVsYXllZFNlbGVjdGlvblN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgdmlldy5kb21PYnNlcnZlci5zZXRDdXJTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aWV3LmRvbU9ic2VydmVyLmRpc2Nvbm5lY3RTZWxlY3Rpb24oKTtcbiAgICBpZiAodmlldy5jdXJzb3JXcmFwcGVyKSB7XG4gICAgICAgIHNlbGVjdEN1cnNvcldyYXBwZXIodmlldyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgeyBhbmNob3IsIGhlYWQgfSA9IHNlbCwgcmVzZXRFZGl0YWJsZUZyb20sIHJlc2V0RWRpdGFibGVUbztcbiAgICAgICAgaWYgKGJyb2tlblNlbGVjdEJldHdlZW5VbmVkaXRhYmxlICYmICEoc2VsIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIGlmICghc2VsLiRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgICAgIHJlc2V0RWRpdGFibGVGcm9tID0gdGVtcG9yYXJpbHlFZGl0YWJsZU5lYXIodmlldywgc2VsLmZyb20pO1xuICAgICAgICAgICAgaWYgKCFzZWwuZW1wdHkgJiYgIXNlbC4kZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudClcbiAgICAgICAgICAgICAgICByZXNldEVkaXRhYmxlVG8gPSB0ZW1wb3JhcmlseUVkaXRhYmxlTmVhcih2aWV3LCBzZWwudG8pO1xuICAgICAgICB9XG4gICAgICAgIHZpZXcuZG9jVmlldy5zZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkLCB2aWV3LCBmb3JjZSk7XG4gICAgICAgIGlmIChicm9rZW5TZWxlY3RCZXR3ZWVuVW5lZGl0YWJsZSkge1xuICAgICAgICAgICAgaWYgKHJlc2V0RWRpdGFibGVGcm9tKVxuICAgICAgICAgICAgICAgIHJlc2V0RWRpdGFibGUocmVzZXRFZGl0YWJsZUZyb20pO1xuICAgICAgICAgICAgaWYgKHJlc2V0RWRpdGFibGVUbylcbiAgICAgICAgICAgICAgICByZXNldEVkaXRhYmxlKHJlc2V0RWRpdGFibGVUbyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbC52aXNpYmxlKSB7XG4gICAgICAgICAgICB2aWV3LmRvbS5jbGFzc0xpc3QucmVtb3ZlKFwiUHJvc2VNaXJyb3ItaGlkZXNlbGVjdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZpZXcuZG9tLmNsYXNzTGlzdC5hZGQoXCJQcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uXCIpO1xuICAgICAgICAgICAgaWYgKFwib25zZWxlY3Rpb25jaGFuZ2VcIiBpbiBkb2N1bWVudClcbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzc09uU2VsZWN0aW9uQ2hhbmdlKHZpZXcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc2V0Q3VyU2VsZWN0aW9uKCk7XG4gICAgdmlldy5kb21PYnNlcnZlci5jb25uZWN0U2VsZWN0aW9uKCk7XG59XG4vLyBLbHVkZ2UgdG8gd29yayBhcm91bmQgV2Via2l0IG5vdCBhbGxvd2luZyBhIHNlbGVjdGlvbiB0byBzdGFydC9lbmRcbi8vIGJldHdlZW4gbm9uLWVkaXRhYmxlIGJsb2NrIG5vZGVzLiBXZSBicmllZmx5IG1ha2Ugc29tZXRoaW5nXG4vLyBlZGl0YWJsZSwgc2V0IHRoZSBzZWxlY3Rpb24sIHRoZW4gc2V0IGl0IHVuZWRpdGFibGUgYWdhaW4uXG5jb25zdCBicm9rZW5TZWxlY3RCZXR3ZWVuVW5lZGl0YWJsZSA9IHNhZmFyaSB8fCBjaHJvbWUgJiYgY2hyb21lX3ZlcnNpb24gPCA2MztcbmZ1bmN0aW9uIHRlbXBvcmFyaWx5RWRpdGFibGVOZWFyKHZpZXcsIHBvcykge1xuICAgIGxldCB7IG5vZGUsIG9mZnNldCB9ID0gdmlldy5kb2NWaWV3LmRvbUZyb21Qb3MocG9zLCAwKTtcbiAgICBsZXQgYWZ0ZXIgPSBvZmZzZXQgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoID8gbm9kZS5jaGlsZE5vZGVzW29mZnNldF0gOiBudWxsO1xuICAgIGxldCBiZWZvcmUgPSBvZmZzZXQgPyBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV0gOiBudWxsO1xuICAgIGlmIChzYWZhcmkgJiYgYWZ0ZXIgJiYgYWZ0ZXIuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgcmV0dXJuIHNldEVkaXRhYmxlKGFmdGVyKTtcbiAgICBpZiAoKCFhZnRlciB8fCBhZnRlci5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKSAmJlxuICAgICAgICAoIWJlZm9yZSB8fCBiZWZvcmUuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIikpIHtcbiAgICAgICAgaWYgKGFmdGVyKVxuICAgICAgICAgICAgcmV0dXJuIHNldEVkaXRhYmxlKGFmdGVyKTtcbiAgICAgICAgZWxzZSBpZiAoYmVmb3JlKVxuICAgICAgICAgICAgcmV0dXJuIHNldEVkaXRhYmxlKGJlZm9yZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0RWRpdGFibGUoZWxlbWVudCkge1xuICAgIGVsZW1lbnQuY29udGVudEVkaXRhYmxlID0gXCJ0cnVlXCI7XG4gICAgaWYgKHNhZmFyaSAmJiBlbGVtZW50LmRyYWdnYWJsZSkge1xuICAgICAgICBlbGVtZW50LmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgICBlbGVtZW50Lndhc0RyYWdnYWJsZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xufVxuZnVuY3Rpb24gcmVzZXRFZGl0YWJsZShlbGVtZW50KSB7XG4gICAgZWxlbWVudC5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCI7XG4gICAgaWYgKGVsZW1lbnQud2FzRHJhZ2dhYmxlKSB7XG4gICAgICAgIGVsZW1lbnQuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgICAgZWxlbWVudC53YXNEcmFnZ2FibGUgPSBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzT25TZWxlY3Rpb25DaGFuZ2Uodmlldykge1xuICAgIGxldCBkb2MgPSB2aWV3LmRvbS5vd25lckRvY3VtZW50O1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHZpZXcuaW5wdXQuaGlkZVNlbGVjdGlvbkd1YXJkKTtcbiAgICBsZXQgZG9tU2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgIGxldCBub2RlID0gZG9tU2VsLmFuY2hvck5vZGUsIG9mZnNldCA9IGRvbVNlbC5hbmNob3JPZmZzZXQ7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdmlldy5pbnB1dC5oaWRlU2VsZWN0aW9uR3VhcmQgPSAoKSA9PiB7XG4gICAgICAgIGlmIChkb21TZWwuYW5jaG9yTm9kZSAhPSBub2RlIHx8IGRvbVNlbC5hbmNob3JPZmZzZXQgIT0gb2Zmc2V0KSB7XG4gICAgICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB2aWV3LmlucHV0LmhpZGVTZWxlY3Rpb25HdWFyZCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWVkaXRvck93bnNTZWxlY3Rpb24odmlldykgfHwgdmlldy5zdGF0ZS5zZWxlY3Rpb24udmlzaWJsZSlcbiAgICAgICAgICAgICAgICAgICAgdmlldy5kb20uY2xhc3NMaXN0LnJlbW92ZShcIlByb3NlTWlycm9yLWhpZGVzZWxlY3Rpb25cIik7XG4gICAgICAgICAgICB9LCAyMCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHNlbGVjdEN1cnNvcldyYXBwZXIodmlldykge1xuICAgIGxldCBkb21TZWwgPSB2aWV3LmRvbVNlbGVjdGlvbigpO1xuICAgIGlmICghZG9tU2VsKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IG5vZGUgPSB2aWV3LmN1cnNvcldyYXBwZXIuZG9tLCBpbWcgPSBub2RlLm5vZGVOYW1lID09IFwiSU1HXCI7XG4gICAgaWYgKGltZylcbiAgICAgICAgZG9tU2VsLmNvbGxhcHNlKG5vZGUucGFyZW50Tm9kZSwgZG9tSW5kZXgobm9kZSkgKyAxKTtcbiAgICBlbHNlXG4gICAgICAgIGRvbVNlbC5jb2xsYXBzZShub2RlLCAwKTtcbiAgICAvLyBLbHVkZ2UgdG8ga2lsbCAnY29udHJvbCBzZWxlY3Rpb24nIGluIElFMTEgd2hlbiBzZWxlY3RpbmcgYW5cbiAgICAvLyBpbnZpc2libGUgY3Vyc29yIHdyYXBwZXIsIHNpbmNlIHRoYXQgd291bGQgcmVzdWx0IGluIHRob3NlIHdlaXJkXG4gICAgLy8gcmVzaXplIGhhbmRsZXMgYW5kIGEgc2VsZWN0aW9uIHRoYXQgY29uc2lkZXJzIHRoZSBhYnNvbHV0ZWx5XG4gICAgLy8gcG9zaXRpb25lZCB3cmFwcGVyLCByYXRoZXIgdGhhbiB0aGUgcm9vdCBlZGl0YWJsZSBub2RlLCB0aGVcbiAgICAvLyBmb2N1c2VkIGVsZW1lbnQuXG4gICAgaWYgKCFpbWcgJiYgIXZpZXcuc3RhdGUuc2VsZWN0aW9uLnZpc2libGUgJiYgaWUgJiYgaWVfdmVyc2lvbiA8PSAxMSkge1xuICAgICAgICBub2RlLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgbm9kZS5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN5bmNOb2RlU2VsZWN0aW9uKHZpZXcsIHNlbCkge1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKSB7XG4gICAgICAgIGxldCBkZXNjID0gdmlldy5kb2NWaWV3LmRlc2NBdChzZWwuZnJvbSk7XG4gICAgICAgIGlmIChkZXNjICE9IHZpZXcubGFzdFNlbGVjdGVkVmlld0Rlc2MpIHtcbiAgICAgICAgICAgIGNsZWFyTm9kZVNlbGVjdGlvbih2aWV3KTtcbiAgICAgICAgICAgIGlmIChkZXNjKVxuICAgICAgICAgICAgICAgIGRlc2Muc2VsZWN0Tm9kZSgpO1xuICAgICAgICAgICAgdmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYyA9IGRlc2M7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNsZWFyTm9kZVNlbGVjdGlvbih2aWV3KTtcbiAgICB9XG59XG4vLyBDbGVhciBhbGwgRE9NIHN0YXRlZnVsbmVzcyBvZiB0aGUgbGFzdCBub2RlIHNlbGVjdGlvbi5cbmZ1bmN0aW9uIGNsZWFyTm9kZVNlbGVjdGlvbih2aWV3KSB7XG4gICAgaWYgKHZpZXcubGFzdFNlbGVjdGVkVmlld0Rlc2MpIHtcbiAgICAgICAgaWYgKHZpZXcubGFzdFNlbGVjdGVkVmlld0Rlc2MucGFyZW50KVxuICAgICAgICAgICAgdmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYy5kZXNlbGVjdE5vZGUoKTtcbiAgICAgICAgdmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYyA9IHVuZGVmaW5lZDtcbiAgICB9XG59XG5mdW5jdGlvbiBzZWxlY3Rpb25CZXR3ZWVuKHZpZXcsICRhbmNob3IsICRoZWFkLCBiaWFzKSB7XG4gICAgcmV0dXJuIHZpZXcuc29tZVByb3AoXCJjcmVhdGVTZWxlY3Rpb25CZXR3ZWVuXCIsIGYgPT4gZih2aWV3LCAkYW5jaG9yLCAkaGVhZCkpXG4gICAgICAgIHx8IFRleHRTZWxlY3Rpb24uYmV0d2VlbigkYW5jaG9yLCAkaGVhZCwgYmlhcyk7XG59XG5mdW5jdGlvbiBoYXNGb2N1c0FuZFNlbGVjdGlvbih2aWV3KSB7XG4gICAgaWYgKHZpZXcuZWRpdGFibGUgJiYgIXZpZXcuaGFzRm9jdXMoKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBoYXNTZWxlY3Rpb24odmlldyk7XG59XG5mdW5jdGlvbiBoYXNTZWxlY3Rpb24odmlldykge1xuICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgaWYgKCFzZWwuYW5jaG9yTm9kZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIC8vIEZpcmVmb3ggd2lsbCByYWlzZSAncGVybWlzc2lvbiBkZW5pZWQnIGVycm9ycyB3aGVuIGFjY2Vzc2luZ1xuICAgICAgICAvLyBwcm9wZXJ0aWVzIG9mIGBzZWwuYW5jaG9yTm9kZWAgd2hlbiBpdCdzIGluIGEgZ2VuZXJhdGVkIENTU1xuICAgICAgICAvLyBlbGVtZW50LlxuICAgICAgICByZXR1cm4gdmlldy5kb20uY29udGFpbnMoc2VsLmFuY2hvck5vZGUubm9kZVR5cGUgPT0gMyA/IHNlbC5hbmNob3JOb2RlLnBhcmVudE5vZGUgOiBzZWwuYW5jaG9yTm9kZSkgJiZcbiAgICAgICAgICAgICh2aWV3LmVkaXRhYmxlIHx8IHZpZXcuZG9tLmNvbnRhaW5zKHNlbC5mb2N1c05vZGUubm9kZVR5cGUgPT0gMyA/IHNlbC5mb2N1c05vZGUucGFyZW50Tm9kZSA6IHNlbC5mb2N1c05vZGUpKTtcbiAgICB9XG4gICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFuY2hvckluUmlnaHRQbGFjZSh2aWV3KSB7XG4gICAgbGV0IGFuY2hvckRPTSA9IHZpZXcuZG9jVmlldy5kb21Gcm9tUG9zKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmFuY2hvciwgMCk7XG4gICAgbGV0IGRvbVNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICByZXR1cm4gaXNFcXVpdmFsZW50UG9zaXRpb24oYW5jaG9yRE9NLm5vZGUsIGFuY2hvckRPTS5vZmZzZXQsIGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0KTtcbn1cblxuZnVuY3Rpb24gbW92ZVNlbGVjdGlvbkJsb2NrKHN0YXRlLCBkaXIpIHtcbiAgICBsZXQgeyAkYW5jaG9yLCAkaGVhZCB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCAkc2lkZSA9IGRpciA+IDAgPyAkYW5jaG9yLm1heCgkaGVhZCkgOiAkYW5jaG9yLm1pbigkaGVhZCk7XG4gICAgbGV0ICRzdGFydCA9ICEkc2lkZS5wYXJlbnQuaW5saW5lQ29udGVudCA/ICRzaWRlIDogJHNpZGUuZGVwdGggPyBzdGF0ZS5kb2MucmVzb2x2ZShkaXIgPiAwID8gJHNpZGUuYWZ0ZXIoKSA6ICRzaWRlLmJlZm9yZSgpKSA6IG51bGw7XG4gICAgcmV0dXJuICRzdGFydCAmJiBTZWxlY3Rpb24uZmluZEZyb20oJHN0YXJ0LCBkaXIpO1xufVxuZnVuY3Rpb24gYXBwbHkodmlldywgc2VsKSB7XG4gICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWwpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gc2VsZWN0SG9yaXpvbnRhbGx5KHZpZXcsIGRpciwgbW9kcykge1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoc2VsIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikge1xuICAgICAgICBpZiAobW9kcy5pbmRleE9mKFwic1wiKSA+IC0xKSB7XG4gICAgICAgICAgICBsZXQgeyAkaGVhZCB9ID0gc2VsLCBub2RlID0gJGhlYWQudGV4dE9mZnNldCA/IG51bGwgOiBkaXIgPCAwID8gJGhlYWQubm9kZUJlZm9yZSA6ICRoZWFkLm5vZGVBZnRlcjtcbiAgICAgICAgICAgIGlmICghbm9kZSB8fCBub2RlLmlzVGV4dCB8fCAhbm9kZS5pc0xlYWYpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGV0ICRuZXdIZWFkID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZSgkaGVhZC5wb3MgKyBub2RlLm5vZGVTaXplICogKGRpciA8IDAgPyAtMSA6IDEpKTtcbiAgICAgICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXcgVGV4dFNlbGVjdGlvbihzZWwuJGFuY2hvciwgJG5ld0hlYWQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghc2VsLmVtcHR5KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmlldy5lbmRPZlRleHRibG9jayhkaXIgPiAwID8gXCJmb3J3YXJkXCIgOiBcImJhY2t3YXJkXCIpKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IG1vdmVTZWxlY3Rpb25CbG9jayh2aWV3LnN0YXRlLCBkaXIpO1xuICAgICAgICAgICAgaWYgKG5leHQgJiYgKG5leHQgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwbHkodmlldywgbmV4dCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIShtYWMgJiYgbW9kcy5pbmRleE9mKFwibVwiKSA+IC0xKSkge1xuICAgICAgICAgICAgbGV0ICRoZWFkID0gc2VsLiRoZWFkLCBub2RlID0gJGhlYWQudGV4dE9mZnNldCA/IG51bGwgOiBkaXIgPCAwID8gJGhlYWQubm9kZUJlZm9yZSA6ICRoZWFkLm5vZGVBZnRlciwgZGVzYztcbiAgICAgICAgICAgIGlmICghbm9kZSB8fCBub2RlLmlzVGV4dClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBsZXQgbm9kZVBvcyA9IGRpciA8IDAgPyAkaGVhZC5wb3MgLSBub2RlLm5vZGVTaXplIDogJGhlYWQucG9zO1xuICAgICAgICAgICAgaWYgKCEobm9kZS5pc0F0b20gfHwgKGRlc2MgPSB2aWV3LmRvY1ZpZXcuZGVzY0F0KG5vZGVQb3MpKSAmJiAhZGVzYy5jb250ZW50RE9NKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwbHkodmlldywgbmV3IE5vZGVTZWxlY3Rpb24oZGlyIDwgMCA/IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoJGhlYWQucG9zIC0gbm9kZS5ub2RlU2l6ZSkgOiAkaGVhZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAod2Via2l0KSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hyb21lIGFuZCBTYWZhcmkgd2lsbCBpbnRyb2R1Y2UgZXh0cmEgcG9pbnRsZXNzIGN1cnNvclxuICAgICAgICAgICAgICAgIC8vIHBvc2l0aW9ucyBhcm91bmQgaW5saW5lIHVuZWRpdGFibGUgbm9kZXMsIHNvIHdlIGhhdmUgdG9cbiAgICAgICAgICAgICAgICAvLyB0YWtlIG92ZXIgYW5kIG1vdmUgdGhlIGN1cnNvciBwYXN0IHRoZW0gKCM5MzcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5ldyBUZXh0U2VsZWN0aW9uKHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoZGlyIDwgMCA/IG5vZGVQb3MgOiBub2RlUG9zICsgbm9kZS5ub2RlU2l6ZSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uICYmIHNlbC5ub2RlLmlzSW5saW5lKSB7XG4gICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXcgVGV4dFNlbGVjdGlvbihkaXIgPiAwID8gc2VsLiR0byA6IHNlbC4kZnJvbSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IG5leHQgPSBtb3ZlU2VsZWN0aW9uQmxvY2sodmlldy5zdGF0ZSwgZGlyKTtcbiAgICAgICAgaWYgKG5leHQpXG4gICAgICAgICAgICByZXR1cm4gYXBwbHkodmlldywgbmV4dCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBub2RlTGVuKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PSAzID8gbm9kZS5ub2RlVmFsdWUubGVuZ3RoIDogbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGlzSWdub3JhYmxlKGRvbSwgZGlyKSB7XG4gICAgbGV0IGRlc2MgPSBkb20ucG1WaWV3RGVzYztcbiAgICByZXR1cm4gZGVzYyAmJiBkZXNjLnNpemUgPT0gMCAmJiAoZGlyIDwgMCB8fCBkb20ubmV4dFNpYmxpbmcgfHwgZG9tLm5vZGVOYW1lICE9IFwiQlJcIik7XG59XG5mdW5jdGlvbiBza2lwSWdub3JlZE5vZGVzKHZpZXcsIGRpcikge1xuICAgIHJldHVybiBkaXIgPCAwID8gc2tpcElnbm9yZWROb2Rlc0JlZm9yZSh2aWV3KSA6IHNraXBJZ25vcmVkTm9kZXNBZnRlcih2aWV3KTtcbn1cbi8vIE1ha2Ugc3VyZSB0aGUgY3Vyc29yIGlzbid0IGRpcmVjdGx5IGFmdGVyIG9uZSBvciBtb3JlIGlnbm9yZWRcbi8vIG5vZGVzLCB3aGljaCB3aWxsIGNvbmZ1c2UgdGhlIGJyb3dzZXIncyBjdXJzb3IgbW90aW9uIGxvZ2ljLlxuZnVuY3Rpb24gc2tpcElnbm9yZWROb2Rlc0JlZm9yZSh2aWV3KSB7XG4gICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICBsZXQgbm9kZSA9IHNlbC5mb2N1c05vZGUsIG9mZnNldCA9IHNlbC5mb2N1c09mZnNldDtcbiAgICBpZiAoIW5vZGUpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgbW92ZU5vZGUsIG1vdmVPZmZzZXQsIGZvcmNlID0gZmFsc2U7XG4gICAgLy8gR2Vja28gd2lsbCBkbyBvZGQgdGhpbmdzIHdoZW4gdGhlIHNlbGVjdGlvbiBpcyBkaXJlY3RseSBpbiBmcm9udFxuICAgIC8vIG9mIGEgbm9uLWVkaXRhYmxlIG5vZGUsIHNvIGluIHRoYXQgY2FzZSwgbW92ZSBpdCBpbnRvIHRoZSBuZXh0XG4gICAgLy8gbm9kZSBpZiBwb3NzaWJsZS4gSXNzdWUgcHJvc2VtaXJyb3IvcHJvc2VtaXJyb3IjODMyLlxuICAgIGlmIChnZWNrbyAmJiBub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0IDwgbm9kZUxlbihub2RlKSAmJiBpc0lnbm9yYWJsZShub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XSwgLTEpKVxuICAgICAgICBmb3JjZSA9IHRydWU7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAob2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGJlZm9yZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNJZ25vcmFibGUoYmVmb3JlLCAtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZU5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICBtb3ZlT2Zmc2V0ID0gLS1vZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJlZm9yZS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBiZWZvcmU7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IG5vZGUubm9kZVZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Jsb2NrTm9kZShub2RlKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgd2hpbGUgKHByZXYgJiYgaXNJZ25vcmFibGUocHJldiwgLTEpKSB7XG4gICAgICAgICAgICAgICAgbW92ZU5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgbW92ZU9mZnNldCA9IGRvbUluZGV4KHByZXYpO1xuICAgICAgICAgICAgICAgIHByZXYgPSBwcmV2LnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcHJldikge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgPT0gdmlldy5kb20pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlID0gcHJldjtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBub2RlTGVuKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChmb3JjZSlcbiAgICAgICAgc2V0U2VsRm9jdXModmlldywgbm9kZSwgb2Zmc2V0KTtcbiAgICBlbHNlIGlmIChtb3ZlTm9kZSlcbiAgICAgICAgc2V0U2VsRm9jdXModmlldywgbW92ZU5vZGUsIG1vdmVPZmZzZXQpO1xufVxuLy8gTWFrZSBzdXJlIHRoZSBjdXJzb3IgaXNuJ3QgZGlyZWN0bHkgYmVmb3JlIG9uZSBvciBtb3JlIGlnbm9yZWRcbi8vIG5vZGVzLlxuZnVuY3Rpb24gc2tpcElnbm9yZWROb2Rlc0FmdGVyKHZpZXcpIHtcbiAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgIGxldCBub2RlID0gc2VsLmZvY3VzTm9kZSwgb2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0O1xuICAgIGlmICghbm9kZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBsZW4gPSBub2RlTGVuKG5vZGUpO1xuICAgIGxldCBtb3ZlTm9kZSwgbW92ZU9mZnNldDtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChvZmZzZXQgPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDEpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgIGlmIChpc0lnbm9yYWJsZShhZnRlciwgMSkpIHtcbiAgICAgICAgICAgICAgICBtb3ZlTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgbW92ZU9mZnNldCA9ICsrb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQmxvY2tOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgIHdoaWxlIChuZXh0ICYmIGlzSWdub3JhYmxlKG5leHQsIDEpKSB7XG4gICAgICAgICAgICAgICAgbW92ZU5vZGUgPSBuZXh0LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgbW92ZU9mZnNldCA9IGRvbUluZGV4KG5leHQpICsgMTtcbiAgICAgICAgICAgICAgICBuZXh0ID0gbmV4dC5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmV4dCkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgPT0gdmlldy5kb20pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IGxlbiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgIGxlbiA9IG5vZGVMZW4obm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1vdmVOb2RlKVxuICAgICAgICBzZXRTZWxGb2N1cyh2aWV3LCBtb3ZlTm9kZSwgbW92ZU9mZnNldCk7XG59XG5mdW5jdGlvbiBpc0Jsb2NrTm9kZShkb20pIHtcbiAgICBsZXQgZGVzYyA9IGRvbS5wbVZpZXdEZXNjO1xuICAgIHJldHVybiBkZXNjICYmIGRlc2Mubm9kZSAmJiBkZXNjLm5vZGUuaXNCbG9jaztcbn1cbmZ1bmN0aW9uIHRleHROb2RlQWZ0ZXIobm9kZSwgb2Zmc2V0KSB7XG4gICAgd2hpbGUgKG5vZGUgJiYgb2Zmc2V0ID09IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggJiYgIWhhc0Jsb2NrRGVzYyhub2RlKSkge1xuICAgICAgICBvZmZzZXQgPSBkb21JbmRleChub2RlKSArIDE7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHdoaWxlIChub2RlICYmIG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IG5leHQgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgaWYgKG5leHQubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICBpZiAobmV4dC5ub2RlVHlwZSA9PSAxICYmIG5leHQuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG59XG5mdW5jdGlvbiB0ZXh0Tm9kZUJlZm9yZShub2RlLCBvZmZzZXQpIHtcbiAgICB3aGlsZSAobm9kZSAmJiAhb2Zmc2V0ICYmICFoYXNCbG9ja0Rlc2Mobm9kZSkpIHtcbiAgICAgICAgb2Zmc2V0ID0gZG9tSW5kZXgobm9kZSk7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHdoaWxlIChub2RlICYmIG9mZnNldCkge1xuICAgICAgICBsZXQgbmV4dCA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgaWYgKG5leHQubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICBpZiAobmV4dC5ub2RlVHlwZSA9PSAxICYmIG5leHQuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgb2Zmc2V0ID0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRTZWxGb2N1cyh2aWV3LCBub2RlLCBvZmZzZXQpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAzKSB7XG4gICAgICAgIGxldCBiZWZvcmUsIGFmdGVyO1xuICAgICAgICBpZiAoYWZ0ZXIgPSB0ZXh0Tm9kZUFmdGVyKG5vZGUsIG9mZnNldCkpIHtcbiAgICAgICAgICAgIG5vZGUgPSBhZnRlcjtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmVmb3JlID0gdGV4dE5vZGVCZWZvcmUobm9kZSwgb2Zmc2V0KSkge1xuICAgICAgICAgICAgbm9kZSA9IGJlZm9yZTtcbiAgICAgICAgICAgIG9mZnNldCA9IGJlZm9yZS5ub2RlVmFsdWUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvbigpO1xuICAgIGlmICghc2VsKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHNlbGVjdGlvbkNvbGxhcHNlZChzZWwpKSB7XG4gICAgICAgIGxldCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIHJhbmdlLnNldEVuZChub2RlLCBvZmZzZXQpO1xuICAgICAgICByYW5nZS5zZXRTdGFydChub2RlLCBvZmZzZXQpO1xuICAgICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgIHNlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlbC5leHRlbmQpIHtcbiAgICAgICAgc2VsLmV4dGVuZChub2RlLCBvZmZzZXQpO1xuICAgIH1cbiAgICB2aWV3LmRvbU9ic2VydmVyLnNldEN1clNlbGVjdGlvbigpO1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3O1xuICAgIC8vIElmIG5vIHN0YXRlIHVwZGF0ZSBlbmRzIHVwIGhhcHBlbmluZywgcmVzZXQgdGhlIHNlbGVjdGlvbi5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHZpZXcuc3RhdGUgPT0gc3RhdGUpXG4gICAgICAgICAgICBzZWxlY3Rpb25Ub0RPTSh2aWV3KTtcbiAgICB9LCA1MCk7XG59XG5mdW5jdGlvbiBmaW5kRGlyZWN0aW9uKHZpZXcsIHBvcykge1xuICAgIGxldCAkcG9zID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShwb3MpO1xuICAgIGlmICghKGNocm9tZSB8fCB3aW5kb3dzKSAmJiAkcG9zLnBhcmVudC5pbmxpbmVDb250ZW50KSB7XG4gICAgICAgIGxldCBjb29yZHMgPSB2aWV3LmNvb3Jkc0F0UG9zKHBvcyk7XG4gICAgICAgIGlmIChwb3MgPiAkcG9zLnN0YXJ0KCkpIHtcbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSB2aWV3LmNvb3Jkc0F0UG9zKHBvcyAtIDEpO1xuICAgICAgICAgICAgbGV0IG1pZCA9IChiZWZvcmUudG9wICsgYmVmb3JlLmJvdHRvbSkgLyAyO1xuICAgICAgICAgICAgaWYgKG1pZCA+IGNvb3Jkcy50b3AgJiYgbWlkIDwgY29vcmRzLmJvdHRvbSAmJiBNYXRoLmFicyhiZWZvcmUubGVmdCAtIGNvb3Jkcy5sZWZ0KSA+IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJlZm9yZS5sZWZ0IDwgY29vcmRzLmxlZnQgPyBcImx0clwiIDogXCJydGxcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zIDwgJHBvcy5lbmQoKSkge1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gdmlldy5jb29yZHNBdFBvcyhwb3MgKyAxKTtcbiAgICAgICAgICAgIGxldCBtaWQgPSAoYWZ0ZXIudG9wICsgYWZ0ZXIuYm90dG9tKSAvIDI7XG4gICAgICAgICAgICBpZiAobWlkID4gY29vcmRzLnRvcCAmJiBtaWQgPCBjb29yZHMuYm90dG9tICYmIE1hdGguYWJzKGFmdGVyLmxlZnQgLSBjb29yZHMubGVmdCkgPiAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBhZnRlci5sZWZ0ID4gY29vcmRzLmxlZnQgPyBcImx0clwiIDogXCJydGxcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgY29tcHV0ZWQgPSBnZXRDb21wdXRlZFN0eWxlKHZpZXcuZG9tKS5kaXJlY3Rpb247XG4gICAgcmV0dXJuIGNvbXB1dGVkID09IFwicnRsXCIgPyBcInJ0bFwiIDogXCJsdHJcIjtcbn1cbi8vIENoZWNrIHdoZXRoZXIgdmVydGljYWwgc2VsZWN0aW9uIG1vdGlvbiB3b3VsZCBpbnZvbHZlIG5vZGVcbi8vIHNlbGVjdGlvbnMuIElmIHNvLCBhcHBseSBpdCAoaWYgbm90LCB0aGUgcmVzdWx0IGlzIGxlZnQgdG8gdGhlXG4vLyBicm93c2VyKVxuZnVuY3Rpb24gc2VsZWN0VmVydGljYWxseSh2aWV3LCBkaXIsIG1vZHMpIHtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24gJiYgIXNlbC5lbXB0eSB8fCBtb2RzLmluZGV4T2YoXCJzXCIpID4gLTEpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAobWFjICYmIG1vZHMuaW5kZXhPZihcIm1cIikgPiAtMSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHNlbDtcbiAgICBpZiAoISRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50IHx8IHZpZXcuZW5kT2ZUZXh0YmxvY2soZGlyIDwgMCA/IFwidXBcIiA6IFwiZG93blwiKSkge1xuICAgICAgICBsZXQgbmV4dCA9IG1vdmVTZWxlY3Rpb25CbG9jayh2aWV3LnN0YXRlLCBkaXIpO1xuICAgICAgICBpZiAobmV4dCAmJiAobmV4dCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24pKVxuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5leHQpO1xuICAgIH1cbiAgICBpZiAoISRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50KSB7XG4gICAgICAgIGxldCBzaWRlID0gZGlyIDwgMCA/ICRmcm9tIDogJHRvO1xuICAgICAgICBsZXQgYmV5b25kID0gc2VsIGluc3RhbmNlb2YgQWxsU2VsZWN0aW9uID8gU2VsZWN0aW9uLm5lYXIoc2lkZSwgZGlyKSA6IFNlbGVjdGlvbi5maW5kRnJvbShzaWRlLCBkaXIpO1xuICAgICAgICByZXR1cm4gYmV5b25kID8gYXBwbHkodmlldywgYmV5b25kKSA6IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzdG9wTmF0aXZlSG9yaXpvbnRhbERlbGV0ZSh2aWV3LCBkaXIpIHtcbiAgICBpZiAoISh2aWV3LnN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgeyAkaGVhZCwgJGFuY2hvciwgZW1wdHkgfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGhlYWQuc2FtZVBhcmVudCgkYW5jaG9yKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKCFlbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh2aWV3LmVuZE9mVGV4dGJsb2NrKGRpciA+IDAgPyBcImZvcndhcmRcIiA6IFwiYmFja3dhcmRcIikpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCBuZXh0Tm9kZSA9ICEkaGVhZC50ZXh0T2Zmc2V0ICYmIChkaXIgPCAwID8gJGhlYWQubm9kZUJlZm9yZSA6ICRoZWFkLm5vZGVBZnRlcik7XG4gICAgaWYgKG5leHROb2RlICYmICFuZXh0Tm9kZS5pc1RleHQpIHtcbiAgICAgICAgbGV0IHRyID0gdmlldy5zdGF0ZS50cjtcbiAgICAgICAgaWYgKGRpciA8IDApXG4gICAgICAgICAgICB0ci5kZWxldGUoJGhlYWQucG9zIC0gbmV4dE5vZGUubm9kZVNpemUsICRoZWFkLnBvcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRyLmRlbGV0ZSgkaGVhZC5wb3MsICRoZWFkLnBvcyArIG5leHROb2RlLm5vZGVTaXplKTtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzd2l0Y2hFZGl0YWJsZSh2aWV3LCBub2RlLCBzdGF0ZSkge1xuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgIG5vZGUuY29udGVudEVkaXRhYmxlID0gc3RhdGU7XG4gICAgdmlldy5kb21PYnNlcnZlci5zdGFydCgpO1xufVxuLy8gSXNzdWUgIzg2NyAvICMxMDkwIC8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9OTAzODIxXG4vLyBJbiB3aGljaCBTYWZhcmkgKGFuZCBhdCBzb21lIHBvaW50IGluIHRoZSBwYXN0LCBDaHJvbWUpIGRvZXMgcmVhbGx5XG4vLyB3cm9uZyB0aGluZ3Mgd2hlbiB0aGUgZG93biBhcnJvdyBpcyBwcmVzc2VkIHdoZW4gdGhlIGN1cnNvciBpc1xuLy8gZGlyZWN0bHkgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrIGFuZCBoYXMgYW4gdW5lZGl0YWJsZSBub2RlXG4vLyBhZnRlciBpdFxuZnVuY3Rpb24gc2FmYXJpRG93bkFycm93QnVnKHZpZXcpIHtcbiAgICBpZiAoIXNhZmFyaSB8fCB2aWV3LnN0YXRlLnNlbGVjdGlvbi4kaGVhZC5wYXJlbnRPZmZzZXQgPiAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHsgZm9jdXNOb2RlLCBmb2N1c09mZnNldCB9ID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgIGlmIChmb2N1c05vZGUgJiYgZm9jdXNOb2RlLm5vZGVUeXBlID09IDEgJiYgZm9jdXNPZmZzZXQgPT0gMCAmJlxuICAgICAgICBmb2N1c05vZGUuZmlyc3RDaGlsZCAmJiBmb2N1c05vZGUuZmlyc3RDaGlsZC5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IGZvY3VzTm9kZS5maXJzdENoaWxkO1xuICAgICAgICBzd2l0Y2hFZGl0YWJsZSh2aWV3LCBjaGlsZCwgXCJ0cnVlXCIpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHN3aXRjaEVkaXRhYmxlKHZpZXcsIGNoaWxkLCBcImZhbHNlXCIpLCAyMCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIEEgYmFja2Ryb3Aga2V5IG1hcHBpbmcgdXNlZCB0byBtYWtlIHN1cmUgd2UgYWx3YXlzIHN1cHByZXNzIGtleXNcbi8vIHRoYXQgaGF2ZSBhIGRhbmdlcm91cyBkZWZhdWx0IGVmZmVjdCwgZXZlbiBpZiB0aGUgY29tbWFuZHMgdGhleSBhcmVcbi8vIGJvdW5kIHRvIHJldHVybiBmYWxzZSwgYW5kIHRvIG1ha2Ugc3VyZSB0aGF0IGN1cnNvci1tb3Rpb24ga2V5c1xuLy8gZmluZCBhIGN1cnNvciAoYXMgb3Bwb3NlZCB0byBhIG5vZGUgc2VsZWN0aW9uKSB3aGVuIHByZXNzZWQuIEZvclxuLy8gY3Vyc29yLW1vdGlvbiBrZXlzLCB0aGUgY29kZSBpbiB0aGUgaGFuZGxlcnMgYWxzbyB0YWtlcyBjYXJlIG9mXG4vLyBibG9jayBzZWxlY3Rpb25zLlxuZnVuY3Rpb24gZ2V0TW9kcyhldmVudCkge1xuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIGlmIChldmVudC5jdHJsS2V5KVxuICAgICAgICByZXN1bHQgKz0gXCJjXCI7XG4gICAgaWYgKGV2ZW50Lm1ldGFLZXkpXG4gICAgICAgIHJlc3VsdCArPSBcIm1cIjtcbiAgICBpZiAoZXZlbnQuYWx0S2V5KVxuICAgICAgICByZXN1bHQgKz0gXCJhXCI7XG4gICAgaWYgKGV2ZW50LnNoaWZ0S2V5KVxuICAgICAgICByZXN1bHQgKz0gXCJzXCI7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNhcHR1cmVLZXlEb3duKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IGNvZGUgPSBldmVudC5rZXlDb2RlLCBtb2RzID0gZ2V0TW9kcyhldmVudCk7XG4gICAgaWYgKGNvZGUgPT0gOCB8fCAobWFjICYmIGNvZGUgPT0gNzIgJiYgbW9kcyA9PSBcImNcIikpIHsgLy8gQmFja3NwYWNlLCBDdHJsLWggb24gTWFjXG4gICAgICAgIHJldHVybiBzdG9wTmF0aXZlSG9yaXpvbnRhbERlbGV0ZSh2aWV3LCAtMSkgfHwgc2tpcElnbm9yZWROb2Rlcyh2aWV3LCAtMSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKChjb2RlID09IDQ2ICYmICFldmVudC5zaGlmdEtleSkgfHwgKG1hYyAmJiBjb2RlID09IDY4ICYmIG1vZHMgPT0gXCJjXCIpKSB7IC8vIERlbGV0ZSwgQ3RybC1kIG9uIE1hY1xuICAgICAgICByZXR1cm4gc3RvcE5hdGl2ZUhvcml6b250YWxEZWxldGUodmlldywgMSkgfHwgc2tpcElnbm9yZWROb2Rlcyh2aWV3LCAxKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZSA9PSAxMyB8fCBjb2RlID09IDI3KSB7IC8vIEVudGVyLCBFc2NcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGUgPT0gMzcgfHwgKG1hYyAmJiBjb2RlID09IDY2ICYmIG1vZHMgPT0gXCJjXCIpKSB7IC8vIExlZnQgYXJyb3csIEN0cmwtYiBvbiBNYWNcbiAgICAgICAgbGV0IGRpciA9IGNvZGUgPT0gMzcgPyAoZmluZERpcmVjdGlvbih2aWV3LCB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tKSA9PSBcImx0clwiID8gLTEgOiAxKSA6IC0xO1xuICAgICAgICByZXR1cm4gc2VsZWN0SG9yaXpvbnRhbGx5KHZpZXcsIGRpciwgbW9kcykgfHwgc2tpcElnbm9yZWROb2Rlcyh2aWV3LCBkaXIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlID09IDM5IHx8IChtYWMgJiYgY29kZSA9PSA3MCAmJiBtb2RzID09IFwiY1wiKSkgeyAvLyBSaWdodCBhcnJvdywgQ3RybC1mIG9uIE1hY1xuICAgICAgICBsZXQgZGlyID0gY29kZSA9PSAzOSA/IChmaW5kRGlyZWN0aW9uKHZpZXcsIHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20pID09IFwibHRyXCIgPyAxIDogLTEpIDogMTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdEhvcml6b250YWxseSh2aWV3LCBkaXIsIG1vZHMpIHx8IHNraXBJZ25vcmVkTm9kZXModmlldywgZGlyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZSA9PSAzOCB8fCAobWFjICYmIGNvZGUgPT0gODAgJiYgbW9kcyA9PSBcImNcIikpIHsgLy8gVXAgYXJyb3csIEN0cmwtcCBvbiBNYWNcbiAgICAgICAgcmV0dXJuIHNlbGVjdFZlcnRpY2FsbHkodmlldywgLTEsIG1vZHMpIHx8IHNraXBJZ25vcmVkTm9kZXModmlldywgLTEpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlID09IDQwIHx8IChtYWMgJiYgY29kZSA9PSA3OCAmJiBtb2RzID09IFwiY1wiKSkgeyAvLyBEb3duIGFycm93LCBDdHJsLW4gb24gTWFjXG4gICAgICAgIHJldHVybiBzYWZhcmlEb3duQXJyb3dCdWcodmlldykgfHwgc2VsZWN0VmVydGljYWxseSh2aWV3LCAxLCBtb2RzKSB8fCBza2lwSWdub3JlZE5vZGVzKHZpZXcsIDEpO1xuICAgIH1cbiAgICBlbHNlIGlmIChtb2RzID09IChtYWMgPyBcIm1cIiA6IFwiY1wiKSAmJlxuICAgICAgICAoY29kZSA9PSA2NiB8fCBjb2RlID09IDczIHx8IGNvZGUgPT0gODkgfHwgY29kZSA9PSA5MCkpIHsgLy8gTW9kLVtiaXl6XVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVGb3JDbGlwYm9hcmQodmlldywgc2xpY2UpIHtcbiAgICB2aWV3LnNvbWVQcm9wKFwidHJhbnNmb3JtQ29waWVkXCIsIGYgPT4geyBzbGljZSA9IGYoc2xpY2UsIHZpZXcpOyB9KTtcbiAgICBsZXQgY29udGV4dCA9IFtdLCB7IGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCB9ID0gc2xpY2U7XG4gICAgd2hpbGUgKG9wZW5TdGFydCA+IDEgJiYgb3BlbkVuZCA+IDEgJiYgY29udGVudC5jaGlsZENvdW50ID09IDEgJiYgY29udGVudC5maXJzdENoaWxkLmNoaWxkQ291bnQgPT0gMSkge1xuICAgICAgICBvcGVuU3RhcnQtLTtcbiAgICAgICAgb3BlbkVuZC0tO1xuICAgICAgICBsZXQgbm9kZSA9IGNvbnRlbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgY29udGV4dC5wdXNoKG5vZGUudHlwZS5uYW1lLCBub2RlLmF0dHJzICE9IG5vZGUudHlwZS5kZWZhdWx0QXR0cnMgPyBub2RlLmF0dHJzIDogbnVsbCk7XG4gICAgICAgIGNvbnRlbnQgPSBub2RlLmNvbnRlbnQ7XG4gICAgfVxuICAgIGxldCBzZXJpYWxpemVyID0gdmlldy5zb21lUHJvcChcImNsaXBib2FyZFNlcmlhbGl6ZXJcIikgfHwgRE9NU2VyaWFsaXplci5mcm9tU2NoZW1hKHZpZXcuc3RhdGUuc2NoZW1hKTtcbiAgICBsZXQgZG9jID0gZGV0YWNoZWREb2MoKSwgd3JhcCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHdyYXAuYXBwZW5kQ2hpbGQoc2VyaWFsaXplci5zZXJpYWxpemVGcmFnbWVudChjb250ZW50LCB7IGRvY3VtZW50OiBkb2MgfSkpO1xuICAgIGxldCBmaXJzdENoaWxkID0gd3JhcC5maXJzdENoaWxkLCBuZWVkc1dyYXAsIHdyYXBwZXJzID0gMDtcbiAgICB3aGlsZSAoZmlyc3RDaGlsZCAmJiBmaXJzdENoaWxkLm5vZGVUeXBlID09IDEgJiYgKG5lZWRzV3JhcCA9IHdyYXBNYXBbZmlyc3RDaGlsZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXSkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IG5lZWRzV3JhcC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHdyYXBwZXIgPSBkb2MuY3JlYXRlRWxlbWVudChuZWVkc1dyYXBbaV0pO1xuICAgICAgICAgICAgd2hpbGUgKHdyYXAuZmlyc3RDaGlsZClcbiAgICAgICAgICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHdyYXAuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB3cmFwLmFwcGVuZENoaWxkKHdyYXBwZXIpO1xuICAgICAgICAgICAgd3JhcHBlcnMrKztcbiAgICAgICAgfVxuICAgICAgICBmaXJzdENoaWxkID0gd3JhcC5maXJzdENoaWxkO1xuICAgIH1cbiAgICBpZiAoZmlyc3RDaGlsZCAmJiBmaXJzdENoaWxkLm5vZGVUeXBlID09IDEpXG4gICAgICAgIGZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKFwiZGF0YS1wbS1zbGljZVwiLCBgJHtvcGVuU3RhcnR9ICR7b3BlbkVuZH0ke3dyYXBwZXJzID8gYCAtJHt3cmFwcGVyc31gIDogXCJcIn0gJHtKU09OLnN0cmluZ2lmeShjb250ZXh0KX1gKTtcbiAgICBsZXQgdGV4dCA9IHZpZXcuc29tZVByb3AoXCJjbGlwYm9hcmRUZXh0U2VyaWFsaXplclwiLCBmID0+IGYoc2xpY2UsIHZpZXcpKSB8fFxuICAgICAgICBzbGljZS5jb250ZW50LnRleHRCZXR3ZWVuKDAsIHNsaWNlLmNvbnRlbnQuc2l6ZSwgXCJcXG5cXG5cIik7XG4gICAgcmV0dXJuIHsgZG9tOiB3cmFwLCB0ZXh0LCBzbGljZSB9O1xufVxuLy8gUmVhZCBhIHNsaWNlIG9mIGNvbnRlbnQgZnJvbSB0aGUgY2xpcGJvYXJkIChvciBkcm9wIGRhdGEpLlxuZnVuY3Rpb24gcGFyc2VGcm9tQ2xpcGJvYXJkKHZpZXcsIHRleHQsIGh0bWwsIHBsYWluVGV4dCwgJGNvbnRleHQpIHtcbiAgICBsZXQgaW5Db2RlID0gJGNvbnRleHQucGFyZW50LnR5cGUuc3BlYy5jb2RlO1xuICAgIGxldCBkb20sIHNsaWNlO1xuICAgIGlmICghaHRtbCAmJiAhdGV4dClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGFzVGV4dCA9ICEhdGV4dCAmJiAocGxhaW5UZXh0IHx8IGluQ29kZSB8fCAhaHRtbCk7XG4gICAgaWYgKGFzVGV4dCkge1xuICAgICAgICB2aWV3LnNvbWVQcm9wKFwidHJhbnNmb3JtUGFzdGVkVGV4dFwiLCBmID0+IHsgdGV4dCA9IGYodGV4dCwgaW5Db2RlIHx8IHBsYWluVGV4dCwgdmlldyk7IH0pO1xuICAgICAgICBpZiAoaW5Db2RlKSB7XG4gICAgICAgICAgICBzbGljZSA9IG5ldyBTbGljZShGcmFnbWVudC5mcm9tKHZpZXcuc3RhdGUuc2NoZW1hLnRleHQodGV4dC5yZXBsYWNlKC9cXHJcXG4/L2csIFwiXFxuXCIpKSksIDAsIDApO1xuICAgICAgICAgICAgdmlldy5zb21lUHJvcChcInRyYW5zZm9ybVBhc3RlZFwiLCBmID0+IHsgc2xpY2UgPSBmKHNsaWNlLCB2aWV3LCB0cnVlKTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gc2xpY2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcnNlZCA9IHZpZXcuc29tZVByb3AoXCJjbGlwYm9hcmRUZXh0UGFyc2VyXCIsIGYgPT4gZih0ZXh0LCAkY29udGV4dCwgcGxhaW5UZXh0LCB2aWV3KSk7XG4gICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgIHNsaWNlID0gcGFyc2VkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1hcmtzID0gJGNvbnRleHQubWFya3MoKTtcbiAgICAgICAgICAgIGxldCB7IHNjaGVtYSB9ID0gdmlldy5zdGF0ZSwgc2VyaWFsaXplciA9IERPTVNlcmlhbGl6ZXIuZnJvbVNjaGVtYShzY2hlbWEpO1xuICAgICAgICAgICAgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHRleHQuc3BsaXQoLyg/Olxcclxcbj98XFxuKSsvKS5mb3JFYWNoKGJsb2NrID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcCA9IGRvbS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKSk7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrKVxuICAgICAgICAgICAgICAgICAgICBwLmFwcGVuZENoaWxkKHNlcmlhbGl6ZXIuc2VyaWFsaXplTm9kZShzY2hlbWEudGV4dChibG9jaywgbWFya3MpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmlldy5zb21lUHJvcChcInRyYW5zZm9ybVBhc3RlZEhUTUxcIiwgZiA9PiB7IGh0bWwgPSBmKGh0bWwsIHZpZXcpOyB9KTtcbiAgICAgICAgZG9tID0gcmVhZEhUTUwoaHRtbCk7XG4gICAgICAgIGlmICh3ZWJraXQpXG4gICAgICAgICAgICByZXN0b3JlUmVwbGFjZWRTcGFjZXMoZG9tKTtcbiAgICB9XG4gICAgbGV0IGNvbnRleHROb2RlID0gZG9tICYmIGRvbS5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtcG0tc2xpY2VdXCIpO1xuICAgIGxldCBzbGljZURhdGEgPSBjb250ZXh0Tm9kZSAmJiAvXihcXGQrKSAoXFxkKykoPzogLShcXGQrKSk/ICguKikvLmV4ZWMoY29udGV4dE5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1wbS1zbGljZVwiKSB8fCBcIlwiKTtcbiAgICBpZiAoc2xpY2VEYXRhICYmIHNsaWNlRGF0YVszXSlcbiAgICAgICAgZm9yIChsZXQgaSA9ICtzbGljZURhdGFbM107IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IGRvbS5maXJzdENoaWxkO1xuICAgICAgICAgICAgd2hpbGUgKGNoaWxkICYmIGNoaWxkLm5vZGVUeXBlICE9IDEpXG4gICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICAgIGlmICghY2hpbGQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkb20gPSBjaGlsZDtcbiAgICAgICAgfVxuICAgIGlmICghc2xpY2UpIHtcbiAgICAgICAgbGV0IHBhcnNlciA9IHZpZXcuc29tZVByb3AoXCJjbGlwYm9hcmRQYXJzZXJcIikgfHwgdmlldy5zb21lUHJvcChcImRvbVBhcnNlclwiKSB8fCBET01QYXJzZXIuZnJvbVNjaGVtYSh2aWV3LnN0YXRlLnNjaGVtYSk7XG4gICAgICAgIHNsaWNlID0gcGFyc2VyLnBhcnNlU2xpY2UoZG9tLCB7XG4gICAgICAgICAgICBwcmVzZXJ2ZVdoaXRlc3BhY2U6ICEhKGFzVGV4dCB8fCBzbGljZURhdGEpLFxuICAgICAgICAgICAgY29udGV4dDogJGNvbnRleHQsXG4gICAgICAgICAgICBydWxlRnJvbU5vZGUoZG9tKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIkJSXCIgJiYgIWRvbS5uZXh0U2libGluZyAmJlxuICAgICAgICAgICAgICAgICAgICBkb20ucGFyZW50Tm9kZSAmJiAhaW5saW5lUGFyZW50cy50ZXN0KGRvbS5wYXJlbnROb2RlLm5vZGVOYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgaWdub3JlOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2xpY2VEYXRhKSB7XG4gICAgICAgIHNsaWNlID0gYWRkQ29udGV4dChjbG9zZVNsaWNlKHNsaWNlLCArc2xpY2VEYXRhWzFdLCArc2xpY2VEYXRhWzJdKSwgc2xpY2VEYXRhWzRdKTtcbiAgICB9XG4gICAgZWxzZSB7IC8vIEhUTUwgd2Fzbid0IGNyZWF0ZWQgYnkgUHJvc2VNaXJyb3IuIE1ha2Ugc3VyZSB0b3AtbGV2ZWwgc2libGluZ3MgYXJlIGNvaGVyZW50XG4gICAgICAgIHNsaWNlID0gU2xpY2UubWF4T3Blbihub3JtYWxpemVTaWJsaW5ncyhzbGljZS5jb250ZW50LCAkY29udGV4dCksIHRydWUpO1xuICAgICAgICBpZiAoc2xpY2Uub3BlblN0YXJ0IHx8IHNsaWNlLm9wZW5FbmQpIHtcbiAgICAgICAgICAgIGxldCBvcGVuU3RhcnQgPSAwLCBvcGVuRW5kID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IG5vZGUgPSBzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQ7IG9wZW5TdGFydCA8IHNsaWNlLm9wZW5TdGFydCAmJiAhbm9kZS50eXBlLnNwZWMuaXNvbGF0aW5nOyBvcGVuU3RhcnQrKywgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZCkgeyB9XG4gICAgICAgICAgICBmb3IgKGxldCBub2RlID0gc2xpY2UuY29udGVudC5sYXN0Q2hpbGQ7IG9wZW5FbmQgPCBzbGljZS5vcGVuRW5kICYmICFub2RlLnR5cGUuc3BlYy5pc29sYXRpbmc7IG9wZW5FbmQrKywgbm9kZSA9IG5vZGUubGFzdENoaWxkKSB7IH1cbiAgICAgICAgICAgIHNsaWNlID0gY2xvc2VTbGljZShzbGljZSwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aWV3LnNvbWVQcm9wKFwidHJhbnNmb3JtUGFzdGVkXCIsIGYgPT4geyBzbGljZSA9IGYoc2xpY2UsIHZpZXcsIGFzVGV4dCk7IH0pO1xuICAgIHJldHVybiBzbGljZTtcbn1cbmNvbnN0IGlubGluZVBhcmVudHMgPSAvXihhfGFiYnJ8YWNyb255bXxifGNpdGV8Y29kZXxkZWx8ZW18aXxpbnN8a2JkfGxhYmVsfG91dHB1dHxxfHJ1Ynl8c3xzYW1wfHNwYW58c3Ryb25nfHN1YnxzdXB8dGltZXx1fHR0fHZhcikkL2k7XG4vLyBUYWtlcyBhIHNsaWNlIHBhcnNlZCB3aXRoIHBhcnNlU2xpY2UsIHdoaWNoIG1lYW5zIHRoZXJlIGhhc24ndCBiZWVuXG4vLyBhbnkgY29udGVudC1leHByZXNzaW9uIGNoZWNraW5nIGRvbmUgb24gdGhlIHRvcCBub2RlcywgdHJpZXMgdG9cbi8vIGZpbmQgYSBwYXJlbnQgbm9kZSBpbiB0aGUgY3VycmVudCBjb250ZXh0IHRoYXQgbWlnaHQgZml0IHRoZSBub2Rlcyxcbi8vIGFuZCBpZiBzdWNjZXNzZnVsLCByZWJ1aWxkcyB0aGUgc2xpY2Ugc28gdGhhdCBpdCBmaXRzIGludG8gdGhhdCBwYXJlbnQuXG4vL1xuLy8gVGhpcyBhZGRyZXNzZXMgdGhlIHByb2JsZW0gdGhhdCBUcmFuc2Zvcm0ucmVwbGFjZSBleHBlY3RzIGFcbi8vIGNvaGVyZW50IHNsaWNlLCBhbmQgd2lsbCBmYWlsIHRvIHBsYWNlIGEgc2V0IG9mIHNpYmxpbmdzIHRoYXQgZG9uJ3Rcbi8vIGZpdCBhbnl3aGVyZSBpbiB0aGUgc2NoZW1hLlxuZnVuY3Rpb24gbm9ybWFsaXplU2libGluZ3MoZnJhZ21lbnQsICRjb250ZXh0KSB7XG4gICAgaWYgKGZyYWdtZW50LmNoaWxkQ291bnQgPCAyKVxuICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgZm9yIChsZXQgZCA9ICRjb250ZXh0LmRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgICAgICBsZXQgcGFyZW50ID0gJGNvbnRleHQubm9kZShkKTtcbiAgICAgICAgbGV0IG1hdGNoID0gcGFyZW50LmNvbnRlbnRNYXRjaEF0KCRjb250ZXh0LmluZGV4KGQpKTtcbiAgICAgICAgbGV0IGxhc3RXcmFwLCByZXN1bHQgPSBbXTtcbiAgICAgICAgZnJhZ21lbnQuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCB3cmFwID0gbWF0Y2guZmluZFdyYXBwaW5nKG5vZGUudHlwZSksIGluTGFzdDtcbiAgICAgICAgICAgIGlmICghd3JhcClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChpbkxhc3QgPSByZXN1bHQubGVuZ3RoICYmIGxhc3RXcmFwLmxlbmd0aCAmJiBhZGRUb1NpYmxpbmcod3JhcCwgbGFzdFdyYXAsIG5vZGUsIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0sIDApKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA9IGluTGFzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID0gY2xvc2VSaWdodChyZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdLCBsYXN0V3JhcC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGxldCB3cmFwcGVkID0gd2l0aFdyYXBwZXJzKG5vZGUsIHdyYXApO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHdyYXBwZWQpO1xuICAgICAgICAgICAgICAgIG1hdGNoID0gbWF0Y2gubWF0Y2hUeXBlKHdyYXBwZWQudHlwZSk7XG4gICAgICAgICAgICAgICAgbGFzdFdyYXAgPSB3cmFwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5mcm9tKHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudDtcbn1cbmZ1bmN0aW9uIHdpdGhXcmFwcGVycyhub2RlLCB3cmFwLCBmcm9tID0gMCkge1xuICAgIGZvciAobGV0IGkgPSB3cmFwLmxlbmd0aCAtIDE7IGkgPj0gZnJvbTsgaS0tKVxuICAgICAgICBub2RlID0gd3JhcFtpXS5jcmVhdGUobnVsbCwgRnJhZ21lbnQuZnJvbShub2RlKSk7XG4gICAgcmV0dXJuIG5vZGU7XG59XG4vLyBVc2VkIHRvIGdyb3VwIGFkamFjZW50IG5vZGVzIHdyYXBwZWQgaW4gc2ltaWxhciBwYXJlbnRzIGJ5XG4vLyBub3JtYWxpemVTaWJsaW5ncyBpbnRvIHRoZSBzYW1lIHBhcmVudCBub2RlXG5mdW5jdGlvbiBhZGRUb1NpYmxpbmcod3JhcCwgbGFzdFdyYXAsIG5vZGUsIHNpYmxpbmcsIGRlcHRoKSB7XG4gICAgaWYgKGRlcHRoIDwgd3JhcC5sZW5ndGggJiYgZGVwdGggPCBsYXN0V3JhcC5sZW5ndGggJiYgd3JhcFtkZXB0aF0gPT0gbGFzdFdyYXBbZGVwdGhdKSB7XG4gICAgICAgIGxldCBpbm5lciA9IGFkZFRvU2libGluZyh3cmFwLCBsYXN0V3JhcCwgbm9kZSwgc2libGluZy5sYXN0Q2hpbGQsIGRlcHRoICsgMSk7XG4gICAgICAgIGlmIChpbm5lcilcbiAgICAgICAgICAgIHJldHVybiBzaWJsaW5nLmNvcHkoc2libGluZy5jb250ZW50LnJlcGxhY2VDaGlsZChzaWJsaW5nLmNoaWxkQ291bnQgLSAxLCBpbm5lcikpO1xuICAgICAgICBsZXQgbWF0Y2ggPSBzaWJsaW5nLmNvbnRlbnRNYXRjaEF0KHNpYmxpbmcuY2hpbGRDb3VudCk7XG4gICAgICAgIGlmIChtYXRjaC5tYXRjaFR5cGUoZGVwdGggPT0gd3JhcC5sZW5ndGggLSAxID8gbm9kZS50eXBlIDogd3JhcFtkZXB0aCArIDFdKSlcbiAgICAgICAgICAgIHJldHVybiBzaWJsaW5nLmNvcHkoc2libGluZy5jb250ZW50LmFwcGVuZChGcmFnbWVudC5mcm9tKHdpdGhXcmFwcGVycyhub2RlLCB3cmFwLCBkZXB0aCArIDEpKSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsb3NlUmlnaHQobm9kZSwgZGVwdGgpIHtcbiAgICBpZiAoZGVwdGggPT0gMClcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgbGV0IGZyYWdtZW50ID0gbm9kZS5jb250ZW50LnJlcGxhY2VDaGlsZChub2RlLmNoaWxkQ291bnQgLSAxLCBjbG9zZVJpZ2h0KG5vZGUubGFzdENoaWxkLCBkZXB0aCAtIDEpKTtcbiAgICBsZXQgZmlsbCA9IG5vZGUuY29udGVudE1hdGNoQXQobm9kZS5jaGlsZENvdW50KS5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKTtcbiAgICByZXR1cm4gbm9kZS5jb3B5KGZyYWdtZW50LmFwcGVuZChmaWxsKSk7XG59XG5mdW5jdGlvbiBjbG9zZVJhbmdlKGZyYWdtZW50LCBzaWRlLCBmcm9tLCB0bywgZGVwdGgsIG9wZW5FbmQpIHtcbiAgICBsZXQgbm9kZSA9IHNpZGUgPCAwID8gZnJhZ21lbnQuZmlyc3RDaGlsZCA6IGZyYWdtZW50Lmxhc3RDaGlsZCwgaW5uZXIgPSBub2RlLmNvbnRlbnQ7XG4gICAgaWYgKGZyYWdtZW50LmNoaWxkQ291bnQgPiAxKVxuICAgICAgICBvcGVuRW5kID0gMDtcbiAgICBpZiAoZGVwdGggPCB0byAtIDEpXG4gICAgICAgIGlubmVyID0gY2xvc2VSYW5nZShpbm5lciwgc2lkZSwgZnJvbSwgdG8sIGRlcHRoICsgMSwgb3BlbkVuZCk7XG4gICAgaWYgKGRlcHRoID49IGZyb20pXG4gICAgICAgIGlubmVyID0gc2lkZSA8IDAgPyBub2RlLmNvbnRlbnRNYXRjaEF0KDApLmZpbGxCZWZvcmUoaW5uZXIsIG9wZW5FbmQgPD0gZGVwdGgpLmFwcGVuZChpbm5lcilcbiAgICAgICAgICAgIDogaW5uZXIuYXBwZW5kKG5vZGUuY29udGVudE1hdGNoQXQobm9kZS5jaGlsZENvdW50KS5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKSk7XG4gICAgcmV0dXJuIGZyYWdtZW50LnJlcGxhY2VDaGlsZChzaWRlIDwgMCA/IDAgOiBmcmFnbWVudC5jaGlsZENvdW50IC0gMSwgbm9kZS5jb3B5KGlubmVyKSk7XG59XG5mdW5jdGlvbiBjbG9zZVNsaWNlKHNsaWNlLCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICBpZiAob3BlblN0YXJ0IDwgc2xpY2Uub3BlblN0YXJ0KVxuICAgICAgICBzbGljZSA9IG5ldyBTbGljZShjbG9zZVJhbmdlKHNsaWNlLmNvbnRlbnQsIC0xLCBvcGVuU3RhcnQsIHNsaWNlLm9wZW5TdGFydCwgMCwgc2xpY2Uub3BlbkVuZCksIG9wZW5TdGFydCwgc2xpY2Uub3BlbkVuZCk7XG4gICAgaWYgKG9wZW5FbmQgPCBzbGljZS5vcGVuRW5kKVxuICAgICAgICBzbGljZSA9IG5ldyBTbGljZShjbG9zZVJhbmdlKHNsaWNlLmNvbnRlbnQsIDEsIG9wZW5FbmQsIHNsaWNlLm9wZW5FbmQsIDAsIDApLCBzbGljZS5vcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgIHJldHVybiBzbGljZTtcbn1cbi8vIFRyaWNrIGZyb20galF1ZXJ5IC0tIHNvbWUgZWxlbWVudHMgbXVzdCBiZSB3cmFwcGVkIGluIG90aGVyXG4vLyBlbGVtZW50cyBmb3IgaW5uZXJIVE1MIHRvIHdvcmsuIEkuZS4gaWYgeW91IGRvIGBkaXYuaW5uZXJIVE1MID1cbi8vIFwiPHRkPi4uPC90ZD5cImAgdGhlIHRhYmxlIGNlbGxzIGFyZSBpZ25vcmVkLlxuY29uc3Qgd3JhcE1hcCA9IHtcbiAgICB0aGVhZDogW1widGFibGVcIl0sXG4gICAgdGJvZHk6IFtcInRhYmxlXCJdLFxuICAgIHRmb290OiBbXCJ0YWJsZVwiXSxcbiAgICBjYXB0aW9uOiBbXCJ0YWJsZVwiXSxcbiAgICBjb2xncm91cDogW1widGFibGVcIl0sXG4gICAgY29sOiBbXCJ0YWJsZVwiLCBcImNvbGdyb3VwXCJdLFxuICAgIHRyOiBbXCJ0YWJsZVwiLCBcInRib2R5XCJdLFxuICAgIHRkOiBbXCJ0YWJsZVwiLCBcInRib2R5XCIsIFwidHJcIl0sXG4gICAgdGg6IFtcInRhYmxlXCIsIFwidGJvZHlcIiwgXCJ0clwiXVxufTtcbmxldCBfZGV0YWNoZWREb2MgPSBudWxsO1xuZnVuY3Rpb24gZGV0YWNoZWREb2MoKSB7XG4gICAgcmV0dXJuIF9kZXRhY2hlZERvYyB8fCAoX2RldGFjaGVkRG9jID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KFwidGl0bGVcIikpO1xufVxubGV0IF9wb2xpY3kgPSBudWxsO1xuZnVuY3Rpb24gbWF5YmVXcmFwVHJ1c3RlZChodG1sKSB7XG4gICAgbGV0IHRydXN0ZWRUeXBlcyA9IHdpbmRvdy50cnVzdGVkVHlwZXM7XG4gICAgaWYgKCF0cnVzdGVkVHlwZXMpXG4gICAgICAgIHJldHVybiBodG1sO1xuICAgIC8vIFdpdGggdGhlIHJlcXVpcmUtdHJ1c3RlZC10eXBlcy1mb3IgQ1NQLCBDaHJvbWUgd2lsbCBibG9ja1xuICAgIC8vIGlubmVySFRNTCwgZXZlbiBvbiBhIGRldGFjaGVkIGRvY3VtZW50LiBUaGlzIHdyYXBzIHRoZSBzdHJpbmcgaW5cbiAgICAvLyBhIHdheSB0aGF0IG1ha2VzIHRoZSBicm93c2VyIGFsbG93IHVzIHRvIHVzZSBpdHMgcGFyc2VyIGFnYWluLlxuICAgIGlmICghX3BvbGljeSlcbiAgICAgICAgX3BvbGljeSA9IHRydXN0ZWRUeXBlcy5kZWZhdWx0UG9saWN5IHx8IHRydXN0ZWRUeXBlcy5jcmVhdGVQb2xpY3koXCJQcm9zZU1pcnJvckNsaXBib2FyZFwiLCB7IGNyZWF0ZUhUTUw6IChzKSA9PiBzIH0pO1xuICAgIHJldHVybiBfcG9saWN5LmNyZWF0ZUhUTUwoaHRtbCk7XG59XG5mdW5jdGlvbiByZWFkSFRNTChodG1sKSB7XG4gICAgbGV0IG1ldGFzID0gL14oXFxzKjxtZXRhIFtePl0qPikqLy5leGVjKGh0bWwpO1xuICAgIGlmIChtZXRhcylcbiAgICAgICAgaHRtbCA9IGh0bWwuc2xpY2UobWV0YXNbMF0ubGVuZ3RoKTtcbiAgICBsZXQgZWx0ID0gZGV0YWNoZWREb2MoKS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGxldCBmaXJzdFRhZyA9IC88KFthLXpdW14+XFxzXSspL2kuZXhlYyhodG1sKSwgd3JhcDtcbiAgICBpZiAod3JhcCA9IGZpcnN0VGFnICYmIHdyYXBNYXBbZmlyc3RUYWdbMV0udG9Mb3dlckNhc2UoKV0pXG4gICAgICAgIGh0bWwgPSB3cmFwLm1hcChuID0+IFwiPFwiICsgbiArIFwiPlwiKS5qb2luKFwiXCIpICsgaHRtbCArIHdyYXAubWFwKG4gPT4gXCI8L1wiICsgbiArIFwiPlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKTtcbiAgICBlbHQuaW5uZXJIVE1MID0gbWF5YmVXcmFwVHJ1c3RlZChodG1sKTtcbiAgICBpZiAod3JhcClcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3cmFwLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgZWx0ID0gZWx0LnF1ZXJ5U2VsZWN0b3Iod3JhcFtpXSkgfHwgZWx0O1xuICAgIHJldHVybiBlbHQ7XG59XG4vLyBXZWJraXQgYnJvd3NlcnMgZG8gc29tZSBoYXJkLXRvLXByZWRpY3QgcmVwbGFjZW1lbnQgb2YgcmVndWxhclxuLy8gc3BhY2VzIHdpdGggbm9uLWJyZWFraW5nIHNwYWNlcyB3aGVuIHB1dHRpbmcgY29udGVudCBvbiB0aGVcbi8vIGNsaXBib2FyZC4gVGhpcyB0cmllcyB0byBjb252ZXJ0IHN1Y2ggbm9uLWJyZWFraW5nIHNwYWNlcyAod2hpY2hcbi8vIHdpbGwgYmUgd3JhcHBlZCBpbiBhIHBsYWluIHNwYW4gb24gQ2hyb21lLCBhIHNwYW4gd2l0aCBjbGFzc1xuLy8gQXBwbGUtY29udmVydGVkLXNwYWNlIG9uIFNhZmFyaSkgYmFjayB0byByZWd1bGFyIHNwYWNlcy5cbmZ1bmN0aW9uIHJlc3RvcmVSZXBsYWNlZFNwYWNlcyhkb20pIHtcbiAgICBsZXQgbm9kZXMgPSBkb20ucXVlcnlTZWxlY3RvckFsbChjaHJvbWUgPyBcInNwYW46bm90KFtjbGFzc10pOm5vdChbc3R5bGVdKVwiIDogXCJzcGFuLkFwcGxlLWNvbnZlcnRlZC1zcGFjZVwiKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlLmNoaWxkTm9kZXMubGVuZ3RoID09IDEgJiYgbm9kZS50ZXh0Q29udGVudCA9PSBcIlxcdTAwYTBcIiAmJiBub2RlLnBhcmVudE5vZGUpXG4gICAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGRvbS5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiIFwiKSwgbm9kZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkQ29udGV4dChzbGljZSwgY29udGV4dCkge1xuICAgIGlmICghc2xpY2Uuc2l6ZSlcbiAgICAgICAgcmV0dXJuIHNsaWNlO1xuICAgIGxldCBzY2hlbWEgPSBzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQudHlwZS5zY2hlbWEsIGFycmF5O1xuICAgIHRyeSB7XG4gICAgICAgIGFycmF5ID0gSlNPTi5wYXJzZShjb250ZXh0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHNsaWNlO1xuICAgIH1cbiAgICBsZXQgeyBjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQgfSA9IHNsaWNlO1xuICAgIGZvciAobGV0IGkgPSBhcnJheS5sZW5ndGggLSAyOyBpID49IDA7IGkgLT0gMikge1xuICAgICAgICBsZXQgdHlwZSA9IHNjaGVtYS5ub2Rlc1thcnJheVtpXV07XG4gICAgICAgIGlmICghdHlwZSB8fCB0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjb250ZW50ID0gRnJhZ21lbnQuZnJvbSh0eXBlLmNyZWF0ZShhcnJheVtpICsgMV0sIGNvbnRlbnQpKTtcbiAgICAgICAgb3BlblN0YXJ0Kys7XG4gICAgICAgIG9wZW5FbmQrKztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTbGljZShjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xufVxuXG4vLyBBIGNvbGxlY3Rpb24gb2YgRE9NIGV2ZW50cyB0aGF0IG9jY3VyIHdpdGhpbiB0aGUgZWRpdG9yLCBhbmQgY2FsbGJhY2sgZnVuY3Rpb25zXG4vLyB0byBpbnZva2Ugd2hlbiB0aGUgZXZlbnQgZmlyZXMuXG5jb25zdCBoYW5kbGVycyA9IHt9O1xuY29uc3QgZWRpdEhhbmRsZXJzID0ge307XG5jb25zdCBwYXNzaXZlSGFuZGxlcnMgPSB7IHRvdWNoc3RhcnQ6IHRydWUsIHRvdWNobW92ZTogdHJ1ZSB9O1xuY2xhc3MgSW5wdXRTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc2hpZnRLZXkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tb3VzZURvd24gPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RLZXlDb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0S2V5Q29kZVRpbWUgPSAwO1xuICAgICAgICB0aGlzLmxhc3RDbGljayA9IHsgdGltZTogMCwgeDogMCwgeTogMCwgdHlwZTogXCJcIiwgYnV0dG9uOiAwIH07XG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGlvbk9yaWdpbiA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGlvblRpbWUgPSAwO1xuICAgICAgICB0aGlzLmxhc3RJT1NFbnRlciA9IDA7XG4gICAgICAgIHRoaXMubGFzdElPU0VudGVyRmFsbGJhY2tUaW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMubGFzdEZvY3VzID0gMDtcbiAgICAgICAgdGhpcy5sYXN0VG91Y2ggPSAwO1xuICAgICAgICB0aGlzLmxhc3RDaHJvbWVEZWxldGUgPSAwO1xuICAgICAgICB0aGlzLmNvbXBvc2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uTm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY29tcG9zaW5nVGltZW91dCA9IC0xO1xuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uTm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvbkVuZGVkQXQgPSAtMmU4O1xuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uSUQgPSAxO1xuICAgICAgICB0aGlzLmJhZFNhZmFyaUNvbXBvc2l0aW9uID0gZmFsc2U7XG4gICAgICAgIC8vIFNldCB0byBhIGNvbXBvc2l0aW9uIElEIHdoZW4gdGhlcmUgYXJlIHBlbmRpbmcgY2hhbmdlcyBhdCBjb21wb3NpdGlvbmVuZFxuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZXMgPSAwO1xuICAgICAgICB0aGlzLmRvbUNoYW5nZUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5oaWRlU2VsZWN0aW9uR3VhcmQgPSBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluaXRJbnB1dCh2aWV3KSB7XG4gICAgZm9yIChsZXQgZXZlbnQgaW4gaGFuZGxlcnMpIHtcbiAgICAgICAgbGV0IGhhbmRsZXIgPSBoYW5kbGVyc1tldmVudF07XG4gICAgICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIHZpZXcuaW5wdXQuZXZlbnRIYW5kbGVyc1tldmVudF0gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudEJlbG9uZ3NUb1ZpZXcodmlldywgZXZlbnQpICYmICFydW5DdXN0b21IYW5kbGVyKHZpZXcsIGV2ZW50KSAmJlxuICAgICAgICAgICAgICAgICh2aWV3LmVkaXRhYmxlIHx8ICEoZXZlbnQudHlwZSBpbiBlZGl0SGFuZGxlcnMpKSlcbiAgICAgICAgICAgICAgICBoYW5kbGVyKHZpZXcsIGV2ZW50KTtcbiAgICAgICAgfSwgcGFzc2l2ZUhhbmRsZXJzW2V2ZW50XSA/IHsgcGFzc2l2ZTogdHJ1ZSB9IDogdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLy8gT24gU2FmYXJpLCBmb3IgcmVhc29ucyBiZXlvbmQgbXkgdW5kZXJzdGFuZGluZywgYWRkaW5nIGFuIGlucHV0XG4gICAgLy8gZXZlbnQgaGFuZGxlciBtYWtlcyBhbiBpc3N1ZSB3aGVyZSB0aGUgY29tcG9zaXRpb24gdmFuaXNoZXMgd2hlblxuICAgIC8vIHlvdSBwcmVzcyBlbnRlciBnbyBhd2F5LlxuICAgIGlmIChzYWZhcmkpXG4gICAgICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCAoKSA9PiBudWxsKTtcbiAgICBlbnN1cmVMaXN0ZW5lcnModmlldyk7XG59XG5mdW5jdGlvbiBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgb3JpZ2luKSB7XG4gICAgdmlldy5pbnB1dC5sYXN0U2VsZWN0aW9uT3JpZ2luID0gb3JpZ2luO1xuICAgIHZpZXcuaW5wdXQubGFzdFNlbGVjdGlvblRpbWUgPSBEYXRlLm5vdygpO1xufVxuZnVuY3Rpb24gZGVzdHJveUlucHV0KHZpZXcpIHtcbiAgICB2aWV3LmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICBmb3IgKGxldCB0eXBlIGluIHZpZXcuaW5wdXQuZXZlbnRIYW5kbGVycylcbiAgICAgICAgdmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCB2aWV3LmlucHV0LmV2ZW50SGFuZGxlcnNbdHlwZV0pO1xuICAgIGNsZWFyVGltZW91dCh2aWV3LmlucHV0LmNvbXBvc2luZ1RpbWVvdXQpO1xuICAgIGNsZWFyVGltZW91dCh2aWV3LmlucHV0Lmxhc3RJT1NFbnRlckZhbGxiYWNrVGltZW91dCk7XG59XG5mdW5jdGlvbiBlbnN1cmVMaXN0ZW5lcnModmlldykge1xuICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVET01FdmVudHNcIiwgY3VycmVudEhhbmRsZXJzID0+IHtcbiAgICAgICAgZm9yIChsZXQgdHlwZSBpbiBjdXJyZW50SGFuZGxlcnMpXG4gICAgICAgICAgICBpZiAoIXZpZXcuaW5wdXQuZXZlbnRIYW5kbGVyc1t0eXBlXSlcbiAgICAgICAgICAgICAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHZpZXcuaW5wdXQuZXZlbnRIYW5kbGVyc1t0eXBlXSA9IGV2ZW50ID0+IHJ1bkN1c3RvbUhhbmRsZXIodmlldywgZXZlbnQpKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHJ1bkN1c3RvbUhhbmRsZXIodmlldywgZXZlbnQpIHtcbiAgICByZXR1cm4gdmlldy5zb21lUHJvcChcImhhbmRsZURPTUV2ZW50c1wiLCBoYW5kbGVycyA9PiB7XG4gICAgICAgIGxldCBoYW5kbGVyID0gaGFuZGxlcnNbZXZlbnQudHlwZV07XG4gICAgICAgIHJldHVybiBoYW5kbGVyID8gaGFuZGxlcih2aWV3LCBldmVudCkgfHwgZXZlbnQuZGVmYXVsdFByZXZlbnRlZCA6IGZhbHNlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZXZlbnRCZWxvbmdzVG9WaWV3KHZpZXcsIGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC5idWJibGVzKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IG5vZGUgPSBldmVudC50YXJnZXQ7IG5vZGUgIT0gdmlldy5kb207IG5vZGUgPSBub2RlLnBhcmVudE5vZGUpXG4gICAgICAgIGlmICghbm9kZSB8fCBub2RlLm5vZGVUeXBlID09IDExIHx8XG4gICAgICAgICAgICAobm9kZS5wbVZpZXdEZXNjICYmIG5vZGUucG1WaWV3RGVzYy5zdG9wRXZlbnQoZXZlbnQpKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQodmlldywgZXZlbnQpIHtcbiAgICBpZiAoIXJ1bkN1c3RvbUhhbmRsZXIodmlldywgZXZlbnQpICYmIGhhbmRsZXJzW2V2ZW50LnR5cGVdICYmXG4gICAgICAgICh2aWV3LmVkaXRhYmxlIHx8ICEoZXZlbnQudHlwZSBpbiBlZGl0SGFuZGxlcnMpKSlcbiAgICAgICAgaGFuZGxlcnNbZXZlbnQudHlwZV0odmlldywgZXZlbnQpO1xufVxuZWRpdEhhbmRsZXJzLmtleWRvd24gPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIHZpZXcuaW5wdXQuc2hpZnRLZXkgPSBldmVudC5rZXlDb2RlID09IDE2IHx8IGV2ZW50LnNoaWZ0S2V5O1xuICAgIGlmIChpbk9yTmVhckNvbXBvc2l0aW9uKHZpZXcsIGV2ZW50KSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgPSBldmVudC5rZXlDb2RlO1xuICAgIHZpZXcuaW5wdXQubGFzdEtleUNvZGVUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAvLyBTdXBwcmVzcyBlbnRlciBrZXkgZXZlbnRzIG9uIENocm9tZSBBbmRyb2lkLCBiZWNhdXNlIHRob3NlIHRlbmRcbiAgICAvLyB0byBiZSBwYXJ0IG9mIGEgY29uZnVzZWQgc2VxdWVuY2Ugb2YgY29tcG9zaXRpb24gZXZlbnRzIGZpcmVkLFxuICAgIC8vIGFuZCBoYW5kbGluZyB0aGVtIGVhZ2VybHkgdGVuZHMgdG8gY29ycnVwdCB0aGUgaW5wdXQuXG4gICAgaWYgKGFuZHJvaWQgJiYgY2hyb21lICYmIGV2ZW50LmtleUNvZGUgPT0gMTMpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoZXZlbnQua2V5Q29kZSAhPSAyMjkpXG4gICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuZm9yY2VGbHVzaCgpO1xuICAgIC8vIE9uIGlPUywgaWYgd2UgcHJldmVudERlZmF1bHQgZW50ZXIga2V5IHByZXNzZXMsIHRoZSB2aXJ0dWFsXG4gICAgLy8ga2V5Ym9hcmQgZ2V0cyBjb25mdXNlZC4gU28gdGhlIGhhY2sgaGVyZSBpcyB0byBzZXQgYSBmbGFnIHRoYXRcbiAgICAvLyBtYWtlcyB0aGUgRE9NIGNoYW5nZSBjb2RlIHJlY29nbml6ZSB0aGF0IHdoYXQganVzdCBoYXBwZW5zIHNob3VsZFxuICAgIC8vIGJlIHJlcGxhY2VkIGJ5IHdoYXRldmVyIHRoZSBFbnRlciBrZXkgaGFuZGxlcnMgZG8uXG4gICAgaWYgKGlvcyAmJiBldmVudC5rZXlDb2RlID09IDEzICYmICFldmVudC5jdHJsS2V5ICYmICFldmVudC5hbHRLZXkgJiYgIWV2ZW50Lm1ldGFLZXkpIHtcbiAgICAgICAgbGV0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID0gbm93O1xuICAgICAgICB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlckZhbGxiYWNrVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHZpZXcuaW5wdXQubGFzdElPU0VudGVyID09IG5vdykge1xuICAgICAgICAgICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGYgPT4gZih2aWV3LCBrZXlFdmVudCgxMywgXCJFbnRlclwiKSkpO1xuICAgICAgICAgICAgICAgIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMjAwKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGV2ZW50KSkgfHwgY2FwdHVyZUtleURvd24odmlldywgZXZlbnQpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgXCJrZXlcIik7XG4gICAgfVxufTtcbmVkaXRIYW5kbGVycy5rZXl1cCA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIGlmIChldmVudC5rZXlDb2RlID09IDE2KVxuICAgICAgICB2aWV3LmlucHV0LnNoaWZ0S2V5ID0gZmFsc2U7XG59O1xuZWRpdEhhbmRsZXJzLmtleXByZXNzID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICBpZiAoaW5Pck5lYXJDb21wb3NpdGlvbih2aWV3LCBldmVudCkgfHwgIWV2ZW50LmNoYXJDb2RlIHx8XG4gICAgICAgIGV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50LmFsdEtleSB8fCBtYWMgJiYgZXZlbnQubWV0YUtleSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5UHJlc3NcIiwgZiA9PiBmKHZpZXcsIGV2ZW50KSkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEoc2VsIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikgfHwgIXNlbC4kZnJvbS5zYW1lUGFyZW50KHNlbC4kdG8pKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gU3RyaW5nLmZyb21DaGFyQ29kZShldmVudC5jaGFyQ29kZSk7XG4gICAgICAgIGxldCBkZWZsdCA9ICgpID0+IHZpZXcuc3RhdGUudHIuaW5zZXJ0VGV4dCh0ZXh0KS5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICBpZiAoIS9bXFxyXFxuXS8udGVzdCh0ZXh0KSAmJiAhdmlldy5zb21lUHJvcChcImhhbmRsZVRleHRJbnB1dFwiLCBmID0+IGYodmlldywgc2VsLiRmcm9tLnBvcywgc2VsLiR0by5wb3MsIHRleHQsIGRlZmx0KSkpXG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKGRlZmx0KCkpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBldmVudENvb3JkcyhldmVudCkgeyByZXR1cm4geyBsZWZ0OiBldmVudC5jbGllbnRYLCB0b3A6IGV2ZW50LmNsaWVudFkgfTsgfVxuZnVuY3Rpb24gaXNOZWFyKGV2ZW50LCBjbGljaykge1xuICAgIGxldCBkeCA9IGNsaWNrLnggLSBldmVudC5jbGllbnRYLCBkeSA9IGNsaWNrLnkgLSBldmVudC5jbGllbnRZO1xuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSA8IDEwMDtcbn1cbmZ1bmN0aW9uIHJ1bkhhbmRsZXJPbkNvbnRleHQodmlldywgcHJvcE5hbWUsIHBvcywgaW5zaWRlLCBldmVudCkge1xuICAgIGlmIChpbnNpZGUgPT0gLTEpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoaW5zaWRlKTtcbiAgICBmb3IgKGxldCBpID0gJHBvcy5kZXB0aCArIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgaWYgKHZpZXcuc29tZVByb3AocHJvcE5hbWUsIGYgPT4gaSA+ICRwb3MuZGVwdGggPyBmKHZpZXcsIHBvcywgJHBvcy5ub2RlQWZ0ZXIsICRwb3MuYmVmb3JlKGkpLCBldmVudCwgdHJ1ZSlcbiAgICAgICAgICAgIDogZih2aWV3LCBwb3MsICRwb3Mubm9kZShpKSwgJHBvcy5iZWZvcmUoaSksIGV2ZW50LCBmYWxzZSkpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBzZWxlY3Rpb24sIG9yaWdpbikge1xuICAgIGlmICghdmlldy5mb2N1c2VkKVxuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgaWYgKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmVxKHNlbGVjdGlvbikpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgdHIgPSB2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIGlmIChvcmlnaW4gPT0gXCJwb2ludGVyXCIpXG4gICAgICAgIHRyLnNldE1ldGEoXCJwb2ludGVyXCIsIHRydWUpO1xuICAgIHZpZXcuZGlzcGF0Y2godHIpO1xufVxuZnVuY3Rpb24gc2VsZWN0Q2xpY2tlZExlYWYodmlldywgaW5zaWRlKSB7XG4gICAgaWYgKGluc2lkZSA9PSAtMSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkcG9zID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShpbnNpZGUpLCBub2RlID0gJHBvcy5ub2RlQWZ0ZXI7XG4gICAgaWYgKG5vZGUgJiYgbm9kZS5pc0F0b20gJiYgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpIHtcbiAgICAgICAgdXBkYXRlU2VsZWN0aW9uKHZpZXcsIG5ldyBOb2RlU2VsZWN0aW9uKCRwb3MpLCBcInBvaW50ZXJcIik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzZWxlY3RDbGlja2VkTm9kZSh2aWV3LCBpbnNpZGUpIHtcbiAgICBpZiAoaW5zaWRlID09IC0xKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLCBzZWxlY3RlZE5vZGUsIHNlbGVjdEF0O1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKVxuICAgICAgICBzZWxlY3RlZE5vZGUgPSBzZWwubm9kZTtcbiAgICBsZXQgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoaW5zaWRlKTtcbiAgICBmb3IgKGxldCBpID0gJHBvcy5kZXB0aCArIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgbGV0IG5vZGUgPSBpID4gJHBvcy5kZXB0aCA/ICRwb3Mubm9kZUFmdGVyIDogJHBvcy5ub2RlKGkpO1xuICAgICAgICBpZiAoTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZE5vZGUgJiYgc2VsLiRmcm9tLmRlcHRoID4gMCAmJlxuICAgICAgICAgICAgICAgIGkgPj0gc2VsLiRmcm9tLmRlcHRoICYmICRwb3MuYmVmb3JlKHNlbC4kZnJvbS5kZXB0aCArIDEpID09IHNlbC4kZnJvbS5wb3MpXG4gICAgICAgICAgICAgICAgc2VsZWN0QXQgPSAkcG9zLmJlZm9yZShzZWwuJGZyb20uZGVwdGgpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNlbGVjdEF0ID0gJHBvcy5iZWZvcmUoaSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2VsZWN0QXQgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVTZWxlY3Rpb24odmlldywgTm9kZVNlbGVjdGlvbi5jcmVhdGUodmlldy5zdGF0ZS5kb2MsIHNlbGVjdEF0KSwgXCJwb2ludGVyXCIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYW5kbGVTaW5nbGVDbGljayh2aWV3LCBwb3MsIGluc2lkZSwgZXZlbnQsIHNlbGVjdE5vZGUpIHtcbiAgICByZXR1cm4gcnVuSGFuZGxlck9uQ29udGV4dCh2aWV3LCBcImhhbmRsZUNsaWNrT25cIiwgcG9zLCBpbnNpZGUsIGV2ZW50KSB8fFxuICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlQ2xpY2tcIiwgZiA9PiBmKHZpZXcsIHBvcywgZXZlbnQpKSB8fFxuICAgICAgICAoc2VsZWN0Tm9kZSA/IHNlbGVjdENsaWNrZWROb2RlKHZpZXcsIGluc2lkZSkgOiBzZWxlY3RDbGlja2VkTGVhZih2aWV3LCBpbnNpZGUpKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZURvdWJsZUNsaWNrKHZpZXcsIHBvcywgaW5zaWRlLCBldmVudCkge1xuICAgIHJldHVybiBydW5IYW5kbGVyT25Db250ZXh0KHZpZXcsIFwiaGFuZGxlRG91YmxlQ2xpY2tPblwiLCBwb3MsIGluc2lkZSwgZXZlbnQpIHx8XG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVEb3VibGVDbGlja1wiLCBmID0+IGYodmlldywgcG9zLCBldmVudCkpO1xufVxuZnVuY3Rpb24gaGFuZGxlVHJpcGxlQ2xpY2sodmlldywgcG9zLCBpbnNpZGUsIGV2ZW50KSB7XG4gICAgcmV0dXJuIHJ1bkhhbmRsZXJPbkNvbnRleHQodmlldywgXCJoYW5kbGVUcmlwbGVDbGlja09uXCIsIHBvcywgaW5zaWRlLCBldmVudCkgfHxcbiAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZVRyaXBsZUNsaWNrXCIsIGYgPT4gZih2aWV3LCBwb3MsIGV2ZW50KSkgfHxcbiAgICAgICAgZGVmYXVsdFRyaXBsZUNsaWNrKHZpZXcsIGluc2lkZSwgZXZlbnQpO1xufVxuZnVuY3Rpb24gZGVmYXVsdFRyaXBsZUNsaWNrKHZpZXcsIGluc2lkZSwgZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZG9jID0gdmlldy5zdGF0ZS5kb2M7XG4gICAgaWYgKGluc2lkZSA9PSAtMSkge1xuICAgICAgICBpZiAoZG9jLmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgICAgIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIDAsIGRvYy5jb250ZW50LnNpemUpLCBcInBvaW50ZXJcIik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUoaW5zaWRlKTtcbiAgICBmb3IgKGxldCBpID0gJHBvcy5kZXB0aCArIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgbGV0IG5vZGUgPSBpID4gJHBvcy5kZXB0aCA/ICRwb3Mubm9kZUFmdGVyIDogJHBvcy5ub2RlKGkpO1xuICAgICAgICBsZXQgbm9kZVBvcyA9ICRwb3MuYmVmb3JlKGkpO1xuICAgICAgICBpZiAobm9kZS5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgdXBkYXRlU2VsZWN0aW9uKHZpZXcsIFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgbm9kZVBvcyArIDEsIG5vZGVQb3MgKyAxICsgbm9kZS5jb250ZW50LnNpemUpLCBcInBvaW50ZXJcIik7XG4gICAgICAgIGVsc2UgaWYgKE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKVxuICAgICAgICAgICAgdXBkYXRlU2VsZWN0aW9uKHZpZXcsIE5vZGVTZWxlY3Rpb24uY3JlYXRlKGRvYywgbm9kZVBvcyksIFwicG9pbnRlclwiKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZvcmNlRE9NRmx1c2godmlldykge1xuICAgIHJldHVybiBlbmRDb21wb3NpdGlvbih2aWV3KTtcbn1cbmNvbnN0IHNlbGVjdE5vZGVNb2RpZmllciA9IG1hYyA/IFwibWV0YUtleVwiIDogXCJjdHJsS2V5XCI7XG5oYW5kbGVycy5tb3VzZWRvd24gPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIHZpZXcuaW5wdXQuc2hpZnRLZXkgPSBldmVudC5zaGlmdEtleTtcbiAgICBsZXQgZmx1c2hlZCA9IGZvcmNlRE9NRmx1c2godmlldyk7XG4gICAgbGV0IG5vdyA9IERhdGUubm93KCksIHR5cGUgPSBcInNpbmdsZUNsaWNrXCI7XG4gICAgaWYgKG5vdyAtIHZpZXcuaW5wdXQubGFzdENsaWNrLnRpbWUgPCA1MDAgJiYgaXNOZWFyKGV2ZW50LCB2aWV3LmlucHV0Lmxhc3RDbGljaykgJiYgIWV2ZW50W3NlbGVjdE5vZGVNb2RpZmllcl0gJiZcbiAgICAgICAgdmlldy5pbnB1dC5sYXN0Q2xpY2suYnV0dG9uID09IGV2ZW50LmJ1dHRvbikge1xuICAgICAgICBpZiAodmlldy5pbnB1dC5sYXN0Q2xpY2sudHlwZSA9PSBcInNpbmdsZUNsaWNrXCIpXG4gICAgICAgICAgICB0eXBlID0gXCJkb3VibGVDbGlja1wiO1xuICAgICAgICBlbHNlIGlmICh2aWV3LmlucHV0Lmxhc3RDbGljay50eXBlID09IFwiZG91YmxlQ2xpY2tcIilcbiAgICAgICAgICAgIHR5cGUgPSBcInRyaXBsZUNsaWNrXCI7XG4gICAgfVxuICAgIHZpZXcuaW5wdXQubGFzdENsaWNrID0geyB0aW1lOiBub3csIHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFksIHR5cGUsIGJ1dHRvbjogZXZlbnQuYnV0dG9uIH07XG4gICAgbGV0IHBvcyA9IHZpZXcucG9zQXRDb29yZHMoZXZlbnRDb29yZHMoZXZlbnQpKTtcbiAgICBpZiAoIXBvcylcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh0eXBlID09IFwic2luZ2xlQ2xpY2tcIikge1xuICAgICAgICBpZiAodmlldy5pbnB1dC5tb3VzZURvd24pXG4gICAgICAgICAgICB2aWV3LmlucHV0Lm1vdXNlRG93bi5kb25lKCk7XG4gICAgICAgIHZpZXcuaW5wdXQubW91c2VEb3duID0gbmV3IE1vdXNlRG93bih2aWV3LCBwb3MsIGV2ZW50LCAhIWZsdXNoZWQpO1xuICAgIH1cbiAgICBlbHNlIGlmICgodHlwZSA9PSBcImRvdWJsZUNsaWNrXCIgPyBoYW5kbGVEb3VibGVDbGljayA6IGhhbmRsZVRyaXBsZUNsaWNrKSh2aWV3LCBwb3MucG9zLCBwb3MuaW5zaWRlLCBldmVudCkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNldFNlbGVjdGlvbk9yaWdpbih2aWV3LCBcInBvaW50ZXJcIik7XG4gICAgfVxufTtcbmNsYXNzIE1vdXNlRG93biB7XG4gICAgY29uc3RydWN0b3IodmlldywgcG9zLCBldmVudCwgZmx1c2hlZCkge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5ldmVudCA9IGV2ZW50O1xuICAgICAgICB0aGlzLmZsdXNoZWQgPSBmbHVzaGVkO1xuICAgICAgICB0aGlzLmRlbGF5ZWRTZWxlY3Rpb25TeW5jID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWlnaHREcmFnID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGFydERvYyA9IHZpZXcuc3RhdGUuZG9jO1xuICAgICAgICB0aGlzLnNlbGVjdE5vZGUgPSAhIWV2ZW50W3NlbGVjdE5vZGVNb2RpZmllcl07XG4gICAgICAgIHRoaXMuYWxsb3dEZWZhdWx0ID0gZXZlbnQuc2hpZnRLZXk7XG4gICAgICAgIGxldCB0YXJnZXROb2RlLCB0YXJnZXRQb3M7XG4gICAgICAgIGlmIChwb3MuaW5zaWRlID4gLTEpIHtcbiAgICAgICAgICAgIHRhcmdldE5vZGUgPSB2aWV3LnN0YXRlLmRvYy5ub2RlQXQocG9zLmluc2lkZSk7XG4gICAgICAgICAgICB0YXJnZXRQb3MgPSBwb3MuaW5zaWRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0ICRwb3MgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHBvcy5wb3MpO1xuICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9ICRwb3MucGFyZW50O1xuICAgICAgICAgICAgdGFyZ2V0UG9zID0gJHBvcy5kZXB0aCA/ICRwb3MuYmVmb3JlKCkgOiAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGZsdXNoZWQgPyBudWxsIDogZXZlbnQudGFyZ2V0O1xuICAgICAgICBjb25zdCB0YXJnZXREZXNjID0gdGFyZ2V0ID8gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKHRhcmdldCwgdHJ1ZSkgOiBudWxsO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldERlc2MgJiYgdGFyZ2V0RGVzYy5ub2RlRE9NLm5vZGVUeXBlID09IDEgPyB0YXJnZXREZXNjLm5vZGVET00gOiBudWxsO1xuICAgICAgICBsZXQgeyBzZWxlY3Rpb24gfSA9IHZpZXcuc3RhdGU7XG4gICAgICAgIGlmIChldmVudC5idXR0b24gPT0gMCAmJlxuICAgICAgICAgICAgdGFyZ2V0Tm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlICYmIHRhcmdldE5vZGUudHlwZS5zcGVjLnNlbGVjdGFibGUgIT09IGZhbHNlIHx8XG4gICAgICAgICAgICBzZWxlY3Rpb24gaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uICYmIHNlbGVjdGlvbi5mcm9tIDw9IHRhcmdldFBvcyAmJiBzZWxlY3Rpb24udG8gPiB0YXJnZXRQb3MpXG4gICAgICAgICAgICB0aGlzLm1pZ2h0RHJhZyA9IHtcbiAgICAgICAgICAgICAgICBub2RlOiB0YXJnZXROb2RlLFxuICAgICAgICAgICAgICAgIHBvczogdGFyZ2V0UG9zLFxuICAgICAgICAgICAgICAgIGFkZEF0dHI6ICEhKHRoaXMudGFyZ2V0ICYmICF0aGlzLnRhcmdldC5kcmFnZ2FibGUpLFxuICAgICAgICAgICAgICAgIHNldFVuZWRpdGFibGU6ICEhKHRoaXMudGFyZ2V0ICYmIGdlY2tvICYmICF0aGlzLnRhcmdldC5oYXNBdHRyaWJ1dGUoXCJjb250ZW50RWRpdGFibGVcIikpXG4gICAgICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy50YXJnZXQgJiYgdGhpcy5taWdodERyYWcgJiYgKHRoaXMubWlnaHREcmFnLmFkZEF0dHIgfHwgdGhpcy5taWdodERyYWcuc2V0VW5lZGl0YWJsZSkpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5taWdodERyYWcuYWRkQXR0cilcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldC5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMubWlnaHREcmFnLnNldFVuZWRpdGFibGUpXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXcuaW5wdXQubW91c2VEb3duID09IHRoaXMpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldC5zZXRBdHRyaWJ1dGUoXCJjb250ZW50RWRpdGFibGVcIiwgXCJmYWxzZVwiKTtcbiAgICAgICAgICAgICAgICB9LCAyMCk7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICB2aWV3LnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy51cCA9IHRoaXMudXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHZpZXcucm9vdC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW92ZSA9IHRoaXMubW92ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIFwicG9pbnRlclwiKTtcbiAgICB9XG4gICAgZG9uZSgpIHtcbiAgICAgICAgdGhpcy52aWV3LnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy51cCk7XG4gICAgICAgIHRoaXMudmlldy5yb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3ZlKTtcbiAgICAgICAgaWYgKHRoaXMubWlnaHREcmFnICYmIHRoaXMudGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMubWlnaHREcmFnLmFkZEF0dHIpXG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlQXR0cmlidXRlKFwiZHJhZ2dhYmxlXCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMubWlnaHREcmFnLnNldFVuZWRpdGFibGUpXG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlQXR0cmlidXRlKFwiY29udGVudEVkaXRhYmxlXCIpO1xuICAgICAgICAgICAgdGhpcy52aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGVsYXllZFNlbGVjdGlvblN5bmMpXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHNlbGVjdGlvblRvRE9NKHRoaXMudmlldykpO1xuICAgICAgICB0aGlzLnZpZXcuaW5wdXQubW91c2VEb3duID0gbnVsbDtcbiAgICB9XG4gICAgdXAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5kb25lKCk7XG4gICAgICAgIGlmICghdGhpcy52aWV3LmRvbS5jb250YWlucyhldmVudC50YXJnZXQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5wb3M7XG4gICAgICAgIGlmICh0aGlzLnZpZXcuc3RhdGUuZG9jICE9IHRoaXMuc3RhcnREb2MpXG4gICAgICAgICAgICBwb3MgPSB0aGlzLnZpZXcucG9zQXRDb29yZHMoZXZlbnRDb29yZHMoZXZlbnQpKTtcbiAgICAgICAgdGhpcy51cGRhdGVBbGxvd0RlZmF1bHQoZXZlbnQpO1xuICAgICAgICBpZiAodGhpcy5hbGxvd0RlZmF1bHQgfHwgIXBvcykge1xuICAgICAgICAgICAgc2V0U2VsZWN0aW9uT3JpZ2luKHRoaXMudmlldywgXCJwb2ludGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhbmRsZVNpbmdsZUNsaWNrKHRoaXMudmlldywgcG9zLnBvcywgcG9zLmluc2lkZSwgZXZlbnQsIHRoaXMuc2VsZWN0Tm9kZSkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXZlbnQuYnV0dG9uID09IDAgJiZcbiAgICAgICAgICAgICh0aGlzLmZsdXNoZWQgfHxcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgaWdub3JlcyBjbGlja3Mgb24gZHJhZ2dhYmxlIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgKHNhZmFyaSAmJiB0aGlzLm1pZ2h0RHJhZyAmJiAhdGhpcy5taWdodERyYWcubm9kZS5pc0F0b20pIHx8XG4gICAgICAgICAgICAgICAgLy8gQ2hyb21lIHdpbGwgc29tZXRpbWVzIHRyZWF0IGEgbm9kZSBzZWxlY3Rpb24gYXMgYVxuICAgICAgICAgICAgICAgIC8vIGN1cnNvciwgYnV0IHN0aWxsIHJlcG9ydCB0aGF0IHRoZSBub2RlIGlzIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgLy8gd2hlbiBhc2tlZCB0aHJvdWdoIGdldFNlbGVjdGlvbi4gWW91J2xsIHRoZW4gZ2V0IGFcbiAgICAgICAgICAgICAgICAvLyBzaXR1YXRpb24gd2hlcmUgY2xpY2tpbmcgYXQgdGhlIHBvaW50IHdoZXJlIHRoYXRcbiAgICAgICAgICAgICAgICAvLyAoaGlkZGVuKSBjdXJzb3IgaXMgZG9lc24ndCBjaGFuZ2UgdGhlIHNlbGVjdGlvbiwgYW5kXG4gICAgICAgICAgICAgICAgLy8gdGh1cyBkb2Vzbid0IGdldCBhIHJlYWN0aW9uIGZyb20gUHJvc2VNaXJyb3IuIFRoaXNcbiAgICAgICAgICAgICAgICAvLyB3b3JrcyBhcm91bmQgdGhhdC5cbiAgICAgICAgICAgICAgICAoY2hyb21lICYmICF0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLnZpc2libGUgJiZcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oTWF0aC5hYnMocG9zLnBvcyAtIHRoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSksIE1hdGguYWJzKHBvcy5wb3MgLSB0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvKSkgPD0gMikpKSB7XG4gICAgICAgICAgICB1cGRhdGVTZWxlY3Rpb24odGhpcy52aWV3LCBTZWxlY3Rpb24ubmVhcih0aGlzLnZpZXcuc3RhdGUuZG9jLnJlc29sdmUocG9zLnBvcykpLCBcInBvaW50ZXJcIik7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0U2VsZWN0aW9uT3JpZ2luKHRoaXMudmlldywgXCJwb2ludGVyXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1vdmUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy51cGRhdGVBbGxvd0RlZmF1bHQoZXZlbnQpO1xuICAgICAgICBzZXRTZWxlY3Rpb25PcmlnaW4odGhpcy52aWV3LCBcInBvaW50ZXJcIik7XG4gICAgICAgIGlmIChldmVudC5idXR0b25zID09IDApXG4gICAgICAgICAgICB0aGlzLmRvbmUoKTtcbiAgICB9XG4gICAgdXBkYXRlQWxsb3dEZWZhdWx0KGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5hbGxvd0RlZmF1bHQgJiYgKE1hdGguYWJzKHRoaXMuZXZlbnQueCAtIGV2ZW50LmNsaWVudFgpID4gNCB8fFxuICAgICAgICAgICAgTWF0aC5hYnModGhpcy5ldmVudC55IC0gZXZlbnQuY2xpZW50WSkgPiA0KSlcbiAgICAgICAgICAgIHRoaXMuYWxsb3dEZWZhdWx0ID0gdHJ1ZTtcbiAgICB9XG59XG5oYW5kbGVycy50b3VjaHN0YXJ0ID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dC5sYXN0VG91Y2ggPSBEYXRlLm5vdygpO1xuICAgIGZvcmNlRE9NRmx1c2godmlldyk7XG4gICAgc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIFwicG9pbnRlclwiKTtcbn07XG5oYW5kbGVycy50b3VjaG1vdmUgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0Lmxhc3RUb3VjaCA9IERhdGUubm93KCk7XG4gICAgc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIFwicG9pbnRlclwiKTtcbn07XG5oYW5kbGVycy5jb250ZXh0bWVudSA9IHZpZXcgPT4gZm9yY2VET01GbHVzaCh2aWV3KTtcbmZ1bmN0aW9uIGluT3JOZWFyQ29tcG9zaXRpb24odmlldywgZXZlbnQpIHtcbiAgICBpZiAodmlldy5jb21wb3NpbmcpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIC8vIFNlZSBodHRwczovL3d3dy5zdHVtLmRlLzIwMTYvMDYvMjQvaGFuZGxpbmctaW1lLWV2ZW50cy1pbi1qYXZhc2NyaXB0Ly5cbiAgICAvLyBPbiBKYXBhbmVzZSBpbnB1dCBtZXRob2QgZWRpdG9ycyAoSU1FcyksIHRoZSBFbnRlciBrZXkgaXMgdXNlZCB0byBjb25maXJtIGNoYXJhY3RlclxuICAgIC8vIHNlbGVjdGlvbi4gT24gU2FmYXJpLCB3aGVuIEVudGVyIGlzIHByZXNzZWQsIGNvbXBvc2l0aW9uZW5kIGFuZCBrZXlkb3duIGV2ZW50cyBhcmVcbiAgICAvLyBlbWl0dGVkLiBUaGUga2V5ZG93biBldmVudCB0cmlnZ2VycyBuZXdsaW5lIGluc2VydGlvbiwgd2hpY2ggd2UgZG9uJ3Qgd2FudC5cbiAgICAvLyBUaGlzIG1ldGhvZCByZXR1cm5zIHRydWUgaWYgdGhlIGtleWRvd24gZXZlbnQgc2hvdWxkIGJlIGlnbm9yZWQuXG4gICAgLy8gV2Ugb25seSBpZ25vcmUgaXQgb25jZSwgYXMgcHJlc3NpbmcgRW50ZXIgYSBzZWNvbmQgdGltZSAqc2hvdWxkKiBpbnNlcnQgYSBuZXdsaW5lLlxuICAgIC8vIEZ1cnRoZXJtb3JlLCB0aGUga2V5ZG93biBldmVudCB0aW1lc3RhbXAgbXVzdCBiZSBjbG9zZSB0byB0aGUgY29tcG9zaXRpb25FbmRlZEF0IHRpbWVzdGFtcC5cbiAgICAvLyBUaGlzIGd1YXJkcyBhZ2FpbnN0IHRoZSBjYXNlIHdoZXJlIGNvbXBvc2l0aW9uZW5kIGlzIHRyaWdnZXJlZCB3aXRob3V0IHRoZSBrZXlib2FyZFxuICAgIC8vIChlLmcuIGNoYXJhY3RlciBjb25maXJtYXRpb24gbWF5IGJlIGRvbmUgd2l0aCB0aGUgbW91c2UpLCBhbmQga2V5ZG93biBpcyB0cmlnZ2VyZWRcbiAgICAvLyBhZnRlcndhcmRzLSB3ZSB3b3VsZG4ndCB3YW50IHRvIGlnbm9yZSB0aGUga2V5ZG93biBldmVudCBpbiB0aGlzIGNhc2UuXG4gICAgaWYgKHNhZmFyaSAmJiBNYXRoLmFicyhldmVudC50aW1lU3RhbXAgLSB2aWV3LmlucHV0LmNvbXBvc2l0aW9uRW5kZWRBdCkgPCA1MDApIHtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbkVuZGVkQXQgPSAtMmU4O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gRHJvcCBhY3RpdmUgY29tcG9zaXRpb24gYWZ0ZXIgNSBzZWNvbmRzIG9mIGluYWN0aXZpdHkgb24gQW5kcm9pZFxuY29uc3QgdGltZW91dENvbXBvc2l0aW9uID0gYW5kcm9pZCA/IDUwMDAgOiAtMTtcbmVkaXRIYW5kbGVycy5jb21wb3NpdGlvbnN0YXJ0ID0gZWRpdEhhbmRsZXJzLmNvbXBvc2l0aW9udXBkYXRlID0gdmlldyA9PiB7XG4gICAgaWYgKCF2aWV3LmNvbXBvc2luZykge1xuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLmZsdXNoKCk7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCAkcG9zID0gc3RhdGUuc2VsZWN0aW9uLiR0bztcbiAgICAgICAgaWYgKHN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24gJiZcbiAgICAgICAgICAgIChzdGF0ZS5zdG9yZWRNYXJrcyB8fFxuICAgICAgICAgICAgICAgICghJHBvcy50ZXh0T2Zmc2V0ICYmICRwb3MucGFyZW50T2Zmc2V0ICYmICRwb3Mubm9kZUJlZm9yZS5tYXJrcy5zb21lKG0gPT4gbS50eXBlLnNwZWMuaW5jbHVzaXZlID09PSBmYWxzZSkpIHx8XG4gICAgICAgICAgICAgICAgY2hyb21lICYmIHdpbmRvd3MgJiYgc2VsZWN0aW9uQmVmb3JlVW5lZGl0YWJsZSh2aWV3KSkpIHsgLy8gSXNzdWUgIzE1MDBcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gd3JhcCB0aGUgY3Vyc29yIGluIG1hcmsgbm9kZXMgZGlmZmVyZW50IGZyb20gdGhlIG9uZXMgaW4gdGhlIERPTSBjb250ZXh0XG4gICAgICAgICAgICB2aWV3Lm1hcmtDdXJzb3IgPSB2aWV3LnN0YXRlLnN0b3JlZE1hcmtzIHx8ICRwb3MubWFya3MoKTtcbiAgICAgICAgICAgIGVuZENvbXBvc2l0aW9uKHZpZXcsIHRydWUpO1xuICAgICAgICAgICAgdmlldy5tYXJrQ3Vyc29yID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVuZENvbXBvc2l0aW9uKHZpZXcsICFzdGF0ZS5zZWxlY3Rpb24uZW1wdHkpO1xuICAgICAgICAgICAgLy8gSW4gZmlyZWZveCwgaWYgdGhlIGN1cnNvciBpcyBhZnRlciBidXQgb3V0c2lkZSBhIG1hcmtlZCBub2RlLFxuICAgICAgICAgICAgLy8gdGhlIGluc2VydGVkIHRleHQgd29uJ3QgaW5oZXJpdCB0aGUgbWFya3MuIFNvIHRoaXMgbW92ZXMgaXRcbiAgICAgICAgICAgIC8vIGluc2lkZSBpZiBuZWNlc3NhcnkuXG4gICAgICAgICAgICBpZiAoZ2Vja28gJiYgc3RhdGUuc2VsZWN0aW9uLmVtcHR5ICYmICRwb3MucGFyZW50T2Zmc2V0ICYmICEkcG9zLnRleHRPZmZzZXQgJiYgJHBvcy5ub2RlQmVmb3JlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbm9kZSA9IHNlbC5mb2N1c05vZGUsIG9mZnNldCA9IHNlbC5mb2N1c09mZnNldDsgbm9kZSAmJiBub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0ICE9IDA7KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBiZWZvcmUgPSBvZmZzZXQgPCAwID8gbm9kZS5sYXN0Q2hpbGQgOiBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghYmVmb3JlKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZWZvcmUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbC5jb2xsYXBzZShiZWZvcmUsIGJlZm9yZS5ub2RlVmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGJlZm9yZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgc2NoZWR1bGVDb21wb3NlRW5kKHZpZXcsIHRpbWVvdXRDb21wb3NpdGlvbik7XG59O1xuZnVuY3Rpb24gc2VsZWN0aW9uQmVmb3JlVW5lZGl0YWJsZSh2aWV3KSB7XG4gICAgbGV0IHsgZm9jdXNOb2RlLCBmb2N1c09mZnNldCB9ID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgIGlmICghZm9jdXNOb2RlIHx8IGZvY3VzTm9kZS5ub2RlVHlwZSAhPSAxIHx8IGZvY3VzT2Zmc2V0ID49IGZvY3VzTm9kZS5jaGlsZE5vZGVzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBuZXh0ID0gZm9jdXNOb2RlLmNoaWxkTm9kZXNbZm9jdXNPZmZzZXRdO1xuICAgIHJldHVybiBuZXh0Lm5vZGVUeXBlID09IDEgJiYgbmV4dC5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiO1xufVxuZWRpdEhhbmRsZXJzLmNvbXBvc2l0aW9uZW5kID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgaWYgKHZpZXcuY29tcG9zaW5nKSB7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25FbmRlZEF0ID0gZXZlbnQudGltZVN0YW1wO1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZXMgPSB2aWV3LmRvbU9ic2VydmVyLnBlbmRpbmdSZWNvcmRzKCkubGVuZ3RoID8gdmlldy5pbnB1dC5jb21wb3NpdGlvbklEIDogMDtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbk5vZGUgPSBudWxsO1xuICAgICAgICBpZiAodmlldy5pbnB1dC5iYWRTYWZhcmlDb21wb3NpdGlvbilcbiAgICAgICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuZm9yY2VGbHVzaCgpO1xuICAgICAgICBlbHNlIGlmICh2aWV3LmlucHV0LmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZXMpXG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHZpZXcuZG9tT2JzZXJ2ZXIuZmx1c2goKSk7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25JRCsrO1xuICAgICAgICBzY2hlZHVsZUNvbXBvc2VFbmQodmlldywgMjApO1xuICAgIH1cbn07XG5mdW5jdGlvbiBzY2hlZHVsZUNvbXBvc2VFbmQodmlldywgZGVsYXkpIHtcbiAgICBjbGVhclRpbWVvdXQodmlldy5pbnB1dC5jb21wb3NpbmdUaW1lb3V0KTtcbiAgICBpZiAoZGVsYXkgPiAtMSlcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpbmdUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBlbmRDb21wb3NpdGlvbih2aWV3KSwgZGVsYXkpO1xufVxuZnVuY3Rpb24gY2xlYXJDb21wb3NpdGlvbih2aWV3KSB7XG4gICAgaWYgKHZpZXcuY29tcG9zaW5nKSB7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25FbmRlZEF0ID0gdGltZXN0YW1wRnJvbUN1c3RvbUV2ZW50KCk7XG4gICAgfVxuICAgIHdoaWxlICh2aWV3LmlucHV0LmNvbXBvc2l0aW9uTm9kZXMubGVuZ3RoID4gMClcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbk5vZGVzLnBvcCgpLm1hcmtQYXJlbnRzRGlydHkoKTtcbn1cbmZ1bmN0aW9uIGZpbmRDb21wb3NpdGlvbk5vZGUodmlldykge1xuICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgaWYgKCFzZWwuZm9jdXNOb2RlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgdGV4dEJlZm9yZSA9IHRleHROb2RlQmVmb3JlJDEoc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0KTtcbiAgICBsZXQgdGV4dEFmdGVyID0gdGV4dE5vZGVBZnRlciQxKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XG4gICAgaWYgKHRleHRCZWZvcmUgJiYgdGV4dEFmdGVyICYmIHRleHRCZWZvcmUgIT0gdGV4dEFmdGVyKSB7XG4gICAgICAgIGxldCBkZXNjQWZ0ZXIgPSB0ZXh0QWZ0ZXIucG1WaWV3RGVzYywgbGFzdENoYW5nZWQgPSB2aWV3LmRvbU9ic2VydmVyLmxhc3RDaGFuZ2VkVGV4dE5vZGU7XG4gICAgICAgIGlmICh0ZXh0QmVmb3JlID09IGxhc3RDaGFuZ2VkIHx8IHRleHRBZnRlciA9PSBsYXN0Q2hhbmdlZClcbiAgICAgICAgICAgIHJldHVybiBsYXN0Q2hhbmdlZDtcbiAgICAgICAgaWYgKCFkZXNjQWZ0ZXIgfHwgIWRlc2NBZnRlci5pc1RleHQodGV4dEFmdGVyLm5vZGVWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0QWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmlldy5pbnB1dC5jb21wb3NpdGlvbk5vZGUgPT0gdGV4dEFmdGVyKSB7XG4gICAgICAgICAgICBsZXQgZGVzY0JlZm9yZSA9IHRleHRCZWZvcmUucG1WaWV3RGVzYztcbiAgICAgICAgICAgIGlmICghKCFkZXNjQmVmb3JlIHx8ICFkZXNjQmVmb3JlLmlzVGV4dCh0ZXh0QmVmb3JlLm5vZGVWYWx1ZSkpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0QWZ0ZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRleHRCZWZvcmUgfHwgdGV4dEFmdGVyO1xufVxuZnVuY3Rpb24gdGltZXN0YW1wRnJvbUN1c3RvbUV2ZW50KCkge1xuICAgIGxldCBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7XG4gICAgZXZlbnQuaW5pdEV2ZW50KFwiZXZlbnRcIiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIGV2ZW50LnRpbWVTdGFtcDtcbn1cbi8qKlxuQGludGVybmFsXG4qL1xuZnVuY3Rpb24gZW5kQ29tcG9zaXRpb24odmlldywgcmVzdGFydGluZyA9IGZhbHNlKSB7XG4gICAgaWYgKGFuZHJvaWQgJiYgdmlldy5kb21PYnNlcnZlci5mbHVzaGluZ1Nvb24gPj0gMClcbiAgICAgICAgcmV0dXJuO1xuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuZm9yY2VGbHVzaCgpO1xuICAgIGNsZWFyQ29tcG9zaXRpb24odmlldyk7XG4gICAgaWYgKHJlc3RhcnRpbmcgfHwgdmlldy5kb2NWaWV3ICYmIHZpZXcuZG9jVmlldy5kaXJ0eSkge1xuICAgICAgICBsZXQgc2VsID0gc2VsZWN0aW9uRnJvbURPTSh2aWV3KSwgY3VyID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGlmIChzZWwgJiYgIXNlbC5lcShjdXIpKVxuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWwpKTtcbiAgICAgICAgZWxzZSBpZiAoKHZpZXcubWFya0N1cnNvciB8fCByZXN0YXJ0aW5nKSAmJiAhY3VyLiRmcm9tLm5vZGUoY3VyLiRmcm9tLnNoYXJlZERlcHRoKGN1ci50bykpLmlubGluZUNvbnRlbnQpXG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuZGVsZXRlU2VsZWN0aW9uKCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB2aWV3LnVwZGF0ZVN0YXRlKHZpZXcuc3RhdGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY2FwdHVyZUNvcHkodmlldywgZG9tKSB7XG4gICAgLy8gVGhlIGV4dHJhIHdyYXBwZXIgaXMgc29tZWhvdyBuZWNlc3Nhcnkgb24gSUUvRWRnZSB0byBwcmV2ZW50IHRoZVxuICAgIC8vIGNvbnRlbnQgZnJvbSBiZWluZyBtYW5nbGVkIHdoZW4gaXQgaXMgcHV0IG9udG8gdGhlIGNsaXBib2FyZFxuICAgIGlmICghdmlldy5kb20ucGFyZW50Tm9kZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCB3cmFwID0gdmlldy5kb20ucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICB3cmFwLmFwcGVuZENoaWxkKGRvbSk7XG4gICAgd3JhcC5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogZml4ZWQ7IGxlZnQ6IC0xMDAwMHB4OyB0b3A6IDEwcHhcIjtcbiAgICBsZXQgc2VsID0gZ2V0U2VsZWN0aW9uKCksIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHMoZG9tKTtcbiAgICAvLyBEb25lIGJlY2F1c2UgSUUgd2lsbCBmaXJlIGEgc2VsZWN0aW9uY2hhbmdlIG1vdmluZyB0aGUgc2VsZWN0aW9uXG4gICAgLy8gdG8gaXRzIHN0YXJ0IHdoZW4gcmVtb3ZlQWxsUmFuZ2VzIGlzIGNhbGxlZCBhbmQgdGhlIGVkaXRvciBzdGlsbFxuICAgIC8vIGhhcyBmb2N1cyAod2hpY2ggd2lsbCBtZXNzIHVwIHRoZSBlZGl0b3IncyBzZWxlY3Rpb24gc3RhdGUpLlxuICAgIHZpZXcuZG9tLmJsdXIoKTtcbiAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgc2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHdyYXAucGFyZW50Tm9kZSlcbiAgICAgICAgICAgIHdyYXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh3cmFwKTtcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgIH0sIDUwKTtcbn1cbi8vIFRoaXMgaXMgdmVyeSBjcnVkZSwgYnV0IHVuZm9ydHVuYXRlbHkgYm90aCB0aGVzZSBicm93c2VycyBfcHJldGVuZF9cbi8vIHRoYXQgdGhleSBoYXZlIGEgY2xpcGJvYXJkIEFQSeKAlGFsbCB0aGUgb2JqZWN0cyBhbmQgbWV0aG9kcyBhcmVcbi8vIHRoZXJlLCB0aGV5IGp1c3QgZG9uJ3Qgd29yaywgYW5kIHRoZXkgYXJlIGhhcmQgdG8gdGVzdC5cbmNvbnN0IGJyb2tlbkNsaXBib2FyZEFQSSA9IChpZSAmJiBpZV92ZXJzaW9uIDwgMTUpIHx8XG4gICAgKGlvcyAmJiB3ZWJraXRfdmVyc2lvbiA8IDYwNCk7XG5oYW5kbGVycy5jb3B5ID0gZWRpdEhhbmRsZXJzLmN1dCA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLCBjdXQgPSBldmVudC50eXBlID09IFwiY3V0XCI7XG4gICAgaWYgKHNlbC5lbXB0eSlcbiAgICAgICAgcmV0dXJuO1xuICAgIC8vIElFIGFuZCBFZGdlJ3MgY2xpcGJvYXJkIGludGVyZmFjZSBpcyBjb21wbGV0ZWx5IGJyb2tlblxuICAgIGxldCBkYXRhID0gYnJva2VuQ2xpcGJvYXJkQVBJID8gbnVsbCA6IGV2ZW50LmNsaXBib2FyZERhdGE7XG4gICAgbGV0IHNsaWNlID0gc2VsLmNvbnRlbnQoKSwgeyBkb20sIHRleHQgfSA9IHNlcmlhbGl6ZUZvckNsaXBib2FyZCh2aWV3LCBzbGljZSk7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZGF0YS5jbGVhckRhdGEoKTtcbiAgICAgICAgZGF0YS5zZXREYXRhKFwidGV4dC9odG1sXCIsIGRvbS5pbm5lckhUTUwpO1xuICAgICAgICBkYXRhLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIHRleHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2FwdHVyZUNvcHkodmlldywgZG9tKTtcbiAgICB9XG4gICAgaWYgKGN1dClcbiAgICAgICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLmRlbGV0ZVNlbGVjdGlvbigpLnNjcm9sbEludG9WaWV3KCkuc2V0TWV0YShcInVpRXZlbnRcIiwgXCJjdXRcIikpO1xufTtcbmZ1bmN0aW9uIHNsaWNlU2luZ2xlTm9kZShzbGljZSkge1xuICAgIHJldHVybiBzbGljZS5vcGVuU3RhcnQgPT0gMCAmJiBzbGljZS5vcGVuRW5kID09IDAgJiYgc2xpY2UuY29udGVudC5jaGlsZENvdW50ID09IDEgPyBzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQgOiBudWxsO1xufVxuZnVuY3Rpb24gY2FwdHVyZVBhc3RlKHZpZXcsIGV2ZW50KSB7XG4gICAgaWYgKCF2aWV3LmRvbS5wYXJlbnROb2RlKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHBsYWluVGV4dCA9IHZpZXcuaW5wdXQuc2hpZnRLZXkgfHwgdmlldy5zdGF0ZS5zZWxlY3Rpb24uJGZyb20ucGFyZW50LnR5cGUuc3BlYy5jb2RlO1xuICAgIGxldCB0YXJnZXQgPSB2aWV3LmRvbS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocGxhaW5UZXh0ID8gXCJ0ZXh0YXJlYVwiIDogXCJkaXZcIikpO1xuICAgIGlmICghcGxhaW5UZXh0KVxuICAgICAgICB0YXJnZXQuY29udGVudEVkaXRhYmxlID0gXCJ0cnVlXCI7XG4gICAgdGFyZ2V0LnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogLTEwMDAwcHg7IHRvcDogMTBweFwiO1xuICAgIHRhcmdldC5mb2N1cygpO1xuICAgIGxldCBwbGFpbiA9IHZpZXcuaW5wdXQuc2hpZnRLZXkgJiYgdmlldy5pbnB1dC5sYXN0S2V5Q29kZSAhPSA0NTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgICAgICBpZiAodGFyZ2V0LnBhcmVudE5vZGUpXG4gICAgICAgICAgICB0YXJnZXQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0YXJnZXQpO1xuICAgICAgICBpZiAocGxhaW5UZXh0KVxuICAgICAgICAgICAgZG9QYXN0ZSh2aWV3LCB0YXJnZXQudmFsdWUsIG51bGwsIHBsYWluLCBldmVudCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRvUGFzdGUodmlldywgdGFyZ2V0LnRleHRDb250ZW50LCB0YXJnZXQuaW5uZXJIVE1MLCBwbGFpbiwgZXZlbnQpO1xuICAgIH0sIDUwKTtcbn1cbmZ1bmN0aW9uIGRvUGFzdGUodmlldywgdGV4dCwgaHRtbCwgcHJlZmVyUGxhaW4sIGV2ZW50KSB7XG4gICAgbGV0IHNsaWNlID0gcGFyc2VGcm9tQ2xpcGJvYXJkKHZpZXcsIHRleHQsIGh0bWwsIHByZWZlclBsYWluLCB2aWV3LnN0YXRlLnNlbGVjdGlvbi4kZnJvbSk7XG4gICAgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVQYXN0ZVwiLCBmID0+IGYodmlldywgZXZlbnQsIHNsaWNlIHx8IFNsaWNlLmVtcHR5KSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICghc2xpY2UpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgc2luZ2xlTm9kZSA9IHNsaWNlU2luZ2xlTm9kZShzbGljZSk7XG4gICAgbGV0IHRyID0gc2luZ2xlTm9kZVxuICAgICAgICA/IHZpZXcuc3RhdGUudHIucmVwbGFjZVNlbGVjdGlvbldpdGgoc2luZ2xlTm9kZSwgcHJlZmVyUGxhaW4pXG4gICAgICAgIDogdmlldy5zdGF0ZS50ci5yZXBsYWNlU2VsZWN0aW9uKHNsaWNlKTtcbiAgICB2aWV3LmRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkuc2V0TWV0YShcInBhc3RlXCIsIHRydWUpLnNldE1ldGEoXCJ1aUV2ZW50XCIsIFwicGFzdGVcIikpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0VGV4dChjbGlwYm9hcmREYXRhKSB7XG4gICAgbGV0IHRleHQgPSBjbGlwYm9hcmREYXRhLmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpIHx8IGNsaXBib2FyZERhdGEuZ2V0RGF0YShcIlRleHRcIik7XG4gICAgaWYgKHRleHQpXG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIGxldCB1cmlzID0gY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwidGV4dC91cmktbGlzdFwiKTtcbiAgICByZXR1cm4gdXJpcyA/IHVyaXMucmVwbGFjZSgvXFxyP1xcbi9nLCBcIiBcIikgOiBcIlwiO1xufVxuZWRpdEhhbmRsZXJzLnBhc3RlID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICAvLyBIYW5kbGluZyBwYXN0ZSBmcm9tIEphdmFTY3JpcHQgZHVyaW5nIGNvbXBvc2l0aW9uIGlzIHZlcnkgcG9vcmx5XG4gICAgLy8gaGFuZGxlZCBieSBicm93c2Vycywgc28gYXMgYSBkb2RneSBidXQgcHJlZmVyYWJsZSBrbHVkZ2UsIHdlIGp1c3RcbiAgICAvLyBsZXQgdGhlIGJyb3dzZXIgZG8gaXRzIG5hdGl2ZSB0aGluZyB0aGVyZSwgZXhjZXB0IG9uIEFuZHJvaWQsXG4gICAgLy8gd2hlcmUgdGhlIGVkaXRvciBpcyBhbG1vc3QgYWx3YXlzIGNvbXBvc2luZy5cbiAgICBpZiAodmlldy5jb21wb3NpbmcgJiYgIWFuZHJvaWQpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgZGF0YSA9IGJyb2tlbkNsaXBib2FyZEFQSSA/IG51bGwgOiBldmVudC5jbGlwYm9hcmREYXRhO1xuICAgIGxldCBwbGFpbiA9IHZpZXcuaW5wdXQuc2hpZnRLZXkgJiYgdmlldy5pbnB1dC5sYXN0S2V5Q29kZSAhPSA0NTtcbiAgICBpZiAoZGF0YSAmJiBkb1Bhc3RlKHZpZXcsIGdldFRleHQoZGF0YSksIGRhdGEuZ2V0RGF0YShcInRleHQvaHRtbFwiKSwgcGxhaW4sIGV2ZW50KSlcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBlbHNlXG4gICAgICAgIGNhcHR1cmVQYXN0ZSh2aWV3LCBldmVudCk7XG59O1xuY2xhc3MgRHJhZ2dpbmcge1xuICAgIGNvbnN0cnVjdG9yKHNsaWNlLCBtb3ZlLCBub2RlKSB7XG4gICAgICAgIHRoaXMuc2xpY2UgPSBzbGljZTtcbiAgICAgICAgdGhpcy5tb3ZlID0gbW92ZTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB9XG59XG5jb25zdCBkcmFnQ29weU1vZGlmaWVyID0gbWFjID8gXCJhbHRLZXlcIiA6IFwiY3RybEtleVwiO1xuZnVuY3Rpb24gZHJhZ01vdmVzKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IG1vdmVzID0gdmlldy5zb21lUHJvcChcImRyYWdDb3BpZXNcIiwgdGVzdCA9PiAhdGVzdChldmVudCkpO1xuICAgIHJldHVybiBtb3ZlcyAhPSBudWxsID8gbW92ZXMgOiAhZXZlbnRbZHJhZ0NvcHlNb2RpZmllcl07XG59XG5oYW5kbGVycy5kcmFnc3RhcnQgPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIGxldCBtb3VzZURvd24gPSB2aWV3LmlucHV0Lm1vdXNlRG93bjtcbiAgICBpZiAobW91c2VEb3duKVxuICAgICAgICBtb3VzZURvd24uZG9uZSgpO1xuICAgIGlmICghZXZlbnQuZGF0YVRyYW5zZmVyKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCBwb3MgPSBzZWwuZW1wdHkgPyBudWxsIDogdmlldy5wb3NBdENvb3JkcyhldmVudENvb3JkcyhldmVudCkpO1xuICAgIGxldCBub2RlO1xuICAgIGlmIChwb3MgJiYgcG9zLnBvcyA+PSBzZWwuZnJvbSAmJiBwb3MucG9zIDw9IChzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uID8gc2VsLnRvIC0gMSA6IHNlbC50bykpIDtcbiAgICBlbHNlIGlmIChtb3VzZURvd24gJiYgbW91c2VEb3duLm1pZ2h0RHJhZykge1xuICAgICAgICBub2RlID0gTm9kZVNlbGVjdGlvbi5jcmVhdGUodmlldy5zdGF0ZS5kb2MsIG1vdXNlRG93bi5taWdodERyYWcucG9zKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXZlbnQudGFyZ2V0ICYmIGV2ZW50LnRhcmdldC5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgIGxldCBkZXNjID0gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGV2ZW50LnRhcmdldCwgdHJ1ZSk7XG4gICAgICAgIGlmIChkZXNjICYmIGRlc2Mubm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlICYmIGRlc2MgIT0gdmlldy5kb2NWaWV3KVxuICAgICAgICAgICAgbm9kZSA9IE5vZGVTZWxlY3Rpb24uY3JlYXRlKHZpZXcuc3RhdGUuZG9jLCBkZXNjLnBvc0JlZm9yZSk7XG4gICAgfVxuICAgIGxldCBkcmFnZ2VkU2xpY2UgPSAobm9kZSB8fCB2aWV3LnN0YXRlLnNlbGVjdGlvbikuY29udGVudCgpO1xuICAgIGxldCB7IGRvbSwgdGV4dCwgc2xpY2UgfSA9IHNlcmlhbGl6ZUZvckNsaXBib2FyZCh2aWV3LCBkcmFnZ2VkU2xpY2UpO1xuICAgIC8vIFByZS0xMjAgQ2hyb21lIHZlcnNpb25zIGNsZWFyIGZpbGVzIHdoZW4gY2FsbGluZyBgY2xlYXJEYXRhYCAoIzE0NzIpXG4gICAgaWYgKCFldmVudC5kYXRhVHJhbnNmZXIuZmlsZXMubGVuZ3RoIHx8ICFjaHJvbWUgfHwgY2hyb21lX3ZlcnNpb24gPiAxMjApXG4gICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5jbGVhckRhdGEoKTtcbiAgICBldmVudC5kYXRhVHJhbnNmZXIuc2V0RGF0YShicm9rZW5DbGlwYm9hcmRBUEkgPyBcIlRleHRcIiA6IFwidGV4dC9odG1sXCIsIGRvbS5pbm5lckhUTUwpO1xuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vUHJvc2VNaXJyb3IvcHJvc2VtaXJyb3IvaXNzdWVzLzExNTZcbiAgICBldmVudC5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9IFwiY29weU1vdmVcIjtcbiAgICBpZiAoIWJyb2tlbkNsaXBib2FyZEFQSSlcbiAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIHRleHQpO1xuICAgIHZpZXcuZHJhZ2dpbmcgPSBuZXcgRHJhZ2dpbmcoc2xpY2UsIGRyYWdNb3Zlcyh2aWV3LCBldmVudCksIG5vZGUpO1xufTtcbmhhbmRsZXJzLmRyYWdlbmQgPSB2aWV3ID0+IHtcbiAgICBsZXQgZHJhZ2dpbmcgPSB2aWV3LmRyYWdnaW5nO1xuICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHZpZXcuZHJhZ2dpbmcgPT0gZHJhZ2dpbmcpXG4gICAgICAgICAgICB2aWV3LmRyYWdnaW5nID0gbnVsbDtcbiAgICB9LCA1MCk7XG59O1xuZWRpdEhhbmRsZXJzLmRyYWdvdmVyID0gZWRpdEhhbmRsZXJzLmRyYWdlbnRlciA9IChfLCBlKSA9PiBlLnByZXZlbnREZWZhdWx0KCk7XG5lZGl0SGFuZGxlcnMuZHJvcCA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGhhbmRsZURyb3AodmlldywgZXZlbnQsIHZpZXcuZHJhZ2dpbmcpO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdmlldy5kcmFnZ2luZyA9IG51bGw7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGhhbmRsZURyb3AodmlldywgZXZlbnQsIGRyYWdnaW5nKSB7XG4gICAgaWYgKCFldmVudC5kYXRhVHJhbnNmZXIpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgZXZlbnRQb3MgPSB2aWV3LnBvc0F0Q29vcmRzKGV2ZW50Q29vcmRzKGV2ZW50KSk7XG4gICAgaWYgKCFldmVudFBvcylcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCAkbW91c2UgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGV2ZW50UG9zLnBvcyk7XG4gICAgbGV0IHNsaWNlID0gZHJhZ2dpbmcgJiYgZHJhZ2dpbmcuc2xpY2U7XG4gICAgaWYgKHNsaWNlKSB7XG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJ0cmFuc2Zvcm1QYXN0ZWRcIiwgZiA9PiB7IHNsaWNlID0gZihzbGljZSwgdmlldywgZmFsc2UpOyB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNsaWNlID0gcGFyc2VGcm9tQ2xpcGJvYXJkKHZpZXcsIGdldFRleHQoZXZlbnQuZGF0YVRyYW5zZmVyKSwgYnJva2VuQ2xpcGJvYXJkQVBJID8gbnVsbCA6IGV2ZW50LmRhdGFUcmFuc2Zlci5nZXREYXRhKFwidGV4dC9odG1sXCIpLCBmYWxzZSwgJG1vdXNlKTtcbiAgICB9XG4gICAgbGV0IG1vdmUgPSAhIShkcmFnZ2luZyAmJiBkcmFnTW92ZXModmlldywgZXZlbnQpKTtcbiAgICBpZiAodmlldy5zb21lUHJvcChcImhhbmRsZURyb3BcIiwgZiA9PiBmKHZpZXcsIGV2ZW50LCBzbGljZSB8fCBTbGljZS5lbXB0eSwgbW92ZSkpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFzbGljZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgbGV0IGluc2VydFBvcyA9IHNsaWNlID8gZHJvcFBvaW50KHZpZXcuc3RhdGUuZG9jLCAkbW91c2UucG9zLCBzbGljZSkgOiAkbW91c2UucG9zO1xuICAgIGlmIChpbnNlcnRQb3MgPT0gbnVsbClcbiAgICAgICAgaW5zZXJ0UG9zID0gJG1vdXNlLnBvcztcbiAgICBsZXQgdHIgPSB2aWV3LnN0YXRlLnRyO1xuICAgIGlmIChtb3ZlKSB7XG4gICAgICAgIGxldCB7IG5vZGUgfSA9IGRyYWdnaW5nO1xuICAgICAgICBpZiAobm9kZSlcbiAgICAgICAgICAgIG5vZGUucmVwbGFjZSh0cik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRyLmRlbGV0ZVNlbGVjdGlvbigpO1xuICAgIH1cbiAgICBsZXQgcG9zID0gdHIubWFwcGluZy5tYXAoaW5zZXJ0UG9zKTtcbiAgICBsZXQgaXNOb2RlID0gc2xpY2Uub3BlblN0YXJ0ID09IDAgJiYgc2xpY2Uub3BlbkVuZCA9PSAwICYmIHNsaWNlLmNvbnRlbnQuY2hpbGRDb3VudCA9PSAxO1xuICAgIGxldCBiZWZvcmVJbnNlcnQgPSB0ci5kb2M7XG4gICAgaWYgKGlzTm9kZSlcbiAgICAgICAgdHIucmVwbGFjZVJhbmdlV2l0aChwb3MsIHBvcywgc2xpY2UuY29udGVudC5maXJzdENoaWxkKTtcbiAgICBlbHNlXG4gICAgICAgIHRyLnJlcGxhY2VSYW5nZShwb3MsIHBvcywgc2xpY2UpO1xuICAgIGlmICh0ci5kb2MuZXEoYmVmb3JlSW5zZXJ0KSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCAkcG9zID0gdHIuZG9jLnJlc29sdmUocG9zKTtcbiAgICBpZiAoaXNOb2RlICYmIE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZCkgJiZcbiAgICAgICAgJHBvcy5ub2RlQWZ0ZXIgJiYgJHBvcy5ub2RlQWZ0ZXIuc2FtZU1hcmt1cChzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQpKSB7XG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihuZXcgTm9kZVNlbGVjdGlvbigkcG9zKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgZW5kID0gdHIubWFwcGluZy5tYXAoaW5zZXJ0UG9zKTtcbiAgICAgICAgdHIubWFwcGluZy5tYXBzW3RyLm1hcHBpbmcubWFwcy5sZW5ndGggLSAxXS5mb3JFYWNoKChfZnJvbSwgX3RvLCBfbmV3RnJvbSwgbmV3VG8pID0+IGVuZCA9IG5ld1RvKTtcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbkJldHdlZW4odmlldywgJHBvcywgdHIuZG9jLnJlc29sdmUoZW5kKSkpO1xuICAgIH1cbiAgICB2aWV3LmZvY3VzKCk7XG4gICAgdmlldy5kaXNwYXRjaCh0ci5zZXRNZXRhKFwidWlFdmVudFwiLCBcImRyb3BcIikpO1xufVxuaGFuZGxlcnMuZm9jdXMgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0Lmxhc3RGb2N1cyA9IERhdGUubm93KCk7XG4gICAgaWYgKCF2aWV3LmZvY3VzZWQpIHtcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgIHZpZXcuZG9tLmNsYXNzTGlzdC5hZGQoXCJQcm9zZU1pcnJvci1mb2N1c2VkXCIpO1xuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIHZpZXcuZm9jdXNlZCA9IHRydWU7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHZpZXcuZG9jVmlldyAmJiB2aWV3Lmhhc0ZvY3VzKCkgJiYgIXZpZXcuZG9tT2JzZXJ2ZXIuY3VycmVudFNlbGVjdGlvbi5lcSh2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCkpKVxuICAgICAgICAgICAgICAgIHNlbGVjdGlvblRvRE9NKHZpZXcpO1xuICAgICAgICB9LCAyMCk7XG4gICAgfVxufTtcbmhhbmRsZXJzLmJsdXIgPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIGlmICh2aWV3LmZvY3VzZWQpIHtcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgIHZpZXcuZG9tLmNsYXNzTGlzdC5yZW1vdmUoXCJQcm9zZU1pcnJvci1mb2N1c2VkXCIpO1xuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIGlmIChldmVudC5yZWxhdGVkVGFyZ2V0ICYmIHZpZXcuZG9tLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICAgICAgdmlldy5kb21PYnNlcnZlci5jdXJyZW50U2VsZWN0aW9uLmNsZWFyKCk7XG4gICAgICAgIHZpZXcuZm9jdXNlZCA9IGZhbHNlO1xuICAgIH1cbn07XG5oYW5kbGVycy5iZWZvcmVpbnB1dCA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgLy8gV2Ugc2hvdWxkIHByb2JhYmx5IGRvIG1vcmUgd2l0aCBiZWZvcmVpbnB1dCBldmVudHMsIGJ1dCBzdXBwb3J0XG4gICAgLy8gaXMgc28gc3BvdHR5IHRoYXQgSSdtIHN0aWxsIHdhaXRpbmcgdG8gc2VlIHdoZXJlIHRoZXkgYXJlIGdvaW5nLlxuICAgIC8vIFZlcnkgc3BlY2lmaWMgaGFjayB0byBkZWFsIHdpdGggYmFja3NwYWNlIHNvbWV0aW1lcyBmYWlsaW5nIG9uXG4gICAgLy8gQ2hyb21lIEFuZHJvaWQgd2hlbiBhZnRlciBhbiB1bmVkaXRhYmxlIG5vZGUuXG4gICAgaWYgKGNocm9tZSAmJiBhbmRyb2lkICYmIGV2ZW50LmlucHV0VHlwZSA9PSBcImRlbGV0ZUNvbnRlbnRCYWNrd2FyZFwiKSB7XG4gICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuZmx1c2hTb29uKCk7XG4gICAgICAgIGxldCB7IGRvbUNoYW5nZUNvdW50IH0gPSB2aWV3LmlucHV0O1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh2aWV3LmlucHV0LmRvbUNoYW5nZUNvdW50ICE9IGRvbUNoYW5nZUNvdW50KVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gRXZlbnQgYWxyZWFkeSBoYWQgc29tZSBlZmZlY3RcbiAgICAgICAgICAgIC8vIFRoaXMgYnVnIHRlbmRzIHRvIGNsb3NlIHRoZSB2aXJ0dWFsIGtleWJvYXJkLCBzbyB3ZSByZWZvY3VzXG4gICAgICAgICAgICB2aWV3LmRvbS5ibHVyKCk7XG4gICAgICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICAgICAgICBpZiAodmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDgsIFwiQmFja3NwYWNlXCIpKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHsgJGN1cnNvciB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgICAgICAvLyBDcnVkZSBhcHByb3hpbWF0aW9uIG9mIGJhY2tzcGFjZSBiZWhhdmlvciB3aGVuIG5vIGNvbW1hbmQgaGFuZGxlZCBpdFxuICAgICAgICAgICAgaWYgKCRjdXJzb3IgJiYgJGN1cnNvci5wb3MgPiAwKVxuICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5kZWxldGUoJGN1cnNvci5wb3MgLSAxLCAkY3Vyc29yLnBvcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIH0sIDUwKTtcbiAgICB9XG59O1xuLy8gTWFrZSBzdXJlIGFsbCBoYW5kbGVycyBnZXQgcmVnaXN0ZXJlZFxuZm9yIChsZXQgcHJvcCBpbiBlZGl0SGFuZGxlcnMpXG4gICAgaGFuZGxlcnNbcHJvcF0gPSBlZGl0SGFuZGxlcnNbcHJvcF07XG5cbmZ1bmN0aW9uIGNvbXBhcmVPYmpzKGEsIGIpIHtcbiAgICBpZiAoYSA9PSBiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBmb3IgKGxldCBwIGluIGEpXG4gICAgICAgIGlmIChhW3BdICE9PSBiW3BdKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IHAgaW4gYilcbiAgICAgICAgaWYgKCEocCBpbiBhKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNsYXNzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHRvRE9NLCBzcGVjKSB7XG4gICAgICAgIHRoaXMudG9ET00gPSB0b0RPTTtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYyB8fCBub1NwZWM7XG4gICAgICAgIHRoaXMuc2lkZSA9IHRoaXMuc3BlYy5zaWRlIHx8IDA7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nLCBzcGFuLCBvZmZzZXQsIG9sZE9mZnNldCkge1xuICAgICAgICBsZXQgeyBwb3MsIGRlbGV0ZWQgfSA9IG1hcHBpbmcubWFwUmVzdWx0KHNwYW4uZnJvbSArIG9sZE9mZnNldCwgdGhpcy5zaWRlIDwgMCA/IC0xIDogMSk7XG4gICAgICAgIHJldHVybiBkZWxldGVkID8gbnVsbCA6IG5ldyBEZWNvcmF0aW9uKHBvcyAtIG9mZnNldCwgcG9zIC0gb2Zmc2V0LCB0aGlzKTtcbiAgICB9XG4gICAgdmFsaWQoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHxcbiAgICAgICAgICAgIChvdGhlciBpbnN0YW5jZW9mIFdpZGdldFR5cGUgJiZcbiAgICAgICAgICAgICAgICAodGhpcy5zcGVjLmtleSAmJiB0aGlzLnNwZWMua2V5ID09IG90aGVyLnNwZWMua2V5IHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9ET00gPT0gb3RoZXIudG9ET00gJiYgY29tcGFyZU9ianModGhpcy5zcGVjLCBvdGhlci5zcGVjKSkpO1xuICAgIH1cbiAgICBkZXN0cm95KG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuc3BlYy5kZXN0cm95KVxuICAgICAgICAgICAgdGhpcy5zcGVjLmRlc3Ryb3kobm9kZSk7XG4gICAgfVxufVxuY2xhc3MgSW5saW5lVHlwZSB7XG4gICAgY29uc3RydWN0b3IoYXR0cnMsIHNwZWMpIHtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjIHx8IG5vU3BlYztcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcsIHNwYW4sIG9mZnNldCwgb2xkT2Zmc2V0KSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXAoc3Bhbi5mcm9tICsgb2xkT2Zmc2V0LCB0aGlzLnNwZWMuaW5jbHVzaXZlU3RhcnQgPyAtMSA6IDEpIC0gb2Zmc2V0O1xuICAgICAgICBsZXQgdG8gPSBtYXBwaW5nLm1hcChzcGFuLnRvICsgb2xkT2Zmc2V0LCB0aGlzLnNwZWMuaW5jbHVzaXZlRW5kID8gMSA6IC0xKSAtIG9mZnNldDtcbiAgICAgICAgcmV0dXJuIGZyb20gPj0gdG8gPyBudWxsIDogbmV3IERlY29yYXRpb24oZnJvbSwgdG8sIHRoaXMpO1xuICAgIH1cbiAgICB2YWxpZChfLCBzcGFuKSB7IHJldHVybiBzcGFuLmZyb20gPCBzcGFuLnRvOyB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHxcbiAgICAgICAgICAgIChvdGhlciBpbnN0YW5jZW9mIElubGluZVR5cGUgJiYgY29tcGFyZU9ianModGhpcy5hdHRycywgb3RoZXIuYXR0cnMpICYmXG4gICAgICAgICAgICAgICAgY29tcGFyZU9ianModGhpcy5zcGVjLCBvdGhlci5zcGVjKSk7XG4gICAgfVxuICAgIHN0YXRpYyBpcyhzcGFuKSB7IHJldHVybiBzcGFuLnR5cGUgaW5zdGFuY2VvZiBJbmxpbmVUeXBlOyB9XG4gICAgZGVzdHJveSgpIHsgfVxufVxuY2xhc3MgTm9kZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGF0dHJzLCBzcGVjKSB7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYyB8fCBub1NwZWM7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nLCBzcGFuLCBvZmZzZXQsIG9sZE9mZnNldCkge1xuICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwUmVzdWx0KHNwYW4uZnJvbSArIG9sZE9mZnNldCwgMSk7XG4gICAgICAgIGlmIChmcm9tLmRlbGV0ZWQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHRvID0gbWFwcGluZy5tYXBSZXN1bHQoc3Bhbi50byArIG9sZE9mZnNldCwgLTEpO1xuICAgICAgICBpZiAodG8uZGVsZXRlZCB8fCB0by5wb3MgPD0gZnJvbS5wb3MpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKGZyb20ucG9zIC0gb2Zmc2V0LCB0by5wb3MgLSBvZmZzZXQsIHRoaXMpO1xuICAgIH1cbiAgICB2YWxpZChub2RlLCBzcGFuKSB7XG4gICAgICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IG5vZGUuY29udGVudC5maW5kSW5kZXgoc3Bhbi5mcm9tKSwgY2hpbGQ7XG4gICAgICAgIHJldHVybiBvZmZzZXQgPT0gc3Bhbi5mcm9tICYmICEoY2hpbGQgPSBub2RlLmNoaWxkKGluZGV4KSkuaXNUZXh0ICYmIG9mZnNldCArIGNoaWxkLm5vZGVTaXplID09IHNwYW4udG87XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8XG4gICAgICAgICAgICAob3RoZXIgaW5zdGFuY2VvZiBOb2RlVHlwZSAmJiBjb21wYXJlT2Jqcyh0aGlzLmF0dHJzLCBvdGhlci5hdHRycykgJiZcbiAgICAgICAgICAgICAgICBjb21wYXJlT2Jqcyh0aGlzLnNwZWMsIG90aGVyLnNwZWMpKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHsgfVxufVxuLyoqXG5EZWNvcmF0aW9uIG9iamVjdHMgY2FuIGJlIHByb3ZpZGVkIHRvIHRoZSB2aWV3IHRocm91Z2ggdGhlXG5bYGRlY29yYXRpb25zYCBwcm9wXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JQcm9wcy5kZWNvcmF0aW9ucykuIFRoZXkgY29tZSBpblxuc2V2ZXJhbCB2YXJpYW50c+KAlHNlZSB0aGUgc3RhdGljIG1lbWJlcnMgb2YgdGhpcyBjbGFzcyBmb3IgZGV0YWlscy5cbiovXG5jbGFzcyBEZWNvcmF0aW9uIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgZGVjb3JhdGlvbi5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgcG9zaXRpb24uIFdpbGwgYmUgdGhlIHNhbWUgYXMgYGZyb21gIGZvciBbd2lkZ2V0XG4gICAgZGVjb3JhdGlvbnNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb25ed2lkZ2V0KS5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHR5cGUpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvcHkoZnJvbSwgdG8pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKGZyb20sIHRvLCB0aGlzLnR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGVxKG90aGVyLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUuZXEob3RoZXIudHlwZSkgJiYgdGhpcy5mcm9tICsgb2Zmc2V0ID09IG90aGVyLmZyb20gJiYgdGhpcy50byArIG9mZnNldCA9PSBvdGhlci50bztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtYXAobWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5tYXAobWFwcGluZywgdGhpcywgb2Zmc2V0LCBvbGRPZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGVzIGEgd2lkZ2V0IGRlY29yYXRpb24sIHdoaWNoIGlzIGEgRE9NIG5vZGUgdGhhdCdzIHNob3duIGluXG4gICAgdGhlIGRvY3VtZW50IGF0IHRoZSBnaXZlbiBwb3NpdGlvbi4gSXQgaXMgcmVjb21tZW5kZWQgdGhhdCB5b3VcbiAgICBkZWxheSByZW5kZXJpbmcgdGhlIHdpZGdldCBieSBwYXNzaW5nIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlXG4gICAgY2FsbGVkIHdoZW4gdGhlIHdpZGdldCBpcyBhY3R1YWxseSBkcmF3biBpbiBhIHZpZXcsIGJ1dCB5b3UgY2FuXG4gICAgYWxzbyBkaXJlY3RseSBwYXNzIGEgRE9NIG5vZGUuIGBnZXRQb3NgIGNhbiBiZSB1c2VkIHRvIGZpbmQgdGhlXG4gICAgd2lkZ2V0J3MgY3VycmVudCBkb2N1bWVudCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyB3aWRnZXQocG9zLCB0b0RPTSwgc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IERlY29yYXRpb24ocG9zLCBwb3MsIG5ldyBXaWRnZXRUeXBlKHRvRE9NLCBzcGVjKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZXMgYW4gaW5saW5lIGRlY29yYXRpb24sIHdoaWNoIGFkZHMgdGhlIGdpdmVuIGF0dHJpYnV0ZXMgdG9cbiAgICBlYWNoIGlubGluZSBub2RlIGJldHdlZW4gYGZyb21gIGFuZCBgdG9gLlxuICAgICovXG4gICAgc3RhdGljIGlubGluZShmcm9tLCB0bywgYXR0cnMsIHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKGZyb20sIHRvLCBuZXcgSW5saW5lVHlwZShhdHRycywgc3BlYykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGVzIGEgbm9kZSBkZWNvcmF0aW9uLiBgZnJvbWAgYW5kIGB0b2Agc2hvdWxkIHBvaW50IHByZWNpc2VseVxuICAgIGJlZm9yZSBhbmQgYWZ0ZXIgYSBub2RlIGluIHRoZSBkb2N1bWVudC4gVGhhdCBub2RlLCBhbmQgb25seSB0aGF0XG4gICAgbm9kZSwgd2lsbCByZWNlaXZlIHRoZSBnaXZlbiBhdHRyaWJ1dGVzLlxuICAgICovXG4gICAgc3RhdGljIG5vZGUoZnJvbSwgdG8sIGF0dHJzLCBzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVjb3JhdGlvbihmcm9tLCB0bywgbmV3IE5vZGVUeXBlKGF0dHJzLCBzcGVjKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzcGVjIHByb3ZpZGVkIHdoZW4gY3JlYXRpbmcgdGhpcyBkZWNvcmF0aW9uLiBDYW4gYmUgdXNlZnVsXG4gICAgaWYgeW91J3ZlIHN0b3JlZCBleHRyYSBpbmZvcm1hdGlvbiBpbiB0aGF0IG9iamVjdC5cbiAgICAqL1xuICAgIGdldCBzcGVjKCkgeyByZXR1cm4gdGhpcy50eXBlLnNwZWM7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBpbmxpbmUoKSB7IHJldHVybiB0aGlzLnR5cGUgaW5zdGFuY2VvZiBJbmxpbmVUeXBlOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgd2lkZ2V0KCkgeyByZXR1cm4gdGhpcy50eXBlIGluc3RhbmNlb2YgV2lkZ2V0VHlwZTsgfVxufVxuY29uc3Qgbm9uZSA9IFtdLCBub1NwZWMgPSB7fTtcbi8qKlxuQSBjb2xsZWN0aW9uIG9mIFtkZWNvcmF0aW9uc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvbiksIG9yZ2FuaXplZCBpbiBzdWNoXG5hIHdheSB0aGF0IHRoZSBkcmF3aW5nIGFsZ29yaXRobSBjYW4gZWZmaWNpZW50bHkgdXNlIGFuZCBjb21wYXJlXG50aGVtLiBUaGlzIGlzIGEgcGVyc2lzdGVudCBkYXRhIHN0cnVjdHVyZeKAlGl0IGlzIG5vdCBtb2RpZmllZCxcbnVwZGF0ZXMgY3JlYXRlIGEgbmV3IHZhbHVlLlxuKi9cbmNsYXNzIERlY29yYXRpb25TZXQge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IobG9jYWwsIGNoaWxkcmVuKSB7XG4gICAgICAgIHRoaXMubG9jYWwgPSBsb2NhbC5sZW5ndGggPyBsb2NhbCA6IG5vbmU7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbi5sZW5ndGggPyBjaGlsZHJlbiA6IG5vbmU7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNldCBvZiBkZWNvcmF0aW9ucywgdXNpbmcgdGhlIHN0cnVjdHVyZSBvZiB0aGUgZ2l2ZW5cbiAgICBkb2N1bWVudC4gVGhpcyB3aWxsIGNvbnN1bWUgKG1vZGlmeSkgdGhlIGBkZWNvcmF0aW9uc2AgYXJyYXksIHNvXG4gICAgeW91IG11c3QgbWFrZSBhIGNvcHkgaWYgeW91IHdhbnQgbmVlZCB0byBwcmVzZXJ2ZSB0aGF0LlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShkb2MsIGRlY29yYXRpb25zKSB7XG4gICAgICAgIHJldHVybiBkZWNvcmF0aW9ucy5sZW5ndGggPyBidWlsZFRyZWUoZGVjb3JhdGlvbnMsIGRvYywgMCwgbm9TcGVjKSA6IGVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIGFsbCBkZWNvcmF0aW9ucyBpbiB0aGlzIHNldCB3aGljaCB0b3VjaCB0aGUgZ2l2ZW4gcmFuZ2VcbiAgICAoaW5jbHVkaW5nIGRlY29yYXRpb25zIHRoYXQgc3RhcnQgb3IgZW5kIGRpcmVjdGx5IGF0IHRoZVxuICAgIGJvdW5kYXJpZXMpIGFuZCBtYXRjaCB0aGUgZ2l2ZW4gcHJlZGljYXRlIG9uIHRoZWlyIHNwZWMuIFdoZW5cbiAgICBgc3RhcnRgIGFuZCBgZW5kYCBhcmUgb21pdHRlZCwgYWxsIGRlY29yYXRpb25zIGluIHRoZSBzZXQgYXJlXG4gICAgY29uc2lkZXJlZC4gV2hlbiBgcHJlZGljYXRlYCBpc24ndCBnaXZlbiwgYWxsIGRlY29yYXRpb25zIGFyZVxuICAgIGFzc3VtZWQgdG8gbWF0Y2guXG4gICAgKi9cbiAgICBmaW5kKHN0YXJ0LCBlbmQsIHByZWRpY2F0ZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIHRoaXMuZmluZElubmVyKHN0YXJ0ID09IG51bGwgPyAwIDogc3RhcnQsIGVuZCA9PSBudWxsID8gMWU5IDogZW5kLCByZXN1bHQsIDAsIHByZWRpY2F0ZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZpbmRJbm5lcihzdGFydCwgZW5kLCByZXN1bHQsIG9mZnNldCwgcHJlZGljYXRlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sb2NhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHNwYW4gPSB0aGlzLmxvY2FsW2ldO1xuICAgICAgICAgICAgaWYgKHNwYW4uZnJvbSA8PSBlbmQgJiYgc3Bhbi50byA+PSBzdGFydCAmJiAoIXByZWRpY2F0ZSB8fCBwcmVkaWNhdGUoc3Bhbi5zcGVjKSkpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3Bhbi5jb3B5KHNwYW4uZnJvbSArIG9mZnNldCwgc3Bhbi50byArIG9mZnNldCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0gPCBlbmQgJiYgdGhpcy5jaGlsZHJlbltpICsgMV0gPiBzdGFydCkge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZE9mZiA9IHRoaXMuY2hpbGRyZW5baV0gKyAxO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baSArIDJdLmZpbmRJbm5lcihzdGFydCAtIGNoaWxkT2ZmLCBlbmQgLSBjaGlsZE9mZiwgcmVzdWx0LCBvZmZzZXQgKyBjaGlsZE9mZiwgcHJlZGljYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBNYXAgdGhlIHNldCBvZiBkZWNvcmF0aW9ucyBpbiByZXNwb25zZSB0byBhIGNoYW5nZSBpbiB0aGVcbiAgICBkb2N1bWVudC5cbiAgICAqL1xuICAgIG1hcChtYXBwaW5nLCBkb2MsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMgPT0gZW1wdHkgfHwgbWFwcGluZy5tYXBzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcElubmVyKG1hcHBpbmcsIGRvYywgMCwgMCwgb3B0aW9ucyB8fCBub1NwZWMpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1hcElubmVyKG1hcHBpbmcsIG5vZGUsIG9mZnNldCwgb2xkT2Zmc2V0LCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBuZXdMb2NhbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFwcGVkID0gdGhpcy5sb2NhbFtpXS5tYXAobWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQpO1xuICAgICAgICAgICAgaWYgKG1hcHBlZCAmJiBtYXBwZWQudHlwZS52YWxpZChub2RlLCBtYXBwZWQpKVxuICAgICAgICAgICAgICAgIChuZXdMb2NhbCB8fCAobmV3TG9jYWwgPSBbXSkpLnB1c2gobWFwcGVkKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMub25SZW1vdmUpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vblJlbW92ZSh0aGlzLmxvY2FsW2ldLnNwZWMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBtYXBDaGlsZHJlbih0aGlzLmNoaWxkcmVuLCBuZXdMb2NhbCB8fCBbXSwgbWFwcGluZywgbm9kZSwgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbmV3TG9jYWwgPyBuZXcgRGVjb3JhdGlvblNldChuZXdMb2NhbC5zb3J0KGJ5UG9zKSwgbm9uZSkgOiBlbXB0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIHRoZSBnaXZlbiBhcnJheSBvZiBkZWNvcmF0aW9ucyB0byB0aGUgb25lcyBpbiB0aGUgc2V0LFxuICAgIHByb2R1Y2luZyBhIG5ldyBzZXQuIENvbnN1bWVzIHRoZSBgZGVjb3JhdGlvbnNgIGFycmF5LiBOZWVkc1xuICAgIGFjY2VzcyB0byB0aGUgY3VycmVudCBkb2N1bWVudCB0byBjcmVhdGUgdGhlIGFwcHJvcHJpYXRlIHRyZWVcbiAgICBzdHJ1Y3R1cmUuXG4gICAgKi9cbiAgICBhZGQoZG9jLCBkZWNvcmF0aW9ucykge1xuICAgICAgICBpZiAoIWRlY29yYXRpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAodGhpcyA9PSBlbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShkb2MsIGRlY29yYXRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkSW5uZXIoZG9jLCBkZWNvcmF0aW9ucywgMCk7XG4gICAgfVxuICAgIGFkZElubmVyKGRvYywgZGVjb3JhdGlvbnMsIG9mZnNldCkge1xuICAgICAgICBsZXQgY2hpbGRyZW4sIGNoaWxkSW5kZXggPSAwO1xuICAgICAgICBkb2MuZm9yRWFjaCgoY2hpbGROb2RlLCBjaGlsZE9mZnNldCkgPT4ge1xuICAgICAgICAgICAgbGV0IGJhc2VPZmZzZXQgPSBjaGlsZE9mZnNldCArIG9mZnNldCwgZm91bmQ7XG4gICAgICAgICAgICBpZiAoIShmb3VuZCA9IHRha2VTcGFuc0Zvck5vZGUoZGVjb3JhdGlvbnMsIGNoaWxkTm9kZSwgYmFzZU9mZnNldCkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICghY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLnNsaWNlKCk7XG4gICAgICAgICAgICB3aGlsZSAoY2hpbGRJbmRleCA8IGNoaWxkcmVuLmxlbmd0aCAmJiBjaGlsZHJlbltjaGlsZEluZGV4XSA8IGNoaWxkT2Zmc2V0KVxuICAgICAgICAgICAgICAgIGNoaWxkSW5kZXggKz0gMztcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbltjaGlsZEluZGV4XSA9PSBjaGlsZE9mZnNldClcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltjaGlsZEluZGV4ICsgMl0gPSBjaGlsZHJlbltjaGlsZEluZGV4ICsgMl0uYWRkSW5uZXIoY2hpbGROb2RlLCBmb3VuZCwgYmFzZU9mZnNldCArIDEpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShjaGlsZEluZGV4LCAwLCBjaGlsZE9mZnNldCwgY2hpbGRPZmZzZXQgKyBjaGlsZE5vZGUubm9kZVNpemUsIGJ1aWxkVHJlZShmb3VuZCwgY2hpbGROb2RlLCBiYXNlT2Zmc2V0ICsgMSwgbm9TcGVjKSk7XG4gICAgICAgICAgICBjaGlsZEluZGV4ICs9IDM7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbG9jYWwgPSBtb3ZlU3BhbnMoY2hpbGRJbmRleCA/IHdpdGhvdXROdWxscyhkZWNvcmF0aW9ucykgOiBkZWNvcmF0aW9ucywgLW9mZnNldCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWwubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIWxvY2FsW2ldLnR5cGUudmFsaWQoZG9jLCBsb2NhbFtpXSkpXG4gICAgICAgICAgICAgICAgbG9jYWwuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgIHJldHVybiBuZXcgRGVjb3JhdGlvblNldChsb2NhbC5sZW5ndGggPyB0aGlzLmxvY2FsLmNvbmNhdChsb2NhbCkuc29ydChieVBvcykgOiB0aGlzLmxvY2FsLCBjaGlsZHJlbiB8fCB0aGlzLmNoaWxkcmVuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IHNldCB0aGF0IGNvbnRhaW5zIHRoZSBkZWNvcmF0aW9ucyBpbiB0aGlzIHNldCwgbWludXNcbiAgICB0aGUgb25lcyBpbiB0aGUgZ2l2ZW4gYXJyYXkuXG4gICAgKi9cbiAgICByZW1vdmUoZGVjb3JhdGlvbnMpIHtcbiAgICAgICAgaWYgKGRlY29yYXRpb25zLmxlbmd0aCA9PSAwIHx8IHRoaXMgPT0gZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlSW5uZXIoZGVjb3JhdGlvbnMsIDApO1xuICAgIH1cbiAgICByZW1vdmVJbm5lcihkZWNvcmF0aW9ucywgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4sIGxvY2FsID0gdGhpcy5sb2NhbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgbGV0IGZvdW5kO1xuICAgICAgICAgICAgbGV0IGZyb20gPSBjaGlsZHJlbltpXSArIG9mZnNldCwgdG8gPSBjaGlsZHJlbltpICsgMV0gKyBvZmZzZXQ7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgc3BhbjsgaiA8IGRlY29yYXRpb25zLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgIGlmIChzcGFuID0gZGVjb3JhdGlvbnNbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwYW4uZnJvbSA+IGZyb20gJiYgc3Bhbi50byA8IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvcmF0aW9uc1tqXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAoZm91bmQgfHwgKGZvdW5kID0gW10pKS5wdXNoKHNwYW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbiA9PSB0aGlzLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi5zbGljZSgpO1xuICAgICAgICAgICAgbGV0IHJlbW92ZWQgPSBjaGlsZHJlbltpICsgMl0ucmVtb3ZlSW5uZXIoZm91bmQsIGZyb20gKyAxKTtcbiAgICAgICAgICAgIGlmIChyZW1vdmVkICE9IGVtcHR5KSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDJdID0gcmVtb3ZlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShpLCAzKTtcbiAgICAgICAgICAgICAgICBpIC09IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsLmxlbmd0aClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBzcGFuOyBpIDwgZGVjb3JhdGlvbnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKHNwYW4gPSBkZWNvcmF0aW9uc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxvY2FsLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsW2pdLmVxKHNwYW4sIG9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWwgPT0gdGhpcy5sb2NhbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWwgPSB0aGlzLmxvY2FsLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWwuc3BsaWNlKGotLSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRyZW4gPT0gdGhpcy5jaGlsZHJlbiAmJiBsb2NhbCA9PSB0aGlzLmxvY2FsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBsb2NhbC5sZW5ndGggfHwgY2hpbGRyZW4ubGVuZ3RoID8gbmV3IERlY29yYXRpb25TZXQobG9jYWwsIGNoaWxkcmVuKSA6IGVtcHR5O1xuICAgIH1cbiAgICBmb3JDaGlsZChvZmZzZXQsIG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMgPT0gZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKG5vZGUuaXNMZWFmKVxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb25TZXQuZW1wdHk7XG4gICAgICAgIGxldCBjaGlsZCwgbG9jYWw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldID49IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldID09IG9mZnNldClcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2kgKyAyXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0ID0gb2Zmc2V0ICsgMSwgZW5kID0gc3RhcnQgKyBub2RlLmNvbnRlbnQuc2l6ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZGVjID0gdGhpcy5sb2NhbFtpXTtcbiAgICAgICAgICAgIGlmIChkZWMuZnJvbSA8IGVuZCAmJiBkZWMudG8gPiBzdGFydCAmJiAoZGVjLnR5cGUgaW5zdGFuY2VvZiBJbmxpbmVUeXBlKSkge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gTWF0aC5tYXgoc3RhcnQsIGRlYy5mcm9tKSAtIHN0YXJ0LCB0byA9IE1hdGgubWluKGVuZCwgZGVjLnRvKSAtIHN0YXJ0O1xuICAgICAgICAgICAgICAgIGlmIChmcm9tIDwgdG8pXG4gICAgICAgICAgICAgICAgICAgIChsb2NhbCB8fCAobG9jYWwgPSBbXSkpLnB1c2goZGVjLmNvcHkoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobG9jYWwpIHtcbiAgICAgICAgICAgIGxldCBsb2NhbFNldCA9IG5ldyBEZWNvcmF0aW9uU2V0KGxvY2FsLnNvcnQoYnlQb3MpLCBub25lKTtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZCA/IG5ldyBEZWNvcmF0aW9uR3JvdXAoW2xvY2FsU2V0LCBjaGlsZF0pIDogbG9jYWxTZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkIHx8IGVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzID09IG90aGVyKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgRGVjb3JhdGlvblNldCkgfHxcbiAgICAgICAgICAgIHRoaXMubG9jYWwubGVuZ3RoICE9IG90aGVyLmxvY2FsLmxlbmd0aCB8fFxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5sZW5ndGggIT0gb3RoZXIuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubG9jYWwubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIXRoaXMubG9jYWxbaV0uZXEob3RoZXIubG9jYWxbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0gIT0gb3RoZXIuY2hpbGRyZW5baV0gfHxcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2kgKyAxXSAhPSBvdGhlci5jaGlsZHJlbltpICsgMV0gfHxcbiAgICAgICAgICAgICAgICAhdGhpcy5jaGlsZHJlbltpICsgMl0uZXEob3RoZXIuY2hpbGRyZW5baSArIDJdKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGxvY2Fscyhub2RlKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVPdmVybGFwKHRoaXMubG9jYWxzSW5uZXIobm9kZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGxvY2Fsc0lubmVyKG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMgPT0gZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gbm9uZTtcbiAgICAgICAgaWYgKG5vZGUuaW5saW5lQ29udGVudCB8fCAhdGhpcy5sb2NhbC5zb21lKElubGluZVR5cGUuaXMpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWw7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzLmxvY2FsW2ldLnR5cGUgaW5zdGFuY2VvZiBJbmxpbmVUeXBlKSlcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmxvY2FsW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmb3JFYWNoU2V0KGYpIHsgZih0aGlzKTsgfVxufVxuLyoqXG5UaGUgZW1wdHkgc2V0IG9mIGRlY29yYXRpb25zLlxuKi9cbkRlY29yYXRpb25TZXQuZW1wdHkgPSBuZXcgRGVjb3JhdGlvblNldChbXSwgW10pO1xuLyoqXG5AaW50ZXJuYWxcbiovXG5EZWNvcmF0aW9uU2V0LnJlbW92ZU92ZXJsYXAgPSByZW1vdmVPdmVybGFwO1xuY29uc3QgZW1wdHkgPSBEZWNvcmF0aW9uU2V0LmVtcHR5O1xuLy8gQW4gYWJzdHJhY3Rpb24gdGhhdCBhbGxvd3MgdGhlIGNvZGUgZGVhbGluZyB3aXRoIGRlY29yYXRpb25zIHRvXG4vLyB0cmVhdCBtdWx0aXBsZSBEZWNvcmF0aW9uU2V0IG9iamVjdHMgYXMgaWYgaXQgd2VyZSBhIHNpbmdsZSBvYmplY3Rcbi8vIHdpdGggKGEgc3Vic2V0IG9mKSB0aGUgc2FtZSBpbnRlcmZhY2UuXG5jbGFzcyBEZWNvcmF0aW9uR3JvdXAge1xuICAgIGNvbnN0cnVjdG9yKG1lbWJlcnMpIHtcbiAgICAgICAgdGhpcy5tZW1iZXJzID0gbWVtYmVycztcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcsIGRvYykge1xuICAgICAgICBjb25zdCBtYXBwZWREZWNvcyA9IHRoaXMubWVtYmVycy5tYXAobWVtYmVyID0+IG1lbWJlci5tYXAobWFwcGluZywgZG9jLCBub1NwZWMpKTtcbiAgICAgICAgcmV0dXJuIERlY29yYXRpb25Hcm91cC5mcm9tKG1hcHBlZERlY29zKTtcbiAgICB9XG4gICAgZm9yQ2hpbGQob2Zmc2V0LCBjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQuaXNMZWFmKVxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb25TZXQuZW1wdHk7XG4gICAgICAgIGxldCBmb3VuZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWVtYmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMubWVtYmVyc1tpXS5mb3JDaGlsZChvZmZzZXQsIGNoaWxkKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gZW1wdHkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRGVjb3JhdGlvbkdyb3VwKVxuICAgICAgICAgICAgICAgIGZvdW5kID0gZm91bmQuY29uY2F0KHJlc3VsdC5tZW1iZXJzKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBmb3VuZC5wdXNoKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERlY29yYXRpb25Hcm91cC5mcm9tKGZvdW5kKTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBEZWNvcmF0aW9uR3JvdXApIHx8XG4gICAgICAgICAgICBvdGhlci5tZW1iZXJzLmxlbmd0aCAhPSB0aGlzLm1lbWJlcnMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWVtYmVycy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy5tZW1iZXJzW2ldLmVxKG90aGVyLm1lbWJlcnNbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxvY2Fscyhub2RlKSB7XG4gICAgICAgIGxldCByZXN1bHQsIHNvcnRlZCA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tZW1iZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbG9jYWxzID0gdGhpcy5tZW1iZXJzW2ldLmxvY2Fsc0lubmVyKG5vZGUpO1xuICAgICAgICAgICAgaWYgKCFsb2NhbHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBsb2NhbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc29ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICBzb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsb2NhbHMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxvY2Fsc1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCA/IHJlbW92ZU92ZXJsYXAoc29ydGVkID8gcmVzdWx0IDogcmVzdWx0LnNvcnQoYnlQb3MpKSA6IG5vbmU7XG4gICAgfVxuICAgIC8vIENyZWF0ZSBhIGdyb3VwIGZvciB0aGUgZ2l2ZW4gYXJyYXkgb2YgZGVjb3JhdGlvbiBzZXRzLCBvciByZXR1cm5cbiAgICAvLyBhIHNpbmdsZSBzZXQgd2hlbiBwb3NzaWJsZS5cbiAgICBzdGF0aWMgZnJvbShtZW1iZXJzKSB7XG4gICAgICAgIHN3aXRjaCAobWVtYmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIGVtcHR5O1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbWVtYmVyc1swXTtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBuZXcgRGVjb3JhdGlvbkdyb3VwKG1lbWJlcnMuZXZlcnkobSA9PiBtIGluc3RhbmNlb2YgRGVjb3JhdGlvblNldCkgPyBtZW1iZXJzIDpcbiAgICAgICAgICAgICAgICBtZW1iZXJzLnJlZHVjZSgociwgbSkgPT4gci5jb25jYXQobSBpbnN0YW5jZW9mIERlY29yYXRpb25TZXQgPyBtIDogbS5tZW1iZXJzKSwgW10pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3JFYWNoU2V0KGYpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1lbWJlcnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0aGlzLm1lbWJlcnNbaV0uZm9yRWFjaFNldChmKTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYXBDaGlsZHJlbihvbGRDaGlsZHJlbiwgbmV3TG9jYWwsIG1hcHBpbmcsIG5vZGUsIG9mZnNldCwgb2xkT2Zmc2V0LCBvcHRpb25zKSB7XG4gICAgbGV0IGNoaWxkcmVuID0gb2xkQ2hpbGRyZW4uc2xpY2UoKTtcbiAgICAvLyBNYXJrIHRoZSBjaGlsZHJlbiB0aGF0IGFyZSBkaXJlY3RseSB0b3VjaGVkIGJ5IGNoYW5nZXMsIGFuZFxuICAgIC8vIG1vdmUgdGhvc2UgdGhhdCBhcmUgYWZ0ZXIgdGhlIGNoYW5nZXMuXG4gICAgZm9yIChsZXQgaSA9IDAsIGJhc2VPZmZzZXQgPSBvbGRPZmZzZXQ7IGkgPCBtYXBwaW5nLm1hcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG1vdmVkID0gMDtcbiAgICAgICAgbWFwcGluZy5tYXBzW2ldLmZvckVhY2goKG9sZFN0YXJ0LCBvbGRFbmQsIG5ld1N0YXJ0LCBuZXdFbmQpID0+IHtcbiAgICAgICAgICAgIGxldCBkU2l6ZSA9IChuZXdFbmQgLSBuZXdTdGFydCkgLSAob2xkRW5kIC0gb2xkU3RhcnQpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgICAgIGxldCBlbmQgPSBjaGlsZHJlbltpICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKGVuZCA8IDAgfHwgb2xkU3RhcnQgPiBlbmQgKyBiYXNlT2Zmc2V0IC0gbW92ZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IGNoaWxkcmVuW2ldICsgYmFzZU9mZnNldCAtIG1vdmVkO1xuICAgICAgICAgICAgICAgIGlmIChvbGRFbmQgPj0gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDFdID0gb2xkU3RhcnQgPD0gc3RhcnQgPyAtMiA6IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvbGRTdGFydCA+PSBiYXNlT2Zmc2V0ICYmIGRTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2ldICs9IGRTaXplO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpICsgMV0gKz0gZFNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW92ZWQgKz0gZFNpemU7XG4gICAgICAgIH0pO1xuICAgICAgICBiYXNlT2Zmc2V0ID0gbWFwcGluZy5tYXBzW2ldLm1hcChiYXNlT2Zmc2V0LCAtMSk7XG4gICAgfVxuICAgIC8vIEZpbmQgdGhlIGNoaWxkIG5vZGVzIHRoYXQgc3RpbGwgY29ycmVzcG9uZCB0byBhIHNpbmdsZSBub2RlLFxuICAgIC8vIHJlY3Vyc2l2ZWx5IGNhbGwgbWFwSW5uZXIgb24gdGhlbSBhbmQgdXBkYXRlIHRoZWlyIHBvc2l0aW9ucy5cbiAgICBsZXQgbXVzdFJlYnVpbGQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICBpZiAoY2hpbGRyZW5baSArIDFdIDwgMCkgeyAvLyBUb3VjaGVkIG5vZGVzXG4gICAgICAgICAgICBpZiAoY2hpbGRyZW5baSArIDFdID09IC0yKSB7XG4gICAgICAgICAgICAgICAgbXVzdFJlYnVpbGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuW2kgKyAxXSA9IC0xO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcChvbGRDaGlsZHJlbltpXSArIG9sZE9mZnNldCksIGZyb21Mb2NhbCA9IGZyb20gLSBvZmZzZXQ7XG4gICAgICAgICAgICBpZiAoZnJvbUxvY2FsIDwgMCB8fCBmcm9tTG9jYWwgPj0gbm9kZS5jb250ZW50LnNpemUpIHtcbiAgICAgICAgICAgICAgICBtdXN0UmVidWlsZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNdXN0IHJlYWQgb2xkQ2hpbGRyZW4gYmVjYXVzZSBjaGlsZHJlbiB3YXMgdGFnZ2VkIHdpdGggLTFcbiAgICAgICAgICAgIGxldCB0byA9IG1hcHBpbmcubWFwKG9sZENoaWxkcmVuW2kgKyAxXSArIG9sZE9mZnNldCwgLTEpLCB0b0xvY2FsID0gdG8gLSBvZmZzZXQ7XG4gICAgICAgICAgICBsZXQgeyBpbmRleCwgb2Zmc2V0OiBjaGlsZE9mZnNldCB9ID0gbm9kZS5jb250ZW50LmZpbmRJbmRleChmcm9tTG9jYWwpO1xuICAgICAgICAgICAgbGV0IGNoaWxkTm9kZSA9IG5vZGUubWF5YmVDaGlsZChpbmRleCk7XG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlICYmIGNoaWxkT2Zmc2V0ID09IGZyb21Mb2NhbCAmJiBjaGlsZE9mZnNldCArIGNoaWxkTm9kZS5ub2RlU2l6ZSA9PSB0b0xvY2FsKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hcHBlZCA9IGNoaWxkcmVuW2kgKyAyXVxuICAgICAgICAgICAgICAgICAgICAubWFwSW5uZXIobWFwcGluZywgY2hpbGROb2RlLCBmcm9tICsgMSwgb2xkQ2hpbGRyZW5baV0gKyBvbGRPZmZzZXQgKyAxLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAobWFwcGVkICE9IGVtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2ldID0gZnJvbUxvY2FsO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpICsgMV0gPSB0b0xvY2FsO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpICsgMl0gPSBtYXBwZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpICsgMV0gPSAtMjtcbiAgICAgICAgICAgICAgICAgICAgbXVzdFJlYnVpbGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG11c3RSZWJ1aWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIC8vIFJlbWFpbmluZyBjaGlsZHJlbiBtdXN0IGJlIGNvbGxlY3RlZCBhbmQgcmVidWlsdCBpbnRvIHRoZSBhcHByb3ByaWF0ZSBzdHJ1Y3R1cmVcbiAgICBpZiAobXVzdFJlYnVpbGQpIHtcbiAgICAgICAgbGV0IGRlY29yYXRpb25zID0gbWFwQW5kR2F0aGVyUmVtYWluaW5nRGVjb3JhdGlvbnMoY2hpbGRyZW4sIG9sZENoaWxkcmVuLCBuZXdMb2NhbCwgbWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpO1xuICAgICAgICBsZXQgYnVpbHQgPSBidWlsZFRyZWUoZGVjb3JhdGlvbnMsIG5vZGUsIDAsIG9wdGlvbnMpO1xuICAgICAgICBuZXdMb2NhbCA9IGJ1aWx0LmxvY2FsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2kgKyAxXSA8IDApIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaSwgMyk7XG4gICAgICAgICAgICAgICAgaSAtPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCBidWlsdC5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBidWlsdC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIHdoaWxlIChqIDwgY2hpbGRyZW4ubGVuZ3RoICYmIGNoaWxkcmVuW2pdIDwgZnJvbSlcbiAgICAgICAgICAgICAgICBqICs9IDM7XG4gICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaiwgMCwgYnVpbHQuY2hpbGRyZW5baV0sIGJ1aWx0LmNoaWxkcmVuW2kgKyAxXSwgYnVpbHQuY2hpbGRyZW5baSArIDJdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IERlY29yYXRpb25TZXQobmV3TG9jYWwuc29ydChieVBvcyksIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIG1vdmVTcGFucyhzcGFucywgb2Zmc2V0KSB7XG4gICAgaWYgKCFvZmZzZXQgfHwgIXNwYW5zLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIHNwYW5zO1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBzcGFuID0gc3BhbnNbaV07XG4gICAgICAgIHJlc3VsdC5wdXNoKG5ldyBEZWNvcmF0aW9uKHNwYW4uZnJvbSArIG9mZnNldCwgc3Bhbi50byArIG9mZnNldCwgc3Bhbi50eXBlKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtYXBBbmRHYXRoZXJSZW1haW5pbmdEZWNvcmF0aW9ucyhjaGlsZHJlbiwgb2xkQ2hpbGRyZW4sIGRlY29yYXRpb25zLCBtYXBwaW5nLCBvZmZzZXQsIG9sZE9mZnNldCwgb3B0aW9ucykge1xuICAgIC8vIEdhdGhlciBhbGwgZGVjb3JhdGlvbnMgZnJvbSB0aGUgcmVtYWluaW5nIG1hcmtlZCBjaGlsZHJlblxuICAgIGZ1bmN0aW9uIGdhdGhlcihzZXQsIG9sZE9mZnNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sb2NhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG1hcHBlZCA9IHNldC5sb2NhbFtpXS5tYXAobWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQpO1xuICAgICAgICAgICAgaWYgKG1hcHBlZClcbiAgICAgICAgICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKG1hcHBlZCk7XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLm9uUmVtb3ZlKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMub25SZW1vdmUoc2V0LmxvY2FsW2ldLnNwZWMpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0LmNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICAgICAgZ2F0aGVyKHNldC5jaGlsZHJlbltpICsgMl0sIHNldC5jaGlsZHJlbltpXSArIG9sZE9mZnNldCArIDEpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICBpZiAoY2hpbGRyZW5baSArIDFdID09IC0xKVxuICAgICAgICAgICAgZ2F0aGVyKGNoaWxkcmVuW2kgKyAyXSwgb2xkQ2hpbGRyZW5baV0gKyBvbGRPZmZzZXQgKyAxKTtcbiAgICByZXR1cm4gZGVjb3JhdGlvbnM7XG59XG5mdW5jdGlvbiB0YWtlU3BhbnNGb3JOb2RlKHNwYW5zLCBub2RlLCBvZmZzZXQpIHtcbiAgICBpZiAobm9kZS5pc0xlYWYpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBlbmQgPSBvZmZzZXQgKyBub2RlLm5vZGVTaXplLCBmb3VuZCA9IG51bGw7XG4gICAgZm9yIChsZXQgaSA9IDAsIHNwYW47IGkgPCBzcGFucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoKHNwYW4gPSBzcGFuc1tpXSkgJiYgc3Bhbi5mcm9tID4gb2Zmc2V0ICYmIHNwYW4udG8gPCBlbmQpIHtcbiAgICAgICAgICAgIChmb3VuZCB8fCAoZm91bmQgPSBbXSkpLnB1c2goc3Bhbik7XG4gICAgICAgICAgICBzcGFuc1tpXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuZnVuY3Rpb24gd2l0aG91dE51bGxzKGFycmF5KSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmIChhcnJheVtpXSAhPSBudWxsKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyYXlbaV0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBCdWlsZCB1cCBhIHRyZWUgdGhhdCBjb3JyZXNwb25kcyB0byBhIHNldCBvZiBkZWNvcmF0aW9ucy4gYG9mZnNldGBcbi8vIGlzIGEgYmFzZSBvZmZzZXQgdGhhdCBzaG91bGQgYmUgc3VidHJhY3RlZCBmcm9tIHRoZSBgZnJvbWAgYW5kIGB0b2Bcbi8vIHBvc2l0aW9ucyBpbiB0aGUgc3BhbnMgKHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBhbGxvY2F0ZSBuZXcgc3BhbnNcbi8vIGZvciByZWN1cnNpdmUgY2FsbHMpLlxuZnVuY3Rpb24gYnVpbGRUcmVlKHNwYW5zLCBub2RlLCBvZmZzZXQsIG9wdGlvbnMpIHtcbiAgICBsZXQgY2hpbGRyZW4gPSBbXSwgaGFzTnVsbHMgPSBmYWxzZTtcbiAgICBub2RlLmZvckVhY2goKGNoaWxkTm9kZSwgbG9jYWxTdGFydCkgPT4ge1xuICAgICAgICBsZXQgZm91bmQgPSB0YWtlU3BhbnNGb3JOb2RlKHNwYW5zLCBjaGlsZE5vZGUsIGxvY2FsU3RhcnQgKyBvZmZzZXQpO1xuICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgIGhhc051bGxzID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBzdWJ0cmVlID0gYnVpbGRUcmVlKGZvdW5kLCBjaGlsZE5vZGUsIG9mZnNldCArIGxvY2FsU3RhcnQgKyAxLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChzdWJ0cmVlICE9IGVtcHR5KVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobG9jYWxTdGFydCwgbG9jYWxTdGFydCArIGNoaWxkTm9kZS5ub2RlU2l6ZSwgc3VidHJlZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgbG9jYWxzID0gbW92ZVNwYW5zKGhhc051bGxzID8gd2l0aG91dE51bGxzKHNwYW5zKSA6IHNwYW5zLCAtb2Zmc2V0KS5zb3J0KGJ5UG9zKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2Fscy5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKCFsb2NhbHNbaV0udHlwZS52YWxpZChub2RlLCBsb2NhbHNbaV0pKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vblJlbW92ZSlcbiAgICAgICAgICAgICAgICBvcHRpb25zLm9uUmVtb3ZlKGxvY2Fsc1tpXS5zcGVjKTtcbiAgICAgICAgICAgIGxvY2Fscy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgfVxuICAgIHJldHVybiBsb2NhbHMubGVuZ3RoIHx8IGNoaWxkcmVuLmxlbmd0aCA/IG5ldyBEZWNvcmF0aW9uU2V0KGxvY2FscywgY2hpbGRyZW4pIDogZW1wdHk7XG59XG4vLyBVc2VkIHRvIHNvcnQgZGVjb3JhdGlvbnMgc28gdGhhdCBvbmVzIHdpdGggYSBsb3cgc3RhcnQgcG9zaXRpb25cbi8vIGNvbWUgZmlyc3QsIGFuZCB3aXRoaW4gYSBzZXQgd2l0aCB0aGUgc2FtZSBzdGFydCBwb3NpdGlvbiwgdGhvc2Vcbi8vIHdpdGggYW4gc21hbGxlciBlbmQgcG9zaXRpb24gY29tZSBmaXJzdC5cbmZ1bmN0aW9uIGJ5UG9zKGEsIGIpIHtcbiAgICByZXR1cm4gYS5mcm9tIC0gYi5mcm9tIHx8IGEudG8gLSBiLnRvO1xufVxuLy8gU2NhbiBhIHNvcnRlZCBhcnJheSBvZiBkZWNvcmF0aW9ucyBmb3IgcGFydGlhbGx5IG92ZXJsYXBwaW5nIHNwYW5zLFxuLy8gYW5kIHNwbGl0IHRob3NlIHNvIHRoYXQgb25seSBmdWxseSBvdmVybGFwcGluZyBzcGFucyBhcmUgbGVmdCAodG9cbi8vIG1ha2Ugc3Vic2VxdWVudCByZW5kZXJpbmcgZWFzaWVyKS4gV2lsbCByZXR1cm4gdGhlIGlucHV0IGFycmF5IGlmXG4vLyBubyBwYXJ0aWFsbHkgb3ZlcmxhcHBpbmcgc3BhbnMgYXJlIGZvdW5kICh0aGUgY29tbW9uIGNhc2UpLlxuZnVuY3Rpb24gcmVtb3ZlT3ZlcmxhcChzcGFucykge1xuICAgIGxldCB3b3JraW5nID0gc3BhbnM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3JraW5nLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBsZXQgc3BhbiA9IHdvcmtpbmdbaV07XG4gICAgICAgIGlmIChzcGFuLmZyb20gIT0gc3Bhbi50bylcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IHdvcmtpbmcubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHdvcmtpbmdbal07XG4gICAgICAgICAgICAgICAgaWYgKG5leHQuZnJvbSA9PSBzcGFuLmZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQudG8gIT0gc3Bhbi50bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmtpbmcgPT0gc3BhbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya2luZyA9IHNwYW5zLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb2xsb3dlZCBieSBhIHBhcnRpYWxseSBvdmVybGFwcGluZyBsYXJnZXIgc3Bhbi4gU3BsaXQgdGhhdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3Bhbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtpbmdbal0gPSBuZXh0LmNvcHkobmV4dC5mcm9tLCBzcGFuLnRvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydEFoZWFkKHdvcmtpbmcsIGogKyAxLCBuZXh0LmNvcHkoc3Bhbi50bywgbmV4dC50bykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQuZnJvbSA8IHNwYW4udG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3b3JraW5nID09IHNwYW5zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtpbmcgPSBzcGFucy5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGVuZCBvZiB0aGlzIG9uZSBvdmVybGFwcyB3aXRoIGEgc3Vic2VxdWVudCBzcGFuLiBTcGxpdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBvbmUuXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JraW5nW2ldID0gc3Bhbi5jb3B5KHNwYW4uZnJvbSwgbmV4dC5mcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydEFoZWFkKHdvcmtpbmcsIGosIHNwYW4uY29weShuZXh0LmZyb20sIHNwYW4udG8pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB3b3JraW5nO1xufVxuZnVuY3Rpb24gaW5zZXJ0QWhlYWQoYXJyYXksIGksIGRlY28pIHtcbiAgICB3aGlsZSAoaSA8IGFycmF5Lmxlbmd0aCAmJiBieVBvcyhkZWNvLCBhcnJheVtpXSkgPiAwKVxuICAgICAgICBpKys7XG4gICAgYXJyYXkuc3BsaWNlKGksIDAsIGRlY28pO1xufVxuLy8gR2V0IHRoZSBkZWNvcmF0aW9ucyBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgcHJvcHMgb2YgYSB2aWV3LlxuZnVuY3Rpb24gdmlld0RlY29yYXRpb25zKHZpZXcpIHtcbiAgICBsZXQgZm91bmQgPSBbXTtcbiAgICB2aWV3LnNvbWVQcm9wKFwiZGVjb3JhdGlvbnNcIiwgZiA9PiB7XG4gICAgICAgIGxldCByZXN1bHQgPSBmKHZpZXcuc3RhdGUpO1xuICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdCAhPSBlbXB0eSlcbiAgICAgICAgICAgIGZvdW5kLnB1c2gocmVzdWx0KTtcbiAgICB9KTtcbiAgICBpZiAodmlldy5jdXJzb3JXcmFwcGVyKVxuICAgICAgICBmb3VuZC5wdXNoKERlY29yYXRpb25TZXQuY3JlYXRlKHZpZXcuc3RhdGUuZG9jLCBbdmlldy5jdXJzb3JXcmFwcGVyLmRlY29dKSk7XG4gICAgcmV0dXJuIERlY29yYXRpb25Hcm91cC5mcm9tKGZvdW5kKTtcbn1cblxuY29uc3Qgb2JzZXJ2ZU9wdGlvbnMgPSB7XG4gICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gICAgY2hhcmFjdGVyRGF0YU9sZFZhbHVlOiB0cnVlLFxuICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgYXR0cmlidXRlT2xkVmFsdWU6IHRydWUsXG4gICAgc3VidHJlZTogdHJ1ZVxufTtcbi8vIElFMTEgaGFzIHZlcnkgYnJva2VuIG11dGF0aW9uIG9ic2VydmVycywgc28gd2UgYWxzbyBsaXN0ZW4gdG8gRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXG5jb25zdCB1c2VDaGFyRGF0YSA9IGllICYmIGllX3ZlcnNpb24gPD0gMTE7XG5jbGFzcyBTZWxlY3Rpb25TdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYW5jaG9yTm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuYW5jaG9yT2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5mb2N1c05vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmZvY3VzT2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgc2V0KHNlbCkge1xuICAgICAgICB0aGlzLmFuY2hvck5vZGUgPSBzZWwuYW5jaG9yTm9kZTtcbiAgICAgICAgdGhpcy5hbmNob3JPZmZzZXQgPSBzZWwuYW5jaG9yT2Zmc2V0O1xuICAgICAgICB0aGlzLmZvY3VzTm9kZSA9IHNlbC5mb2N1c05vZGU7XG4gICAgICAgIHRoaXMuZm9jdXNPZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXQ7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLmFuY2hvck5vZGUgPSB0aGlzLmZvY3VzTm9kZSA9IG51bGw7XG4gICAgfVxuICAgIGVxKHNlbCkge1xuICAgICAgICByZXR1cm4gc2VsLmFuY2hvck5vZGUgPT0gdGhpcy5hbmNob3JOb2RlICYmIHNlbC5hbmNob3JPZmZzZXQgPT0gdGhpcy5hbmNob3JPZmZzZXQgJiZcbiAgICAgICAgICAgIHNlbC5mb2N1c05vZGUgPT0gdGhpcy5mb2N1c05vZGUgJiYgc2VsLmZvY3VzT2Zmc2V0ID09IHRoaXMuZm9jdXNPZmZzZXQ7XG4gICAgfVxufVxuY2xhc3MgRE9NT2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIGhhbmRsZURPTUNoYW5nZSkge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmhhbmRsZURPTUNoYW5nZSA9IGhhbmRsZURPTUNoYW5nZTtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLmZsdXNoaW5nU29vbiA9IC0xO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50U2VsZWN0aW9uID0gbmV3IFNlbGVjdGlvblN0YXRlO1xuICAgICAgICB0aGlzLm9uQ2hhckRhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLnN1cHByZXNzaW5nU2VsZWN0aW9uVXBkYXRlcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxhc3RDaGFuZ2VkVGV4dE5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIgJiZcbiAgICAgICAgICAgIG5ldyB3aW5kb3cuTXV0YXRpb25PYnNlcnZlcihtdXRhdGlvbnMgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb25zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2gobXV0YXRpb25zW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8PSAxMSAmJiBtdXRhdGlvbnMuc29tZShtID0+IG0udHlwZSA9PSBcImNoaWxkTGlzdFwiICYmIG0ucmVtb3ZlZE5vZGVzLmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgICAgICBtLnR5cGUgPT0gXCJjaGFyYWN0ZXJEYXRhXCIgJiYgbS5vbGRWYWx1ZS5sZW5ndGggPiBtLnRhcmdldC5ub2RlVmFsdWUubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJRTExIHdpbGwgc29tZXRpbWVzIChvbiBiYWNrc3BhY2luZyBvdXQgYSBzaW5nbGUgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRleHQgbm9kZSBhZnRlciBhIEJSIG5vZGUpIGNhbGwgdGhlIG9ic2VydmVyIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlZm9yZSBhY3R1YWxseSB1cGRhdGluZyB0aGUgRE9NLCB3aGljaCB3aWxsIGNhdXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIFByb3NlTWlycm9yIHRvIG1pc3MgdGhlIGNoYW5nZSAoc2VlICM5MzApXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hTb29uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNhZmFyaSAmJiB2aWV3LmNvbXBvc2luZyAmJiBtdXRhdGlvbnMuc29tZShtID0+IG0udHlwZSA9PSBcImNoaWxkTGlzdFwiICYmIG0udGFyZ2V0Lm5vZGVOYW1lID09IFwiVFJcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIGRvZXMgd2VpcmQgc3R1ZmYgd2hlbiBmaW5pc2hpbmcgYSBjb21wb3NpdGlvbiBpbiBhXG4gICAgICAgICAgICAgICAgICAgIC8vIHRhYmxlIGNlbGwsIHdoaWNoIHRlbmRzIHRvIGludm9sdmUgaW5zZXJ0aW5nIGluYXBwcm9wcmlhdGVcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9kZXMgaW4gdGhlIHRhYmxlIHJvdy5cbiAgICAgICAgICAgICAgICAgICAgdmlldy5pbnB1dC5iYWRTYWZhcmlDb21wb3NpdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hTb29uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmICh1c2VDaGFyRGF0YSkge1xuICAgICAgICAgICAgdGhpcy5vbkNoYXJEYXRhID0gZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHsgdGFyZ2V0OiBlLnRhcmdldCwgdHlwZTogXCJjaGFyYWN0ZXJEYXRhXCIsIG9sZFZhbHVlOiBlLnByZXZWYWx1ZSB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlID0gdGhpcy5vblNlbGVjdGlvbkNoYW5nZS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICBmbHVzaFNvb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmZsdXNoaW5nU29vbiA8IDApXG4gICAgICAgICAgICB0aGlzLmZsdXNoaW5nU29vbiA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHsgdGhpcy5mbHVzaGluZ1Nvb24gPSAtMTsgdGhpcy5mbHVzaCgpOyB9LCAyMCk7XG4gICAgfVxuICAgIGZvcmNlRmx1c2goKSB7XG4gICAgICAgIGlmICh0aGlzLmZsdXNoaW5nU29vbiA+IC0xKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuZmx1c2hpbmdTb29uKTtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hpbmdTb29uID0gLTE7XG4gICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLm9ic2VydmUodGhpcy52aWV3LmRvbSwgb2JzZXJ2ZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9uQ2hhckRhdGEpXG4gICAgICAgICAgICB0aGlzLnZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIiwgdGhpcy5vbkNoYXJEYXRhKTtcbiAgICAgICAgdGhpcy5jb25uZWN0U2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyKSB7XG4gICAgICAgICAgICBsZXQgdGFrZSA9IHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcbiAgICAgICAgICAgIGlmICh0YWtlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFrZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHRha2VbaV0pO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHRoaXMuZmx1c2goKSwgMjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub25DaGFyRGF0YSlcbiAgICAgICAgICAgIHRoaXMudmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLm9uQ2hhckRhdGEpO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RTZWxlY3Rpb24oKTtcbiAgICB9XG4gICAgY29ubmVjdFNlbGVjdGlvbigpIHtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5vd25lckRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSk7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3RTZWxlY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudmlldy5kb20ub3duZXJEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UpO1xuICAgIH1cbiAgICBzdXBwcmVzc1NlbGVjdGlvblVwZGF0ZXMoKSB7XG4gICAgICAgIHRoaXMuc3VwcHJlc3NpbmdTZWxlY3Rpb25VcGRhdGVzID0gdHJ1ZTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnN1cHByZXNzaW5nU2VsZWN0aW9uVXBkYXRlcyA9IGZhbHNlLCA1MCk7XG4gICAgfVxuICAgIG9uU2VsZWN0aW9uQ2hhbmdlKCkge1xuICAgICAgICBpZiAoIWhhc0ZvY3VzQW5kU2VsZWN0aW9uKHRoaXMudmlldykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLnN1cHByZXNzaW5nU2VsZWN0aW9uVXBkYXRlcylcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb25Ub0RPTSh0aGlzLnZpZXcpO1xuICAgICAgICAvLyBEZWxldGlvbnMgb24gSUUxMSBmaXJlIHRoZWlyIGV2ZW50cyBpbiB0aGUgd3Jvbmcgb3JkZXIsIGdpdmluZ1xuICAgICAgICAvLyB1cyBhIHNlbGVjdGlvbiBjaGFuZ2UgZXZlbnQgYmVmb3JlIHRoZSBET00gY2hhbmdlcyBhcmVcbiAgICAgICAgLy8gcmVwb3J0ZWQuXG4gICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDw9IDExICYmICF0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLmVtcHR5KSB7XG4gICAgICAgICAgICBsZXQgc2VsID0gdGhpcy52aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgICAgICAvLyBTZWxlY3Rpb24uaXNDb2xsYXBzZWQgaXNuJ3QgcmVsaWFibGUgb24gSUVcbiAgICAgICAgICAgIGlmIChzZWwuZm9jdXNOb2RlICYmIGlzRXF1aXZhbGVudFBvc2l0aW9uKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCwgc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9XG4gICAgc2V0Q3VyU2VsZWN0aW9uKCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRTZWxlY3Rpb24uc2V0KHRoaXMudmlldy5kb21TZWxlY3Rpb25SYW5nZSgpKTtcbiAgICB9XG4gICAgaWdub3JlU2VsZWN0aW9uQ2hhbmdlKHNlbCkge1xuICAgICAgICBpZiAoIXNlbC5mb2N1c05vZGUpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbGV0IGFuY2VzdG9ycyA9IG5ldyBTZXQsIGNvbnRhaW5lcjtcbiAgICAgICAgZm9yIChsZXQgc2NhbiA9IHNlbC5mb2N1c05vZGU7IHNjYW47IHNjYW4gPSBwYXJlbnROb2RlKHNjYW4pKVxuICAgICAgICAgICAgYW5jZXN0b3JzLmFkZChzY2FuKTtcbiAgICAgICAgZm9yIChsZXQgc2NhbiA9IHNlbC5hbmNob3JOb2RlOyBzY2FuOyBzY2FuID0gcGFyZW50Tm9kZShzY2FuKSlcbiAgICAgICAgICAgIGlmIChhbmNlc3RvcnMuaGFzKHNjYW4pKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gc2NhbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgbGV0IGRlc2MgPSBjb250YWluZXIgJiYgdGhpcy52aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoY29udGFpbmVyKTtcbiAgICAgICAgaWYgKGRlc2MgJiYgZGVzYy5pZ25vcmVNdXRhdGlvbih7XG4gICAgICAgICAgICB0eXBlOiBcInNlbGVjdGlvblwiLFxuICAgICAgICAgICAgdGFyZ2V0OiBjb250YWluZXIubm9kZVR5cGUgPT0gMyA/IGNvbnRhaW5lci5wYXJlbnROb2RlIDogY29udGFpbmVyXG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgICB0aGlzLnNldEN1clNlbGVjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGVuZGluZ1JlY29yZHMoKSB7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyKVxuICAgICAgICAgICAgZm9yIChsZXQgbXV0IG9mIHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKSlcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2gobXV0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVldWU7XG4gICAgfVxuICAgIGZsdXNoKCkge1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0aGlzO1xuICAgICAgICBpZiAoIXZpZXcuZG9jVmlldyB8fCB0aGlzLmZsdXNoaW5nU29vbiA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbXV0YXRpb25zID0gdGhpcy5wZW5kaW5nUmVjb3JkcygpO1xuICAgICAgICBpZiAobXV0YXRpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgbGV0IG5ld1NlbCA9ICF0aGlzLnN1cHByZXNzaW5nU2VsZWN0aW9uVXBkYXRlcyAmJiAhdGhpcy5jdXJyZW50U2VsZWN0aW9uLmVxKHNlbCkgJiYgaGFzRm9jdXNBbmRTZWxlY3Rpb24odmlldykgJiYgIXRoaXMuaWdub3JlU2VsZWN0aW9uQ2hhbmdlKHNlbCk7XG4gICAgICAgIGxldCBmcm9tID0gLTEsIHRvID0gLTEsIHR5cGVPdmVyID0gZmFsc2UsIGFkZGVkID0gW107XG4gICAgICAgIGlmICh2aWV3LmVkaXRhYmxlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnJlZ2lzdGVyTXV0YXRpb24obXV0YXRpb25zW2ldLCBhZGRlZCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBmcm9tID0gZnJvbSA8IDAgPyByZXN1bHQuZnJvbSA6IE1hdGgubWluKHJlc3VsdC5mcm9tLCBmcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgdG8gPSB0byA8IDAgPyByZXN1bHQudG8gOiBNYXRoLm1heChyZXN1bHQudG8sIHRvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlT3ZlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVPdmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdlY2tvICYmIGFkZGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGJycyA9IGFkZGVkLmZpbHRlcihuID0+IG4ubm9kZU5hbWUgPT0gXCJCUlwiKTtcbiAgICAgICAgICAgIGlmIChicnMubGVuZ3RoID09IDIpIHtcbiAgICAgICAgICAgICAgICBsZXQgW2EsIGJdID0gYnJzO1xuICAgICAgICAgICAgICAgIGlmIChhLnBhcmVudE5vZGUgJiYgYS5wYXJlbnROb2RlLnBhcmVudE5vZGUgPT0gYi5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICBiLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB7IGZvY3VzTm9kZSB9ID0gdGhpcy5jdXJyZW50U2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGJyIG9mIGJycykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGFyZW50ID0gYnIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQubm9kZU5hbWUgPT0gXCJMSVwiICYmICghZm9jdXNOb2RlIHx8IGJsb2NrUGFyZW50KHZpZXcsIGZvY3VzTm9kZSkgIT0gcGFyZW50KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoY2hyb21lIHx8IHNhZmFyaSkgJiYgYWRkZWQuc29tZShuID0+IG4ubm9kZU5hbWUgPT0gXCJCUlwiKSAmJlxuICAgICAgICAgICAgKHZpZXcuaW5wdXQubGFzdEtleUNvZGUgPT0gOCB8fCB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlID09IDQ2KSkge1xuICAgICAgICAgICAgLy8gQ2hyb21lL1NhZmFyaSBzb21ldGltZXMgaW5zZXJ0IGEgYm9ndXMgYnJlYWsgbm9kZSBpZiB5b3VcbiAgICAgICAgICAgIC8vIGJhY2tzcGFjZSBvdXQgdGhlIGxhc3QgYml0IG9mIHRleHQgYmVmb3JlIGFuIGlubGluZS1mbGV4IG5vZGUgKCMxNTUyKVxuICAgICAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBhZGRlZClcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PSBcIkJSXCIgJiYgbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhZnRlciA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZnRlciAmJiBhZnRlci5ub2RlVHlwZSA9PSAxICYmIGFmdGVyLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCByZWFkU2VsID0gbnVsbDtcbiAgICAgICAgLy8gSWYgaXQgbG9va3MgbGlrZSB0aGUgYnJvd3NlciBoYXMgcmVzZXQgdGhlIHNlbGVjdGlvbiB0byB0aGVcbiAgICAgICAgLy8gc3RhcnQgb2YgdGhlIGRvY3VtZW50IGFmdGVyIGZvY3VzLCByZXN0b3JlIHRoZSBzZWxlY3Rpb24gZnJvbVxuICAgICAgICAvLyB0aGUgc3RhdGVcbiAgICAgICAgaWYgKGZyb20gPCAwICYmIG5ld1NlbCAmJiB2aWV3LmlucHV0Lmxhc3RGb2N1cyA+IERhdGUubm93KCkgLSAyMDAgJiZcbiAgICAgICAgICAgIE1hdGgubWF4KHZpZXcuaW5wdXQubGFzdFRvdWNoLCB2aWV3LmlucHV0Lmxhc3RDbGljay50aW1lKSA8IERhdGUubm93KCkgLSAzMDAgJiZcbiAgICAgICAgICAgIHNlbGVjdGlvbkNvbGxhcHNlZChzZWwpICYmIChyZWFkU2VsID0gc2VsZWN0aW9uRnJvbURPTSh2aWV3KSkgJiZcbiAgICAgICAgICAgIHJlYWRTZWwuZXEoU2VsZWN0aW9uLm5lYXIodmlldy5zdGF0ZS5kb2MucmVzb2x2ZSgwKSwgMSkpKSB7XG4gICAgICAgICAgICB2aWV3LmlucHV0Lmxhc3RGb2N1cyA9IDA7XG4gICAgICAgICAgICBzZWxlY3Rpb25Ub0RPTSh2aWV3KTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNlbGVjdGlvbi5zZXQoc2VsKTtcbiAgICAgICAgICAgIHZpZXcuc2Nyb2xsVG9TZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmcm9tID4gLTEgfHwgbmV3U2VsKSB7XG4gICAgICAgICAgICBpZiAoZnJvbSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdmlldy5kb2NWaWV3Lm1hcmtEaXJ0eShmcm9tLCB0byk7XG4gICAgICAgICAgICAgICAgY2hlY2tDU1Modmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmlldy5pbnB1dC5iYWRTYWZhcmlDb21wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHZpZXcuaW5wdXQuYmFkU2FmYXJpQ29tcG9zaXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmaXhVcEJhZFNhZmFyaUNvbXBvc2l0aW9uKHZpZXcsIGFkZGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRE9NQ2hhbmdlKGZyb20sIHRvLCB0eXBlT3ZlciwgYWRkZWQpO1xuICAgICAgICAgICAgaWYgKHZpZXcuZG9jVmlldyAmJiB2aWV3LmRvY1ZpZXcuZGlydHkpXG4gICAgICAgICAgICAgICAgdmlldy51cGRhdGVTdGF0ZSh2aWV3LnN0YXRlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmN1cnJlbnRTZWxlY3Rpb24uZXEoc2VsKSlcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Ub0RPTSh2aWV3KTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNlbGVjdGlvbi5zZXQoc2VsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWdpc3Rlck11dGF0aW9uKG11dCwgYWRkZWQpIHtcbiAgICAgICAgLy8gSWdub3JlIG11dGF0aW9ucyBpbnNpZGUgbm9kZXMgdGhhdCB3ZXJlIGFscmVhZHkgbm90ZWQgYXMgaW5zZXJ0ZWRcbiAgICAgICAgaWYgKGFkZGVkLmluZGV4T2YobXV0LnRhcmdldCkgPiAtMSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgZGVzYyA9IHRoaXMudmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKG11dC50YXJnZXQpO1xuICAgICAgICBpZiAobXV0LnR5cGUgPT0gXCJhdHRyaWJ1dGVzXCIgJiZcbiAgICAgICAgICAgIChkZXNjID09IHRoaXMudmlldy5kb2NWaWV3IHx8IG11dC5hdHRyaWJ1dGVOYW1lID09IFwiY29udGVudGVkaXRhYmxlXCIgfHxcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IHNvbWV0aW1lcyBmaXJlcyBzcHVyaW91cyBldmVudHMgZm9yIG51bGwvZW1wdHkgc3R5bGVzXG4gICAgICAgICAgICAgICAgKG11dC5hdHRyaWJ1dGVOYW1lID09IFwic3R5bGVcIiAmJiAhbXV0Lm9sZFZhbHVlICYmICFtdXQudGFyZ2V0LmdldEF0dHJpYnV0ZShcInN0eWxlXCIpKSkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKCFkZXNjIHx8IGRlc2MuaWdub3JlTXV0YXRpb24obXV0KSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAobXV0LnR5cGUgPT0gXCJjaGlsZExpc3RcIikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXQuYWRkZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBub2RlID0gbXV0LmFkZGVkTm9kZXNbaV07XG4gICAgICAgICAgICAgICAgYWRkZWQucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RDaGFuZ2VkVGV4dE5vZGUgPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlc2MuY29udGVudERPTSAmJiBkZXNjLmNvbnRlbnRET00gIT0gZGVzYy5kb20gJiYgIWRlc2MuY29udGVudERPTS5jb250YWlucyhtdXQudGFyZ2V0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4geyBmcm9tOiBkZXNjLnBvc0JlZm9yZSwgdG86IGRlc2MucG9zQWZ0ZXIgfTtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gbXV0LnByZXZpb3VzU2libGluZywgbmV4dCA9IG11dC5uZXh0U2libGluZztcbiAgICAgICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDw9IDExICYmIG11dC5hZGRlZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIElFMTEgZ2l2ZXMgdXMgaW5jb3JyZWN0IG5leHQvcHJldiBzaWJsaW5ncyBmb3Igc29tZVxuICAgICAgICAgICAgICAgIC8vIGluc2VydGlvbnMsIHNvIGlmIHRoZXJlIGFyZSBhZGRlZCBub2RlcywgcmVjb21wdXRlIHRob3NlXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXQuYWRkZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyBwcmV2aW91c1NpYmxpbmcsIG5leHRTaWJsaW5nIH0gPSBtdXQuYWRkZWROb2Rlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmV2aW91c1NpYmxpbmcgfHwgQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChtdXQuYWRkZWROb2RlcywgcHJldmlvdXNTaWJsaW5nKSA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2ID0gcHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5leHRTaWJsaW5nIHx8IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwobXV0LmFkZGVkTm9kZXMsIG5leHRTaWJsaW5nKSA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gbmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZyb21PZmZzZXQgPSBwcmV2ICYmIHByZXYucGFyZW50Tm9kZSA9PSBtdXQudGFyZ2V0XG4gICAgICAgICAgICAgICAgPyBkb21JbmRleChwcmV2KSArIDEgOiAwO1xuICAgICAgICAgICAgbGV0IGZyb20gPSBkZXNjLmxvY2FsUG9zRnJvbURPTShtdXQudGFyZ2V0LCBmcm9tT2Zmc2V0LCAtMSk7XG4gICAgICAgICAgICBsZXQgdG9PZmZzZXQgPSBuZXh0ICYmIG5leHQucGFyZW50Tm9kZSA9PSBtdXQudGFyZ2V0XG4gICAgICAgICAgICAgICAgPyBkb21JbmRleChuZXh0KSA6IG11dC50YXJnZXQuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgdG8gPSBkZXNjLmxvY2FsUG9zRnJvbURPTShtdXQudGFyZ2V0LCB0b09mZnNldCwgMSk7XG4gICAgICAgICAgICByZXR1cm4geyBmcm9tLCB0byB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG11dC50eXBlID09IFwiYXR0cmlidXRlc1wiKSB7XG4gICAgICAgICAgICByZXR1cm4geyBmcm9tOiBkZXNjLnBvc0F0U3RhcnQgLSBkZXNjLmJvcmRlciwgdG86IGRlc2MucG9zQXRFbmQgKyBkZXNjLmJvcmRlciB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBcImNoYXJhY3RlckRhdGFcIlxuICAgICAgICAgICAgdGhpcy5sYXN0Q2hhbmdlZFRleHROb2RlID0gbXV0LnRhcmdldDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZnJvbTogZGVzYy5wb3NBdFN0YXJ0LFxuICAgICAgICAgICAgICAgIHRvOiBkZXNjLnBvc0F0RW5kLFxuICAgICAgICAgICAgICAgIC8vIEFuIGV2ZW50IHdhcyBnZW5lcmF0ZWQgZm9yIGEgdGV4dCBjaGFuZ2UgdGhhdCBkaWRuJ3QgY2hhbmdlXG4gICAgICAgICAgICAgICAgLy8gYW55IHRleHQuIE1hcmsgdGhlIGRvbSBjaGFuZ2UgdG8gZmFsbCBiYWNrIHRvIGFzc3VtaW5nIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNlbGVjdGlvbiB3YXMgdHlwZWQgb3ZlciB3aXRoIGFuIGlkZW50aWNhbCB2YWx1ZSBpZiBpdCBjYW4ndFxuICAgICAgICAgICAgICAgIC8vIGZpbmQgYW5vdGhlciBjaGFuZ2UuXG4gICAgICAgICAgICAgICAgdHlwZU92ZXI6IG11dC50YXJnZXQubm9kZVZhbHVlID09IG11dC5vbGRWYWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmxldCBjc3NDaGVja2VkID0gbmV3IFdlYWtNYXAoKTtcbmxldCBjc3NDaGVja1dhcm5lZCA9IGZhbHNlO1xuZnVuY3Rpb24gY2hlY2tDU1Modmlldykge1xuICAgIGlmIChjc3NDaGVja2VkLmhhcyh2aWV3KSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNzc0NoZWNrZWQuc2V0KHZpZXcsIG51bGwpO1xuICAgIGlmIChbJ25vcm1hbCcsICdub3dyYXAnLCAncHJlLWxpbmUnXS5pbmRleE9mKGdldENvbXB1dGVkU3R5bGUodmlldy5kb20pLndoaXRlU3BhY2UpICE9PSAtMSkge1xuICAgICAgICB2aWV3LnJlcXVpcmVzR2Vja29IYWNrTm9kZSA9IGdlY2tvO1xuICAgICAgICBpZiAoY3NzQ2hlY2tXYXJuZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnNvbGVbXCJ3YXJuXCJdKFwiUHJvc2VNaXJyb3IgZXhwZWN0cyB0aGUgQ1NTIHdoaXRlLXNwYWNlIHByb3BlcnR5IHRvIGJlIHNldCwgcHJlZmVyYWJseSB0byAncHJlLXdyYXAnLiBJdCBpcyByZWNvbW1lbmRlZCB0byBsb2FkIHN0eWxlL3Byb3NlbWlycm9yLmNzcyBmcm9tIHRoZSBwcm9zZW1pcnJvci12aWV3IHBhY2thZ2UuXCIpO1xuICAgICAgICBjc3NDaGVja1dhcm5lZCA9IHRydWU7XG4gICAgfVxufVxuZnVuY3Rpb24gcmFuZ2VUb1NlbGVjdGlvblJhbmdlKHZpZXcsIHJhbmdlKSB7XG4gICAgbGV0IGFuY2hvck5vZGUgPSByYW5nZS5zdGFydENvbnRhaW5lciwgYW5jaG9yT2Zmc2V0ID0gcmFuZ2Uuc3RhcnRPZmZzZXQ7XG4gICAgbGV0IGZvY3VzTm9kZSA9IHJhbmdlLmVuZENvbnRhaW5lciwgZm9jdXNPZmZzZXQgPSByYW5nZS5lbmRPZmZzZXQ7XG4gICAgbGV0IGN1cnJlbnRBbmNob3IgPSB2aWV3LmRvbUF0UG9zKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmFuY2hvcik7XG4gICAgLy8gU2luY2Ugc3VjaCBhIHJhbmdlIGRvZXNuJ3QgZGlzdGluZ3Vpc2ggYmV0d2VlbiBhbmNob3IgYW5kIGhlYWQsXG4gICAgLy8gdXNlIGEgaGV1cmlzdGljIHRoYXQgZmxpcHMgaXQgYXJvdW5kIGlmIGl0cyBlbmQgbWF0Y2hlcyB0aGVcbiAgICAvLyBjdXJyZW50IGFuY2hvci5cbiAgICBpZiAoaXNFcXVpdmFsZW50UG9zaXRpb24oY3VycmVudEFuY2hvci5ub2RlLCBjdXJyZW50QW5jaG9yLm9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkpXG4gICAgICAgIFthbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXRdID0gW2ZvY3VzTm9kZSwgZm9jdXNPZmZzZXQsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldF07XG4gICAgcmV0dXJuIHsgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0IH07XG59XG4vLyBVc2VkIHRvIHdvcmsgYXJvdW5kIGEgU2FmYXJpIFNlbGVjdGlvbi9zaGFkb3cgRE9NIGJ1Z1xuLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2NvZGVtaXJyb3IvZGV2L2lzc3Vlcy80MTQgZml4XG5mdW5jdGlvbiBzYWZhcmlTaGFkb3dTZWxlY3Rpb25SYW5nZSh2aWV3LCBzZWxlY3Rpb24pIHtcbiAgICBpZiAoc2VsZWN0aW9uLmdldENvbXBvc2VkUmFuZ2VzKSB7XG4gICAgICAgIGxldCByYW5nZSA9IHNlbGVjdGlvbi5nZXRDb21wb3NlZFJhbmdlcyh2aWV3LnJvb3QpWzBdO1xuICAgICAgICBpZiAocmFuZ2UpXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2VUb1NlbGVjdGlvblJhbmdlKHZpZXcsIHJhbmdlKTtcbiAgICB9XG4gICAgbGV0IGZvdW5kO1xuICAgIGZ1bmN0aW9uIHJlYWQoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGZvdW5kID0gZXZlbnQuZ2V0VGFyZ2V0UmFuZ2VzKClbMF07XG4gICAgfVxuICAgIC8vIEJlY2F1c2UgU2FmYXJpIChhdCBsZWFzdCBpbiAyMDE4LTIwMjIpIGRvZXNuJ3QgcHJvdmlkZSByZWd1bGFyXG4gICAgLy8gYWNjZXNzIHRvIHRoZSBzZWxlY3Rpb24gaW5zaWRlIGEgc2hhZG93Um9vdCwgd2UgaGF2ZSB0byBwZXJmb3JtIGFcbiAgICAvLyByaWRpY3Vsb3VzIGhhY2sgdG8gZ2V0IGF0IGl04oCUdXNpbmcgYGV4ZWNDb21tYW5kYCB0byB0cmlnZ2VyIGFcbiAgICAvLyBgYmVmb3JlSW5wdXRgIGV2ZW50IHNvIHRoYXQgd2UgY2FuIHJlYWQgdGhlIHRhcmdldCByYW5nZSBmcm9tIHRoZVxuICAgIC8vIGV2ZW50LlxuICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmVpbnB1dFwiLCByZWFkLCB0cnVlKTtcbiAgICBkb2N1bWVudC5leGVjQ29tbWFuZChcImluZGVudFwiKTtcbiAgICB2aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JlaW5wdXRcIiwgcmVhZCwgdHJ1ZSk7XG4gICAgcmV0dXJuIGZvdW5kID8gcmFuZ2VUb1NlbGVjdGlvblJhbmdlKHZpZXcsIGZvdW5kKSA6IG51bGw7XG59XG5mdW5jdGlvbiBibG9ja1BhcmVudCh2aWV3LCBub2RlKSB7XG4gICAgZm9yIChsZXQgcCA9IG5vZGUucGFyZW50Tm9kZTsgcCAmJiBwICE9IHZpZXcuZG9tOyBwID0gcC5wYXJlbnROb2RlKSB7XG4gICAgICAgIGxldCBkZXNjID0gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKHAsIHRydWUpO1xuICAgICAgICBpZiAoZGVzYyAmJiBkZXNjLm5vZGUuaXNCbG9jaylcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8vIEtsdWRnZSBmb3IgYSBTYWZhcmkgYnVnIHdoZXJlLCBvbiBlbmRpbmcgYSBjb21wb3NpdGlvbiBpbiBhblxuLy8gb3RoZXJ3aXNlIGVtcHR5IHRhYmxlIGNlbGwsIGl0IHJhbmRvbWx5IG1vdmVzIHRoZSBjb21wb3NlZCB0ZXh0XG4vLyBpbnRvIHRoZSB0YWJsZSByb3cgYXJvdW5kIHRoYXQgY2VsbCwgZ3JlYXRseSBjb25mdXNpbmcgZXZlcnl0aGluZ1xuLy8gKCMxODgpLlxuZnVuY3Rpb24gZml4VXBCYWRTYWZhcmlDb21wb3NpdGlvbih2aWV3LCBhZGRlZE5vZGVzKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCB7IGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQgfSA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICBmb3IgKGxldCBub2RlIG9mIGFkZGVkTm9kZXMpIHtcbiAgICAgICAgaWYgKCgoX2EgPSBub2RlLnBhcmVudE5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ub2RlTmFtZSkgPT0gXCJUUlwiKSB7XG4gICAgICAgICAgICBsZXQgbmV4dENlbGwgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgd2hpbGUgKG5leHRDZWxsICYmIChuZXh0Q2VsbC5ub2RlTmFtZSAhPSBcIlREXCIgJiYgbmV4dENlbGwubm9kZU5hbWUgIT0gXCJUSFwiKSlcbiAgICAgICAgICAgICAgICBuZXh0Q2VsbCA9IG5leHRDZWxsLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgaWYgKG5leHRDZWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudCA9IG5leHRDZWxsO1xuICAgICAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpcnN0ID0gcGFyZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZmlyc3QgfHwgZmlyc3Qubm9kZVR5cGUgIT0gMSB8fCBmaXJzdC5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAvXihCUnxJTUcpJC8udGVzdChmaXJzdC5ub2RlTmFtZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gZmlyc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUobm9kZSwgcGFyZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgIGlmIChmb2N1c05vZGUgPT0gbm9kZSlcbiAgICAgICAgICAgICAgICAgICAgdmlldy5kb21TZWxlY3Rpb24oKS5jb2xsYXBzZShub2RlLCBmb2N1c09mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIE5vdGUgdGhhdCBhbGwgcmVmZXJlbmNpbmcgYW5kIHBhcnNpbmcgaXMgZG9uZSB3aXRoIHRoZVxuLy8gc3RhcnQtb2Ytb3BlcmF0aW9uIHNlbGVjdGlvbiBhbmQgZG9jdW1lbnQsIHNpbmNlIHRoYXQncyB0aGUgb25lXG4vLyB0aGF0IHRoZSBET00gcmVwcmVzZW50cy4gSWYgYW55IGNoYW5nZXMgY2FtZSBpbiBpbiB0aGUgbWVhbnRpbWUsXG4vLyB0aGUgbW9kaWZpY2F0aW9uIGlzIG1hcHBlZCBvdmVyIHRob3NlIGJlZm9yZSBpdCBpcyBhcHBsaWVkLCBpblxuLy8gcmVhZERPTUNoYW5nZS5cbmZ1bmN0aW9uIHBhcnNlQmV0d2Vlbih2aWV3LCBmcm9tXywgdG9fKSB7XG4gICAgbGV0IHsgbm9kZTogcGFyZW50LCBmcm9tT2Zmc2V0LCB0b09mZnNldCwgZnJvbSwgdG8gfSA9IHZpZXcuZG9jVmlldy5wYXJzZVJhbmdlKGZyb21fLCB0b18pO1xuICAgIGxldCBkb21TZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgbGV0IGZpbmQ7XG4gICAgbGV0IGFuY2hvciA9IGRvbVNlbC5hbmNob3JOb2RlO1xuICAgIGlmIChhbmNob3IgJiYgdmlldy5kb20uY29udGFpbnMoYW5jaG9yLm5vZGVUeXBlID09IDEgPyBhbmNob3IgOiBhbmNob3IucGFyZW50Tm9kZSkpIHtcbiAgICAgICAgZmluZCA9IFt7IG5vZGU6IGFuY2hvciwgb2Zmc2V0OiBkb21TZWwuYW5jaG9yT2Zmc2V0IH1dO1xuICAgICAgICBpZiAoIXNlbGVjdGlvbkNvbGxhcHNlZChkb21TZWwpKVxuICAgICAgICAgICAgZmluZC5wdXNoKHsgbm9kZTogZG9tU2VsLmZvY3VzTm9kZSwgb2Zmc2V0OiBkb21TZWwuZm9jdXNPZmZzZXQgfSk7XG4gICAgfVxuICAgIC8vIFdvcmsgYXJvdW5kIGlzc3VlIGluIENocm9tZSB3aGVyZSBiYWNrc3BhY2luZyBzb21ldGltZXMgcmVwbGFjZXNcbiAgICAvLyB0aGUgZGVsZXRlZCBjb250ZW50IHdpdGggYSByYW5kb20gQlIgbm9kZSAoaXNzdWVzICM3OTksICM4MzEpXG4gICAgaWYgKGNocm9tZSAmJiB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlID09PSA4KSB7XG4gICAgICAgIGZvciAobGV0IG9mZiA9IHRvT2Zmc2V0OyBvZmYgPiBmcm9tT2Zmc2V0OyBvZmYtLSkge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBwYXJlbnQuY2hpbGROb2Rlc1tvZmYgLSAxXSwgZGVzYyA9IG5vZGUucG1WaWV3RGVzYztcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09IFwiQlJcIiAmJiAhZGVzYykge1xuICAgICAgICAgICAgICAgIHRvT2Zmc2V0ID0gb2ZmO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkZXNjIHx8IGRlc2Muc2l6ZSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgc3RhcnREb2MgPSB2aWV3LnN0YXRlLmRvYztcbiAgICBsZXQgcGFyc2VyID0gdmlldy5zb21lUHJvcChcImRvbVBhcnNlclwiKSB8fCBET01QYXJzZXIuZnJvbVNjaGVtYSh2aWV3LnN0YXRlLnNjaGVtYSk7XG4gICAgbGV0ICRmcm9tID0gc3RhcnREb2MucmVzb2x2ZShmcm9tKTtcbiAgICBsZXQgc2VsID0gbnVsbCwgZG9jID0gcGFyc2VyLnBhcnNlKHBhcmVudCwge1xuICAgICAgICB0b3BOb2RlOiAkZnJvbS5wYXJlbnQsXG4gICAgICAgIHRvcE1hdGNoOiAkZnJvbS5wYXJlbnQuY29udGVudE1hdGNoQXQoJGZyb20uaW5kZXgoKSksXG4gICAgICAgIHRvcE9wZW46IHRydWUsXG4gICAgICAgIGZyb206IGZyb21PZmZzZXQsXG4gICAgICAgIHRvOiB0b09mZnNldCxcbiAgICAgICAgcHJlc2VydmVXaGl0ZXNwYWNlOiAkZnJvbS5wYXJlbnQudHlwZS53aGl0ZXNwYWNlID09IFwicHJlXCIgPyBcImZ1bGxcIiA6IHRydWUsXG4gICAgICAgIGZpbmRQb3NpdGlvbnM6IGZpbmQsXG4gICAgICAgIHJ1bGVGcm9tTm9kZSxcbiAgICAgICAgY29udGV4dDogJGZyb21cbiAgICB9KTtcbiAgICBpZiAoZmluZCAmJiBmaW5kWzBdLnBvcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCBhbmNob3IgPSBmaW5kWzBdLnBvcywgaGVhZCA9IGZpbmRbMV0gJiYgZmluZFsxXS5wb3M7XG4gICAgICAgIGlmIChoZWFkID09IG51bGwpXG4gICAgICAgICAgICBoZWFkID0gYW5jaG9yO1xuICAgICAgICBzZWwgPSB7IGFuY2hvcjogYW5jaG9yICsgZnJvbSwgaGVhZDogaGVhZCArIGZyb20gfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZG9jLCBzZWwsIGZyb20sIHRvIH07XG59XG5mdW5jdGlvbiBydWxlRnJvbU5vZGUoZG9tKSB7XG4gICAgbGV0IGRlc2MgPSBkb20ucG1WaWV3RGVzYztcbiAgICBpZiAoZGVzYykge1xuICAgICAgICByZXR1cm4gZGVzYy5wYXJzZVJ1bGUoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZG9tLm5vZGVOYW1lID09IFwiQlJcIiAmJiBkb20ucGFyZW50Tm9kZSkge1xuICAgICAgICAvLyBTYWZhcmkgcmVwbGFjZXMgdGhlIGxpc3QgaXRlbSBvciB0YWJsZSBjZWxsIHdpdGggYSBCUlxuICAgICAgICAvLyBkaXJlY3RseSBpbiB0aGUgbGlzdCBub2RlICg/ISkgaWYgeW91IGRlbGV0ZSB0aGUgbGFzdFxuICAgICAgICAvLyBjaGFyYWN0ZXIgaW4gYSBsaXN0IGl0ZW0gb3IgdGFibGUgY2VsbCAoIzcwOCwgIzg2MilcbiAgICAgICAgaWYgKHNhZmFyaSAmJiAvXih1bHxvbCkkL2kudGVzdChkb20ucGFyZW50Tm9kZS5ub2RlTmFtZSkpIHtcbiAgICAgICAgICAgIGxldCBza2lwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHNraXAuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpXCIpKTtcbiAgICAgICAgICAgIHJldHVybiB7IHNraXAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkb20ucGFyZW50Tm9kZS5sYXN0Q2hpbGQgPT0gZG9tIHx8IHNhZmFyaSAmJiAvXih0cnx0YWJsZSkkL2kudGVzdChkb20ucGFyZW50Tm9kZS5ub2RlTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGlnbm9yZTogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIklNR1wiICYmIGRvbS5nZXRBdHRyaWJ1dGUoXCJtYXJrLXBsYWNlaG9sZGVyXCIpKSB7XG4gICAgICAgIHJldHVybiB7IGlnbm9yZTogdHJ1ZSB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmNvbnN0IGlzSW5saW5lID0gL14oYXxhYmJyfGFjcm9ueW18YnxiZFtpb118YmlnfGJyfGJ1dHRvbnxjaXRlfGNvZGV8ZGF0YShsaXN0KT98ZGVsfGRmbnxlbXxpfGltZ3xpbnN8a2JkfGxhYmVsfG1hcHxtYXJrfG1ldGVyfG91dHB1dHxxfHJ1Ynl8c3xzYW1wfHNtYWxsfHNwYW58c3Ryb25nfHN1W2JwXXx0aW1lfHV8dHR8dmFyKSQvaTtcbmZ1bmN0aW9uIHJlYWRET01DaGFuZ2UodmlldywgZnJvbSwgdG8sIHR5cGVPdmVyLCBhZGRlZE5vZGVzKSB7XG4gICAgbGV0IGNvbXBvc2l0aW9uSUQgPSB2aWV3LmlucHV0LmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZXMgfHwgKHZpZXcuY29tcG9zaW5nID8gdmlldy5pbnB1dC5jb21wb3NpdGlvbklEIDogMCk7XG4gICAgdmlldy5pbnB1dC5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2VzID0gMDtcbiAgICBpZiAoZnJvbSA8IDApIHtcbiAgICAgICAgbGV0IG9yaWdpbiA9IHZpZXcuaW5wdXQubGFzdFNlbGVjdGlvblRpbWUgPiBEYXRlLm5vdygpIC0gNTAgPyB2aWV3LmlucHV0Lmxhc3RTZWxlY3Rpb25PcmlnaW4gOiBudWxsO1xuICAgICAgICBsZXQgbmV3U2VsID0gc2VsZWN0aW9uRnJvbURPTSh2aWV3LCBvcmlnaW4pO1xuICAgICAgICBpZiAobmV3U2VsICYmICF2aWV3LnN0YXRlLnNlbGVjdGlvbi5lcShuZXdTZWwpKSB7XG4gICAgICAgICAgICBpZiAoY2hyb21lICYmIGFuZHJvaWQgJiZcbiAgICAgICAgICAgICAgICB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlID09PSAxMyAmJiBEYXRlLm5vdygpIC0gMTAwIDwgdmlldy5pbnB1dC5sYXN0S2V5Q29kZVRpbWUgJiZcbiAgICAgICAgICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmID0+IGYodmlldywga2V5RXZlbnQoMTMsIFwiRW50ZXJcIikpKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgdHIgPSB2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihuZXdTZWwpO1xuICAgICAgICAgICAgaWYgKG9yaWdpbiA9PSBcInBvaW50ZXJcIilcbiAgICAgICAgICAgICAgICB0ci5zZXRNZXRhKFwicG9pbnRlclwiLCB0cnVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG9yaWdpbiA9PSBcImtleVwiKVxuICAgICAgICAgICAgICAgIHRyLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgICBpZiAoY29tcG9zaXRpb25JRClcbiAgICAgICAgICAgICAgICB0ci5zZXRNZXRhKFwiY29tcG9zaXRpb25cIiwgY29tcG9zaXRpb25JRCk7XG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCAkYmVmb3JlID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShmcm9tKTtcbiAgICBsZXQgc2hhcmVkID0gJGJlZm9yZS5zaGFyZWREZXB0aCh0byk7XG4gICAgZnJvbSA9ICRiZWZvcmUuYmVmb3JlKHNoYXJlZCArIDEpO1xuICAgIHRvID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZSh0bykuYWZ0ZXIoc2hhcmVkICsgMSk7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCBwYXJzZSA9IHBhcnNlQmV0d2Vlbih2aWV3LCBmcm9tLCB0byk7XG4gICAgbGV0IGRvYyA9IHZpZXcuc3RhdGUuZG9jLCBjb21wYXJlID0gZG9jLnNsaWNlKHBhcnNlLmZyb20sIHBhcnNlLnRvKTtcbiAgICBsZXQgcHJlZmVycmVkUG9zLCBwcmVmZXJyZWRTaWRlO1xuICAgIC8vIFByZWZlciBhbmNob3JpbmcgdG8gZW5kIHdoZW4gQmFja3NwYWNlIGlzIHByZXNzZWRcbiAgICBpZiAodmlldy5pbnB1dC5sYXN0S2V5Q29kZSA9PT0gOCAmJiBEYXRlLm5vdygpIC0gMTAwIDwgdmlldy5pbnB1dC5sYXN0S2V5Q29kZVRpbWUpIHtcbiAgICAgICAgcHJlZmVycmVkUG9zID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24udG87XG4gICAgICAgIHByZWZlcnJlZFNpZGUgPSBcImVuZFwiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcHJlZmVycmVkUG9zID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbTtcbiAgICAgICAgcHJlZmVycmVkU2lkZSA9IFwic3RhcnRcIjtcbiAgICB9XG4gICAgdmlldy5pbnB1dC5sYXN0S2V5Q29kZSA9IG51bGw7XG4gICAgbGV0IGNoYW5nZSA9IGZpbmREaWZmKGNvbXBhcmUuY29udGVudCwgcGFyc2UuZG9jLmNvbnRlbnQsIHBhcnNlLmZyb20sIHByZWZlcnJlZFBvcywgcHJlZmVycmVkU2lkZSk7XG4gICAgaWYgKGNoYW5nZSlcbiAgICAgICAgdmlldy5pbnB1dC5kb21DaGFuZ2VDb3VudCsrO1xuICAgIGlmICgoaW9zICYmIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID4gRGF0ZS5ub3coKSAtIDIyNSB8fCBhbmRyb2lkKSAmJlxuICAgICAgICBhZGRlZE5vZGVzLnNvbWUobiA9PiBuLm5vZGVUeXBlID09IDEgJiYgIWlzSW5saW5lLnRlc3Qobi5ub2RlTmFtZSkpICYmXG4gICAgICAgICghY2hhbmdlIHx8IGNoYW5nZS5lbmRBID49IGNoYW5nZS5lbmRCKSAmJlxuICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmID0+IGYodmlldywga2V5RXZlbnQoMTMsIFwiRW50ZXJcIikpKSkge1xuICAgICAgICB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFjaGFuZ2UpIHtcbiAgICAgICAgaWYgKHR5cGVPdmVyICYmIHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24gJiYgIXNlbC5lbXB0eSAmJiBzZWwuJGhlYWQuc2FtZVBhcmVudChzZWwuJGFuY2hvcikgJiZcbiAgICAgICAgICAgICF2aWV3LmNvbXBvc2luZyAmJiAhKHBhcnNlLnNlbCAmJiBwYXJzZS5zZWwuYW5jaG9yICE9IHBhcnNlLnNlbC5oZWFkKSkge1xuICAgICAgICAgICAgY2hhbmdlID0geyBzdGFydDogc2VsLmZyb20sIGVuZEE6IHNlbC50bywgZW5kQjogc2VsLnRvIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocGFyc2Uuc2VsKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNlbCA9IHJlc29sdmVTZWxlY3Rpb24odmlldywgdmlldy5zdGF0ZS5kb2MsIHBhcnNlLnNlbCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbCAmJiAhc2VsLmVxKHZpZXcuc3RhdGUuc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdHIgPSB2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG9zaXRpb25JRClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLnNldE1ldGEoXCJjb21wb3NpdGlvblwiLCBjb21wb3NpdGlvbklEKTtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSBvdmVyd3JpdGluZyBhIHNlbGVjdGlvbiBieSB0eXBpbmcgbWF0Y2hlc1xuICAgIC8vIHRoZSBzdGFydCBvciBlbmQgb2YgdGhlIHNlbGVjdGVkIGNvbnRlbnQsIGNyZWF0aW5nIGEgY2hhbmdlXG4gICAgLy8gdGhhdCdzIHNtYWxsZXIgdGhhbiB3aGF0IHdhcyBhY3R1YWxseSBvdmVyd3JpdHRlbi5cbiAgICBpZiAodmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSA8IHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvICYmXG4gICAgICAgIGNoYW5nZS5zdGFydCA9PSBjaGFuZ2UuZW5kQiAmJlxuICAgICAgICB2aWV3LnN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pIHtcbiAgICAgICAgaWYgKGNoYW5nZS5zdGFydCA+IHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20gJiYgY2hhbmdlLnN0YXJ0IDw9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20gKyAyICYmXG4gICAgICAgICAgICB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tID49IHBhcnNlLmZyb20pIHtcbiAgICAgICAgICAgIGNoYW5nZS5zdGFydCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb207XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhbmdlLmVuZEEgPCB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byAmJiBjaGFuZ2UuZW5kQSA+PSB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byAtIDIgJiZcbiAgICAgICAgICAgIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvIDw9IHBhcnNlLnRvKSB7XG4gICAgICAgICAgICBjaGFuZ2UuZW5kQiArPSAodmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gLSBjaGFuZ2UuZW5kQSk7XG4gICAgICAgICAgICBjaGFuZ2UuZW5kQSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElFMTEgd2lsbCBpbnNlcnQgYSBub24tYnJlYWtpbmcgc3BhY2UgX2FoZWFkXyBvZiB0aGUgc3BhY2UgYWZ0ZXJcbiAgICAvLyB0aGUgY3Vyc29yIHNwYWNlIHdoZW4gYWRkaW5nIGEgc3BhY2UgYmVmb3JlIGFub3RoZXIgc3BhY2UuIFdoZW5cbiAgICAvLyB0aGF0IGhhcHBlbmVkLCBhZGp1c3QgdGhlIGNoYW5nZSB0byBjb3ZlciB0aGUgc3BhY2UgaW5zdGVhZC5cbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8PSAxMSAmJiBjaGFuZ2UuZW5kQiA9PSBjaGFuZ2Uuc3RhcnQgKyAxICYmXG4gICAgICAgIGNoYW5nZS5lbmRBID09IGNoYW5nZS5zdGFydCAmJiBjaGFuZ2Uuc3RhcnQgPiBwYXJzZS5mcm9tICYmXG4gICAgICAgIHBhcnNlLmRvYy50ZXh0QmV0d2VlbihjaGFuZ2Uuc3RhcnQgLSBwYXJzZS5mcm9tIC0gMSwgY2hhbmdlLnN0YXJ0IC0gcGFyc2UuZnJvbSArIDEpID09IFwiIFxcdTAwYTBcIikge1xuICAgICAgICBjaGFuZ2Uuc3RhcnQtLTtcbiAgICAgICAgY2hhbmdlLmVuZEEtLTtcbiAgICAgICAgY2hhbmdlLmVuZEItLTtcbiAgICB9XG4gICAgbGV0ICRmcm9tID0gcGFyc2UuZG9jLnJlc29sdmVOb0NhY2hlKGNoYW5nZS5zdGFydCAtIHBhcnNlLmZyb20pO1xuICAgIGxldCAkdG8gPSBwYXJzZS5kb2MucmVzb2x2ZU5vQ2FjaGUoY2hhbmdlLmVuZEIgLSBwYXJzZS5mcm9tKTtcbiAgICBsZXQgJGZyb21BID0gZG9jLnJlc29sdmUoY2hhbmdlLnN0YXJ0KTtcbiAgICBsZXQgaW5saW5lQ2hhbmdlID0gJGZyb20uc2FtZVBhcmVudCgkdG8pICYmICRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50ICYmICRmcm9tQS5lbmQoKSA+PSBjaGFuZ2UuZW5kQTtcbiAgICAvLyBJZiB0aGlzIGxvb2tzIGxpa2UgdGhlIGVmZmVjdCBvZiBwcmVzc2luZyBFbnRlciAob3Igd2FzIHJlY29yZGVkXG4gICAgLy8gYXMgYmVpbmcgYW4gaU9TIGVudGVyIHByZXNzKSwganVzdCBkaXNwYXRjaCBhbiBFbnRlciBrZXkgaW5zdGVhZC5cbiAgICBpZiAoKChpb3MgJiYgdmlldy5pbnB1dC5sYXN0SU9TRW50ZXIgPiBEYXRlLm5vdygpIC0gMjI1ICYmXG4gICAgICAgICghaW5saW5lQ2hhbmdlIHx8IGFkZGVkTm9kZXMuc29tZShuID0+IG4ubm9kZU5hbWUgPT0gXCJESVZcIiB8fCBuLm5vZGVOYW1lID09IFwiUFwiKSkpIHx8XG4gICAgICAgICghaW5saW5lQ2hhbmdlICYmICRmcm9tLnBvcyA8IHBhcnNlLmRvYy5jb250ZW50LnNpemUgJiZcbiAgICAgICAgICAgICghJGZyb20uc2FtZVBhcmVudCgkdG8pIHx8ICEkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCkgJiZcbiAgICAgICAgICAgICRmcm9tLnBvcyA8ICR0by5wb3MgJiYgIS9cXFMvLnRlc3QocGFyc2UuZG9jLnRleHRCZXR3ZWVuKCRmcm9tLnBvcywgJHRvLnBvcywgXCJcIiwgXCJcIikpKSkgJiZcbiAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDEzLCBcIkVudGVyXCIpKSkpIHtcbiAgICAgICAgdmlldy5pbnB1dC5sYXN0SU9TRW50ZXIgPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFNhbWUgZm9yIGJhY2tzcGFjZVxuICAgIGlmICh2aWV3LnN0YXRlLnNlbGVjdGlvbi5hbmNob3IgPiBjaGFuZ2Uuc3RhcnQgJiZcbiAgICAgICAgbG9va3NMaWtlQmFja3NwYWNlKGRvYywgY2hhbmdlLnN0YXJ0LCBjaGFuZ2UuZW5kQSwgJGZyb20sICR0bykgJiZcbiAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDgsIFwiQmFja3NwYWNlXCIpKSkpIHtcbiAgICAgICAgaWYgKGFuZHJvaWQgJiYgY2hyb21lKVxuICAgICAgICAgICAgdmlldy5kb21PYnNlcnZlci5zdXBwcmVzc1NlbGVjdGlvblVwZGF0ZXMoKTsgLy8gIzgyMFxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIENocm9tZSB3aWxsIG9jY2FzaW9uYWxseSwgZHVyaW5nIGNvbXBvc2l0aW9uLCBkZWxldGUgdGhlXG4gICAgLy8gZW50aXJlIGNvbXBvc2l0aW9uIGFuZCB0aGVuIGltbWVkaWF0ZWx5IGluc2VydCBpdCBhZ2Fpbi4gVGhpcyBpc1xuICAgIC8vIHVzZWQgdG8gZGV0ZWN0IHRoYXQgc2l0dWF0aW9uLlxuICAgIGlmIChjaHJvbWUgJiYgY2hhbmdlLmVuZEIgPT0gY2hhbmdlLnN0YXJ0KVxuICAgICAgICB2aWV3LmlucHV0Lmxhc3RDaHJvbWVEZWxldGUgPSBEYXRlLm5vdygpO1xuICAgIC8vIFRoaXMgdHJpZXMgdG8gZGV0ZWN0IEFuZHJvaWQgdmlydHVhbCBrZXlib2FyZFxuICAgIC8vIGVudGVyLWFuZC1waWNrLXN1Z2dlc3Rpb24gYWN0aW9uLiBUaGF0IHNvbWV0aW1lcyAoc2VlIGlzc3VlXG4gICAgLy8gIzEwNTkpIGZpcnN0IGZpcmVzIGEgRE9NIG11dGF0aW9uLCBiZWZvcmUgbW92aW5nIHRoZSBzZWxlY3Rpb24gdG9cbiAgICAvLyB0aGUgbmV3bHkgY3JlYXRlZCBibG9jay4gQW5kIHRoZW4sIGJlY2F1c2UgUHJvc2VNaXJyb3IgY2xlYW5zIHVwXG4gICAgLy8gdGhlIERPTSBzZWxlY3Rpb24sIGl0IGdpdmVzIHVwIG1vdmluZyB0aGUgc2VsZWN0aW9uIGVudGlyZWx5LFxuICAgIC8vIGxlYXZpbmcgdGhlIGN1cnNvciBpbiB0aGUgd3JvbmcgcGxhY2UuIFdoZW4gdGhhdCBoYXBwZW5zLCB3ZSBkcm9wXG4gICAgLy8gdGhlIG5ldyBwYXJhZ3JhcGggZnJvbSB0aGUgaW5pdGlhbCBjaGFuZ2UsIGFuZCBmaXJlIGEgc2ltdWxhdGVkXG4gICAgLy8gZW50ZXIga2V5IGFmdGVyd2FyZHMuXG4gICAgaWYgKGFuZHJvaWQgJiYgIWlubGluZUNoYW5nZSAmJiAkZnJvbS5zdGFydCgpICE9ICR0by5zdGFydCgpICYmICR0by5wYXJlbnRPZmZzZXQgPT0gMCAmJiAkZnJvbS5kZXB0aCA9PSAkdG8uZGVwdGggJiZcbiAgICAgICAgcGFyc2Uuc2VsICYmIHBhcnNlLnNlbC5hbmNob3IgPT0gcGFyc2Uuc2VsLmhlYWQgJiYgcGFyc2Uuc2VsLmhlYWQgPT0gY2hhbmdlLmVuZEEpIHtcbiAgICAgICAgY2hhbmdlLmVuZEIgLT0gMjtcbiAgICAgICAgJHRvID0gcGFyc2UuZG9jLnJlc29sdmVOb0NhY2hlKGNoYW5nZS5lbmRCIC0gcGFyc2UuZnJvbSk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYodmlldywga2V5RXZlbnQoMTMsIFwiRW50ZXJcIikpOyB9KTtcbiAgICAgICAgfSwgMjApO1xuICAgIH1cbiAgICBsZXQgY2hGcm9tID0gY2hhbmdlLnN0YXJ0LCBjaFRvID0gY2hhbmdlLmVuZEE7XG4gICAgbGV0IG1rVHIgPSAoYmFzZSkgPT4ge1xuICAgICAgICBsZXQgdHIgPSBiYXNlIHx8IHZpZXcuc3RhdGUudHIucmVwbGFjZShjaEZyb20sIGNoVG8sIHBhcnNlLmRvYy5zbGljZShjaGFuZ2Uuc3RhcnQgLSBwYXJzZS5mcm9tLCBjaGFuZ2UuZW5kQiAtIHBhcnNlLmZyb20pKTtcbiAgICAgICAgaWYgKHBhcnNlLnNlbCkge1xuICAgICAgICAgICAgbGV0IHNlbCA9IHJlc29sdmVTZWxlY3Rpb24odmlldywgdHIuZG9jLCBwYXJzZS5zZWwpO1xuICAgICAgICAgICAgLy8gQ2hyb21lIHdpbGwgc29tZXRpbWVzLCBkdXJpbmcgY29tcG9zaXRpb24sIHJlcG9ydCB0aGVcbiAgICAgICAgICAgIC8vIHNlbGVjdGlvbiBpbiB0aGUgd3JvbmcgcGxhY2UuIElmIGl0IGxvb2tzIGxpa2UgdGhhdCBpc1xuICAgICAgICAgICAgLy8gaGFwcGVuaW5nLCBkb24ndCB1cGRhdGUgdGhlIHNlbGVjdGlvbi5cbiAgICAgICAgICAgIC8vIEVkZ2UganVzdCBkb2Vzbid0IG1vdmUgdGhlIGN1cnNvciBmb3J3YXJkIHdoZW4geW91IHN0YXJ0IHR5cGluZ1xuICAgICAgICAgICAgLy8gaW4gYW4gZW1wdHkgYmxvY2sgb3IgYmV0d2VlbiBiciBub2Rlcy5cbiAgICAgICAgICAgIGlmIChzZWwgJiYgIShjaHJvbWUgJiYgdmlldy5jb21wb3NpbmcgJiYgc2VsLmVtcHR5ICYmXG4gICAgICAgICAgICAgICAgKGNoYW5nZS5zdGFydCAhPSBjaGFuZ2UuZW5kQiB8fCB2aWV3LmlucHV0Lmxhc3RDaHJvbWVEZWxldGUgPCBEYXRlLm5vdygpIC0gMTAwKSAmJlxuICAgICAgICAgICAgICAgIChzZWwuaGVhZCA9PSBjaEZyb20gfHwgc2VsLmhlYWQgPT0gdHIubWFwcGluZy5tYXAoY2hUbykgLSAxKSB8fFxuICAgICAgICAgICAgICAgIGllICYmIHNlbC5lbXB0eSAmJiBzZWwuaGVhZCA9PSBjaEZyb20pKVxuICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihzZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wb3NpdGlvbklEKVxuICAgICAgICAgICAgdHIuc2V0TWV0YShcImNvbXBvc2l0aW9uXCIsIGNvbXBvc2l0aW9uSUQpO1xuICAgICAgICByZXR1cm4gdHIuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICB9O1xuICAgIGxldCBtYXJrQ2hhbmdlO1xuICAgIGlmIChpbmxpbmVDaGFuZ2UpIHtcbiAgICAgICAgaWYgKCRmcm9tLnBvcyA9PSAkdG8ucG9zKSB7IC8vIERlbGV0aW9uXG4gICAgICAgICAgICAvLyBJRTExIHNvbWV0aW1lcyB3ZWlyZGx5IG1vdmVzIHRoZSBET00gc2VsZWN0aW9uIGFyb3VuZCBhZnRlclxuICAgICAgICAgICAgLy8gYmFja3NwYWNpbmcgb3V0IHRoZSBmaXJzdCBlbGVtZW50IGluIGEgdGV4dGJsb2NrXG4gICAgICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8PSAxMSAmJiAkZnJvbS5wYXJlbnRPZmZzZXQgPT0gMCkge1xuICAgICAgICAgICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3VwcHJlc3NTZWxlY3Rpb25VcGRhdGVzKCk7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzZWxlY3Rpb25Ub0RPTSh2aWV3KSwgMjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRyID0gbWtUcih2aWV3LnN0YXRlLnRyLmRlbGV0ZShjaEZyb20sIGNoVG8pKTtcbiAgICAgICAgICAgIGxldCBtYXJrcyA9IGRvYy5yZXNvbHZlKGNoYW5nZS5zdGFydCkubWFya3NBY3Jvc3MoZG9jLnJlc29sdmUoY2hhbmdlLmVuZEEpKTtcbiAgICAgICAgICAgIGlmIChtYXJrcylcbiAgICAgICAgICAgICAgICB0ci5lbnN1cmVNYXJrcyhtYXJrcyk7XG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggLy8gQWRkaW5nIG9yIHJlbW92aW5nIGEgbWFya1xuICAgICAgICBjaGFuZ2UuZW5kQSA9PSBjaGFuZ2UuZW5kQiAmJlxuICAgICAgICAgICAgKG1hcmtDaGFuZ2UgPSBpc01hcmtDaGFuZ2UoJGZyb20ucGFyZW50LmNvbnRlbnQuY3V0KCRmcm9tLnBhcmVudE9mZnNldCwgJHRvLnBhcmVudE9mZnNldCksICRmcm9tQS5wYXJlbnQuY29udGVudC5jdXQoJGZyb21BLnBhcmVudE9mZnNldCwgY2hhbmdlLmVuZEEgLSAkZnJvbUEuc3RhcnQoKSkpKSkge1xuICAgICAgICAgICAgbGV0IHRyID0gbWtUcih2aWV3LnN0YXRlLnRyKTtcbiAgICAgICAgICAgIGlmIChtYXJrQ2hhbmdlLnR5cGUgPT0gXCJhZGRcIilcbiAgICAgICAgICAgICAgICB0ci5hZGRNYXJrKGNoRnJvbSwgY2hUbywgbWFya0NoYW5nZS5tYXJrKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0ci5yZW1vdmVNYXJrKGNoRnJvbSwgY2hUbywgbWFya0NoYW5nZS5tYXJrKTtcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCRmcm9tLnBhcmVudC5jaGlsZCgkZnJvbS5pbmRleCgpKS5pc1RleHQgJiYgJGZyb20uaW5kZXgoKSA9PSAkdG8uaW5kZXgoKSAtICgkdG8udGV4dE9mZnNldCA/IDAgOiAxKSkge1xuICAgICAgICAgICAgLy8gQm90aCBwb3NpdGlvbnMgaW4gdGhlIHNhbWUgdGV4dCBub2RlIC0tIHNpbXBseSBpbnNlcnQgdGV4dFxuICAgICAgICAgICAgbGV0IHRleHQgPSAkZnJvbS5wYXJlbnQudGV4dEJldHdlZW4oJGZyb20ucGFyZW50T2Zmc2V0LCAkdG8ucGFyZW50T2Zmc2V0KTtcbiAgICAgICAgICAgIGxldCBkZWZsdCA9ICgpID0+IG1rVHIodmlldy5zdGF0ZS50ci5pbnNlcnRUZXh0KHRleHQsIGNoRnJvbSwgY2hUbykpO1xuICAgICAgICAgICAgaWYgKCF2aWV3LnNvbWVQcm9wKFwiaGFuZGxlVGV4dElucHV0XCIsIGYgPT4gZih2aWV3LCBjaEZyb20sIGNoVG8sIHRleHQsIGRlZmx0KSkpXG4gICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaChkZWZsdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2gobWtUcigpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmlldy5kaXNwYXRjaChta1RyKCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVTZWxlY3Rpb24odmlldywgZG9jLCBwYXJzZWRTZWwpIHtcbiAgICBpZiAoTWF0aC5tYXgocGFyc2VkU2VsLmFuY2hvciwgcGFyc2VkU2VsLmhlYWQpID4gZG9jLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHNlbGVjdGlvbkJldHdlZW4odmlldywgZG9jLnJlc29sdmUocGFyc2VkU2VsLmFuY2hvciksIGRvYy5yZXNvbHZlKHBhcnNlZFNlbC5oZWFkKSk7XG59XG4vLyBHaXZlbiB0d28gc2FtZS1sZW5ndGgsIG5vbi1lbXB0eSBmcmFnbWVudHMgb2YgaW5saW5lIGNvbnRlbnQsXG4vLyBkZXRlcm1pbmUgd2hldGhlciB0aGUgZmlyc3QgY291bGQgYmUgY3JlYXRlZCBmcm9tIHRoZSBzZWNvbmQgYnlcbi8vIHJlbW92aW5nIG9yIGFkZGluZyBhIHNpbmdsZSBtYXJrIHR5cGUuXG5mdW5jdGlvbiBpc01hcmtDaGFuZ2UoY3VyLCBwcmV2KSB7XG4gICAgbGV0IGN1ck1hcmtzID0gY3VyLmZpcnN0Q2hpbGQubWFya3MsIHByZXZNYXJrcyA9IHByZXYuZmlyc3RDaGlsZC5tYXJrcztcbiAgICBsZXQgYWRkZWQgPSBjdXJNYXJrcywgcmVtb3ZlZCA9IHByZXZNYXJrcywgdHlwZSwgbWFyaywgdXBkYXRlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldk1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICBhZGRlZCA9IHByZXZNYXJrc1tpXS5yZW1vdmVGcm9tU2V0KGFkZGVkKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1ck1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICByZW1vdmVkID0gY3VyTWFya3NbaV0ucmVtb3ZlRnJvbVNldChyZW1vdmVkKTtcbiAgICBpZiAoYWRkZWQubGVuZ3RoID09IDEgJiYgcmVtb3ZlZC5sZW5ndGggPT0gMCkge1xuICAgICAgICBtYXJrID0gYWRkZWRbMF07XG4gICAgICAgIHR5cGUgPSBcImFkZFwiO1xuICAgICAgICB1cGRhdGUgPSAobm9kZSkgPT4gbm9kZS5tYXJrKG1hcmsuYWRkVG9TZXQobm9kZS5tYXJrcykpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhZGRlZC5sZW5ndGggPT0gMCAmJiByZW1vdmVkLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIG1hcmsgPSByZW1vdmVkWzBdO1xuICAgICAgICB0eXBlID0gXCJyZW1vdmVcIjtcbiAgICAgICAgdXBkYXRlID0gKG5vZGUpID0+IG5vZGUubWFyayhtYXJrLnJlbW92ZUZyb21TZXQobm9kZS5tYXJrcykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCB1cGRhdGVkID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2LmNoaWxkQ291bnQ7IGkrKylcbiAgICAgICAgdXBkYXRlZC5wdXNoKHVwZGF0ZShwcmV2LmNoaWxkKGkpKSk7XG4gICAgaWYgKEZyYWdtZW50LmZyb20odXBkYXRlZCkuZXEoY3VyKSlcbiAgICAgICAgcmV0dXJuIHsgbWFyaywgdHlwZSB9O1xufVxuZnVuY3Rpb24gbG9va3NMaWtlQmFja3NwYWNlKG9sZCwgc3RhcnQsIGVuZCwgJG5ld1N0YXJ0LCAkbmV3RW5kKSB7XG4gICAgaWYgKCAvLyBUaGUgY29udGVudCBtdXN0IGhhdmUgc2hydW5rXG4gICAgZW5kIC0gc3RhcnQgPD0gJG5ld0VuZC5wb3MgLSAkbmV3U3RhcnQucG9zIHx8XG4gICAgICAgIC8vIG5ld0VuZCBtdXN0IHBvaW50IGRpcmVjdGx5IGF0IG9yIGFmdGVyIHRoZSBlbmQgb2YgdGhlIGJsb2NrIHRoYXQgbmV3U3RhcnQgcG9pbnRzIGludG9cbiAgICAgICAgc2tpcENsb3NpbmdBbmRPcGVuaW5nKCRuZXdTdGFydCwgdHJ1ZSwgZmFsc2UpIDwgJG5ld0VuZC5wb3MpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJHN0YXJ0ID0gb2xkLnJlc29sdmUoc3RhcnQpO1xuICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSwgcmF0aGVyIHRoYW4gam9pbmluZyBibG9ja3MsIHRoZSBjaGFuZ2UganVzdCByZW1vdmVkIGFuIGVudGlyZSBibG9ja1xuICAgIGlmICghJG5ld1N0YXJ0LnBhcmVudC5pc1RleHRibG9jaykge1xuICAgICAgICBsZXQgYWZ0ZXIgPSAkc3RhcnQubm9kZUFmdGVyO1xuICAgICAgICByZXR1cm4gYWZ0ZXIgIT0gbnVsbCAmJiBlbmQgPT0gc3RhcnQgKyBhZnRlci5ub2RlU2l6ZTtcbiAgICB9XG4gICAgLy8gU3RhcnQgbXVzdCBiZSBhdCB0aGUgZW5kIG9mIGEgYmxvY2tcbiAgICBpZiAoJHN0YXJ0LnBhcmVudE9mZnNldCA8ICRzdGFydC5wYXJlbnQuY29udGVudC5zaXplIHx8ICEkc3RhcnQucGFyZW50LmlzVGV4dGJsb2NrKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRuZXh0ID0gb2xkLnJlc29sdmUoc2tpcENsb3NpbmdBbmRPcGVuaW5nKCRzdGFydCwgdHJ1ZSwgdHJ1ZSkpO1xuICAgIC8vIFRoZSBuZXh0IHRleHRibG9jayBtdXN0IHN0YXJ0IGJlZm9yZSBlbmQgYW5kIGVuZCBuZWFyIGl0XG4gICAgaWYgKCEkbmV4dC5wYXJlbnQuaXNUZXh0YmxvY2sgfHwgJG5leHQucG9zID4gZW5kIHx8XG4gICAgICAgIHNraXBDbG9zaW5nQW5kT3BlbmluZygkbmV4dCwgdHJ1ZSwgZmFsc2UpIDwgZW5kKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gVGhlIGZyYWdtZW50cyBhZnRlciB0aGUgam9pbiBwb2ludCBtdXN0IG1hdGNoXG4gICAgcmV0dXJuICRuZXdTdGFydC5wYXJlbnQuY29udGVudC5jdXQoJG5ld1N0YXJ0LnBhcmVudE9mZnNldCkuZXEoJG5leHQucGFyZW50LmNvbnRlbnQpO1xufVxuZnVuY3Rpb24gc2tpcENsb3NpbmdBbmRPcGVuaW5nKCRwb3MsIGZyb21FbmQsIG1heU9wZW4pIHtcbiAgICBsZXQgZGVwdGggPSAkcG9zLmRlcHRoLCBlbmQgPSBmcm9tRW5kID8gJHBvcy5lbmQoKSA6ICRwb3MucG9zO1xuICAgIHdoaWxlIChkZXB0aCA+IDAgJiYgKGZyb21FbmQgfHwgJHBvcy5pbmRleEFmdGVyKGRlcHRoKSA9PSAkcG9zLm5vZGUoZGVwdGgpLmNoaWxkQ291bnQpKSB7XG4gICAgICAgIGRlcHRoLS07XG4gICAgICAgIGVuZCsrO1xuICAgICAgICBmcm9tRW5kID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChtYXlPcGVuKSB7XG4gICAgICAgIGxldCBuZXh0ID0gJHBvcy5ub2RlKGRlcHRoKS5tYXliZUNoaWxkKCRwb3MuaW5kZXhBZnRlcihkZXB0aCkpO1xuICAgICAgICB3aGlsZSAobmV4dCAmJiAhbmV4dC5pc0xlYWYpIHtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBlbmQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW5kO1xufVxuZnVuY3Rpb24gZmluZERpZmYoYSwgYiwgcG9zLCBwcmVmZXJyZWRQb3MsIHByZWZlcnJlZFNpZGUpIHtcbiAgICBsZXQgc3RhcnQgPSBhLmZpbmREaWZmU3RhcnQoYiwgcG9zKTtcbiAgICBpZiAoc3RhcnQgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHsgYTogZW5kQSwgYjogZW5kQiB9ID0gYS5maW5kRGlmZkVuZChiLCBwb3MgKyBhLnNpemUsIHBvcyArIGIuc2l6ZSk7XG4gICAgaWYgKHByZWZlcnJlZFNpZGUgPT0gXCJlbmRcIikge1xuICAgICAgICBsZXQgYWRqdXN0ID0gTWF0aC5tYXgoMCwgc3RhcnQgLSBNYXRoLm1pbihlbmRBLCBlbmRCKSk7XG4gICAgICAgIHByZWZlcnJlZFBvcyAtPSBlbmRBICsgYWRqdXN0IC0gc3RhcnQ7XG4gICAgfVxuICAgIGlmIChlbmRBIDwgc3RhcnQgJiYgYS5zaXplIDwgYi5zaXplKSB7XG4gICAgICAgIGxldCBtb3ZlID0gcHJlZmVycmVkUG9zIDw9IHN0YXJ0ICYmIHByZWZlcnJlZFBvcyA+PSBlbmRBID8gc3RhcnQgLSBwcmVmZXJyZWRQb3MgOiAwO1xuICAgICAgICBzdGFydCAtPSBtb3ZlO1xuICAgICAgICBpZiAoc3RhcnQgJiYgc3RhcnQgPCBiLnNpemUgJiYgaXNTdXJyb2dhdGVQYWlyKGIudGV4dEJldHdlZW4oc3RhcnQgLSAxLCBzdGFydCArIDEpKSlcbiAgICAgICAgICAgIHN0YXJ0ICs9IG1vdmUgPyAxIDogLTE7XG4gICAgICAgIGVuZEIgPSBzdGFydCArIChlbmRCIC0gZW5kQSk7XG4gICAgICAgIGVuZEEgPSBzdGFydDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZW5kQiA8IHN0YXJ0KSB7XG4gICAgICAgIGxldCBtb3ZlID0gcHJlZmVycmVkUG9zIDw9IHN0YXJ0ICYmIHByZWZlcnJlZFBvcyA+PSBlbmRCID8gc3RhcnQgLSBwcmVmZXJyZWRQb3MgOiAwO1xuICAgICAgICBzdGFydCAtPSBtb3ZlO1xuICAgICAgICBpZiAoc3RhcnQgJiYgc3RhcnQgPCBhLnNpemUgJiYgaXNTdXJyb2dhdGVQYWlyKGEudGV4dEJldHdlZW4oc3RhcnQgLSAxLCBzdGFydCArIDEpKSlcbiAgICAgICAgICAgIHN0YXJ0ICs9IG1vdmUgPyAxIDogLTE7XG4gICAgICAgIGVuZEEgPSBzdGFydCArIChlbmRBIC0gZW5kQik7XG4gICAgICAgIGVuZEIgPSBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhcnQsIGVuZEEsIGVuZEIgfTtcbn1cbmZ1bmN0aW9uIGlzU3Vycm9nYXRlUGFpcihzdHIpIHtcbiAgICBpZiAoc3RyLmxlbmd0aCAhPSAyKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGEgPSBzdHIuY2hhckNvZGVBdCgwKSwgYiA9IHN0ci5jaGFyQ29kZUF0KDEpO1xuICAgIHJldHVybiBhID49IDB4REMwMCAmJiBhIDw9IDB4REZGRiAmJiBiID49IDB4RDgwMCAmJiBiIDw9IDB4REJGRjtcbn1cblxuLyoqXG5AaW50ZXJuYWxcbiovXG5jb25zdCBfX3BhcnNlRnJvbUNsaXBib2FyZCA9IHBhcnNlRnJvbUNsaXBib2FyZDtcbi8qKlxuQGludGVybmFsXG4qL1xuY29uc3QgX19lbmRDb21wb3NpdGlvbiA9IGVuZENvbXBvc2l0aW9uO1xuLyoqXG5BbiBlZGl0b3IgdmlldyBtYW5hZ2VzIHRoZSBET00gc3RydWN0dXJlIHRoYXQgcmVwcmVzZW50cyBhblxuZWRpdGFibGUgZG9jdW1lbnQuIEl0cyBzdGF0ZSBhbmQgYmVoYXZpb3IgYXJlIGRldGVybWluZWQgYnkgaXRzXG5bcHJvcHNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkRpcmVjdEVkaXRvclByb3BzKS5cbiovXG5jbGFzcyBFZGl0b3JWaWV3IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSB2aWV3LiBgcGxhY2VgIG1heSBiZSBhIERPTSBub2RlIHRoYXQgdGhlIGVkaXRvciBzaG91bGRcbiAgICBiZSBhcHBlbmRlZCB0bywgYSBmdW5jdGlvbiB0aGF0IHdpbGwgcGxhY2UgaXQgaW50byB0aGUgZG9jdW1lbnQsXG4gICAgb3IgYW4gb2JqZWN0IHdob3NlIGBtb3VudGAgcHJvcGVydHkgaG9sZHMgdGhlIG5vZGUgdG8gdXNlIGFzIHRoZVxuICAgIGRvY3VtZW50IGNvbnRhaW5lci4gSWYgaXQgaXMgYG51bGxgLCB0aGUgZWRpdG9yIHdpbGwgbm90IGJlXG4gICAgYWRkZWQgdG8gdGhlIGRvY3VtZW50LlxuICAgICovXG4gICAgY29uc3RydWN0b3IocGxhY2UsIHByb3BzKSB7XG4gICAgICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgS2x1ZGdlIHVzZWQgdG8gd29yayBhcm91bmQgYSBDaHJvbWUgYnVnIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyYWNrV3JpdGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5tb3VudGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXJrQ3Vyc29yID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmN1cnNvcldyYXBwZXIgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGVkVmlld0Rlc2MgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbnB1dCA9IG5ldyBJbnB1dFN0YXRlO1xuICAgICAgICB0aGlzLnByZXZEaXJlY3RQbHVnaW5zID0gW107XG4gICAgICAgIHRoaXMucGx1Z2luVmlld3MgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgIEhvbGRzIGB0cnVlYCB3aGVuIGEgaGFjayBub2RlIGlzIG5lZWRlZCBpbiBGaXJlZm94IHRvIHByZXZlbnQgdGhlXG4gICAgICAgIFtzcGFjZSBpcyBlYXRlbiBpc3N1ZV0oaHR0cHM6Ly9naXRodWIuY29tL1Byb3NlTWlycm9yL3Byb3NlbWlycm9yL2lzc3Vlcy82NTEpXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlcXVpcmVzR2Vja29IYWNrTm9kZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgV2hlbiBlZGl0b3IgY29udGVudCBpcyBiZWluZyBkcmFnZ2VkLCB0aGlzIG9iamVjdCBjb250YWluc1xuICAgICAgICBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZHJhZ2dlZCBzbGljZSBhbmQgd2hldGhlciBpdCBpcyBiZWluZ1xuICAgICAgICBjb3BpZWQgb3IgbW92ZWQuIEF0IGFueSBvdGhlciB0aW1lLCBpdCBpcyBudWxsLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHByb3BzLnN0YXRlO1xuICAgICAgICB0aGlzLmRpcmVjdFBsdWdpbnMgPSBwcm9wcy5wbHVnaW5zIHx8IFtdO1xuICAgICAgICB0aGlzLmRpcmVjdFBsdWdpbnMuZm9yRWFjaChjaGVja1N0YXRlQ29tcG9uZW50KTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCA9IHRoaXMuZGlzcGF0Y2guYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kb20gPSAocGxhY2UgJiYgcGxhY2UubW91bnQpIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGlmIChwbGFjZSkge1xuICAgICAgICAgICAgaWYgKHBsYWNlLmFwcGVuZENoaWxkKVxuICAgICAgICAgICAgICAgIHBsYWNlLmFwcGVuZENoaWxkKHRoaXMuZG9tKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwbGFjZSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgcGxhY2UodGhpcy5kb20pO1xuICAgICAgICAgICAgZWxzZSBpZiAocGxhY2UubW91bnQpXG4gICAgICAgICAgICAgICAgdGhpcy5tb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVkaXRhYmxlID0gZ2V0RWRpdGFibGUodGhpcyk7XG4gICAgICAgIHVwZGF0ZUN1cnNvcldyYXBwZXIodGhpcyk7XG4gICAgICAgIHRoaXMubm9kZVZpZXdzID0gYnVpbGROb2RlVmlld3ModGhpcyk7XG4gICAgICAgIHRoaXMuZG9jVmlldyA9IGRvY1ZpZXdEZXNjKHRoaXMuc3RhdGUuZG9jLCBjb21wdXRlRG9jRGVjbyh0aGlzKSwgdmlld0RlY29yYXRpb25zKHRoaXMpLCB0aGlzLmRvbSwgdGhpcyk7XG4gICAgICAgIHRoaXMuZG9tT2JzZXJ2ZXIgPSBuZXcgRE9NT2JzZXJ2ZXIodGhpcywgKGZyb20sIHRvLCB0eXBlT3ZlciwgYWRkZWQpID0+IHJlYWRET01DaGFuZ2UodGhpcywgZnJvbSwgdG8sIHR5cGVPdmVyLCBhZGRlZCkpO1xuICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIGluaXRJbnB1dCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVQbHVnaW5WaWV3cygpO1xuICAgIH1cbiAgICAvKipcbiAgICBIb2xkcyBgdHJ1ZWAgd2hlbiBhXG4gICAgW2NvbXBvc2l0aW9uXShodHRwczovL3czYy5naXRodWIuaW8vdWlldmVudHMvI2V2ZW50cy1jb21wb3NpdGlvbmV2ZW50cylcbiAgICBpcyBhY3RpdmUuXG4gICAgKi9cbiAgICBnZXQgY29tcG9zaW5nKCkgeyByZXR1cm4gdGhpcy5pbnB1dC5jb21wb3Npbmc7IH1cbiAgICAvKipcbiAgICBUaGUgdmlldydzIGN1cnJlbnQgW3Byb3BzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JQcm9wcykuXG4gICAgKi9cbiAgICBnZXQgcHJvcHMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcm9wcy5zdGF0ZSAhPSB0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IHRoaXMuX3Byb3BzO1xuICAgICAgICAgICAgdGhpcy5fcHJvcHMgPSB7fTtcbiAgICAgICAgICAgIGZvciAobGV0IG5hbWUgaW4gcHJldilcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9wc1tuYW1lXSA9IHByZXZbbmFtZV07XG4gICAgICAgICAgICB0aGlzLl9wcm9wcy5zdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BzO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgdGhlIHZpZXcncyBwcm9wcy4gV2lsbCBpbW1lZGlhdGVseSBjYXVzZSBhbiB1cGRhdGUgdG9cbiAgICB0aGUgRE9NLlxuICAgICovXG4gICAgdXBkYXRlKHByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wcy5oYW5kbGVET01FdmVudHMgIT0gdGhpcy5fcHJvcHMuaGFuZGxlRE9NRXZlbnRzKVxuICAgICAgICAgICAgZW5zdXJlTGlzdGVuZXJzKHRoaXMpO1xuICAgICAgICBsZXQgcHJldlByb3BzID0gdGhpcy5fcHJvcHM7XG4gICAgICAgIHRoaXMuX3Byb3BzID0gcHJvcHM7XG4gICAgICAgIGlmIChwcm9wcy5wbHVnaW5zKSB7XG4gICAgICAgICAgICBwcm9wcy5wbHVnaW5zLmZvckVhY2goY2hlY2tTdGF0ZUNvbXBvbmVudCk7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdFBsdWdpbnMgPSBwcm9wcy5wbHVnaW5zO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGVJbm5lcihwcm9wcy5zdGF0ZSwgcHJldlByb3BzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSB2aWV3IGJ5IHVwZGF0aW5nIGV4aXN0aW5nIHByb3BzIG9iamVjdCB3aXRoIHRoZSBvYmplY3RcbiAgICBnaXZlbiBhcyBhcmd1bWVudC4gRXF1aXZhbGVudCB0byBgdmlldy51cGRhdGUoT2JqZWN0LmFzc2lnbih7fSxcbiAgICB2aWV3LnByb3BzLCBwcm9wcykpYC5cbiAgICAqL1xuICAgIHNldFByb3BzKHByb3BzKSB7XG4gICAgICAgIGxldCB1cGRhdGVkID0ge307XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcy5fcHJvcHMpXG4gICAgICAgICAgICB1cGRhdGVkW25hbWVdID0gdGhpcy5fcHJvcHNbbmFtZV07XG4gICAgICAgIHVwZGF0ZWQuc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHByb3BzKVxuICAgICAgICAgICAgdXBkYXRlZFtuYW1lXSA9IHByb3BzW25hbWVdO1xuICAgICAgICB0aGlzLnVwZGF0ZSh1cGRhdGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSBlZGl0b3IncyBgc3RhdGVgIHByb3AsIHdpdGhvdXQgdG91Y2hpbmcgYW55IG9mIHRoZVxuICAgIG90aGVyIHByb3BzLlxuICAgICovXG4gICAgdXBkYXRlU3RhdGUoc3RhdGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZUlubmVyKHN0YXRlLCB0aGlzLl9wcm9wcyk7XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlSW5uZXIoc3RhdGUsIHByZXZQcm9wcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBwcmV2ID0gdGhpcy5zdGF0ZSwgcmVkcmF3ID0gZmFsc2UsIHVwZGF0ZVNlbCA9IGZhbHNlO1xuICAgICAgICAvLyBXaGVuIHN0b3JlZCBtYXJrcyBhcmUgYWRkZWQsIHN0b3AgY29tcG9zaXRpb24sIHNvIHRoYXQgdGhleSBjYW5cbiAgICAgICAgLy8gYmUgZGlzcGxheWVkLlxuICAgICAgICBpZiAoc3RhdGUuc3RvcmVkTWFya3MgJiYgdGhpcy5jb21wb3NpbmcpIHtcbiAgICAgICAgICAgIGNsZWFyQ29tcG9zaXRpb24odGhpcyk7XG4gICAgICAgICAgICB1cGRhdGVTZWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgbGV0IHBsdWdpbnNDaGFuZ2VkID0gcHJldi5wbHVnaW5zICE9IHN0YXRlLnBsdWdpbnMgfHwgdGhpcy5fcHJvcHMucGx1Z2lucyAhPSBwcmV2UHJvcHMucGx1Z2lucztcbiAgICAgICAgaWYgKHBsdWdpbnNDaGFuZ2VkIHx8IHRoaXMuX3Byb3BzLnBsdWdpbnMgIT0gcHJldlByb3BzLnBsdWdpbnMgfHwgdGhpcy5fcHJvcHMubm9kZVZpZXdzICE9IHByZXZQcm9wcy5ub2RlVmlld3MpIHtcbiAgICAgICAgICAgIGxldCBub2RlVmlld3MgPSBidWlsZE5vZGVWaWV3cyh0aGlzKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VkTm9kZVZpZXdzKG5vZGVWaWV3cywgdGhpcy5ub2RlVmlld3MpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlVmlld3MgPSBub2RlVmlld3M7XG4gICAgICAgICAgICAgICAgcmVkcmF3ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGx1Z2luc0NoYW5nZWQgfHwgcHJldlByb3BzLmhhbmRsZURPTUV2ZW50cyAhPSB0aGlzLl9wcm9wcy5oYW5kbGVET01FdmVudHMpIHtcbiAgICAgICAgICAgIGVuc3VyZUxpc3RlbmVycyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVkaXRhYmxlID0gZ2V0RWRpdGFibGUodGhpcyk7XG4gICAgICAgIHVwZGF0ZUN1cnNvcldyYXBwZXIodGhpcyk7XG4gICAgICAgIGxldCBpbm5lckRlY28gPSB2aWV3RGVjb3JhdGlvbnModGhpcyksIG91dGVyRGVjbyA9IGNvbXB1dGVEb2NEZWNvKHRoaXMpO1xuICAgICAgICBsZXQgc2Nyb2xsID0gcHJldi5wbHVnaW5zICE9IHN0YXRlLnBsdWdpbnMgJiYgIXByZXYuZG9jLmVxKHN0YXRlLmRvYykgPyBcInJlc2V0XCJcbiAgICAgICAgICAgIDogc3RhdGUuc2Nyb2xsVG9TZWxlY3Rpb24gPiBwcmV2LnNjcm9sbFRvU2VsZWN0aW9uID8gXCJ0byBzZWxlY3Rpb25cIiA6IFwicHJlc2VydmVcIjtcbiAgICAgICAgbGV0IHVwZGF0ZURvYyA9IHJlZHJhdyB8fCAhdGhpcy5kb2NWaWV3Lm1hdGNoZXNOb2RlKHN0YXRlLmRvYywgb3V0ZXJEZWNvLCBpbm5lckRlY28pO1xuICAgICAgICBpZiAodXBkYXRlRG9jIHx8ICFzdGF0ZS5zZWxlY3Rpb24uZXEocHJldi5zZWxlY3Rpb24pKVxuICAgICAgICAgICAgdXBkYXRlU2VsID0gdHJ1ZTtcbiAgICAgICAgbGV0IG9sZFNjcm9sbFBvcyA9IHNjcm9sbCA9PSBcInByZXNlcnZlXCIgJiYgdXBkYXRlU2VsICYmIHRoaXMuZG9tLnN0eWxlLm92ZXJmbG93QW5jaG9yID09IG51bGwgJiYgc3RvcmVTY3JvbGxQb3ModGhpcyk7XG4gICAgICAgIGlmICh1cGRhdGVTZWwpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICAgICAgLy8gV29yayBhcm91bmQgYW4gaXNzdWUgaW4gQ2hyb21lLCBJRSwgYW5kIEVkZ2Ugd2hlcmUgY2hhbmdpbmdcbiAgICAgICAgICAgIC8vIHRoZSBET00gYXJvdW5kIGFuIGFjdGl2ZSBzZWxlY3Rpb24gcHV0cyBpdCBpbnRvIGEgYnJva2VuXG4gICAgICAgICAgICAvLyBzdGF0ZSB3aGVyZSB0aGUgdGhpbmcgdGhlIHVzZXIgc2VlcyBkaWZmZXJzIGZyb20gdGhlXG4gICAgICAgICAgICAvLyBzZWxlY3Rpb24gcmVwb3J0ZWQgYnkgdGhlIFNlbGVjdGlvbiBvYmplY3QgKCM3MTAsICM5NzMsXG4gICAgICAgICAgICAvLyAjMTAxMSwgIzEwMTMsICMxMDM1KS5cbiAgICAgICAgICAgIGxldCBmb3JjZVNlbFVwZGF0ZSA9IHVwZGF0ZURvYyAmJiAoaWUgfHwgY2hyb21lKSAmJiAhdGhpcy5jb21wb3NpbmcgJiZcbiAgICAgICAgICAgICAgICAhcHJldi5zZWxlY3Rpb24uZW1wdHkgJiYgIXN0YXRlLnNlbGVjdGlvbi5lbXB0eSAmJiBzZWxlY3Rpb25Db250ZXh0Q2hhbmdlZChwcmV2LnNlbGVjdGlvbiwgc3RhdGUuc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIGlmICh1cGRhdGVEb2MpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbm9kZSB0aGF0IHRoZSBzZWxlY3Rpb24gcG9pbnRzIGludG8gaXMgd3JpdHRlbiB0byxcbiAgICAgICAgICAgICAgICAvLyBDaHJvbWUgc29tZXRpbWVzIHN0YXJ0cyBtaXNyZXBvcnRpbmcgdGhlIHNlbGVjdGlvbiwgc28gdGhpc1xuICAgICAgICAgICAgICAgIC8vIHRyYWNrcyB0aGF0IGFuZCBmb3JjZXMgYSBzZWxlY3Rpb24gcmVzZXQgd2hlbiBvdXIgdXBkYXRlXG4gICAgICAgICAgICAgICAgLy8gZGlkIHdyaXRlIHRvIHRoZSBub2RlLlxuICAgICAgICAgICAgICAgIGxldCBjaHJvbWVLbHVkZ2UgPSBjaHJvbWUgPyAodGhpcy50cmFja1dyaXRlcyA9IHRoaXMuZG9tU2VsZWN0aW9uUmFuZ2UoKS5mb2N1c05vZGUpIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb21wb3NpbmcpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQuY29tcG9zaXRpb25Ob2RlID0gZmluZENvbXBvc2l0aW9uTm9kZSh0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAocmVkcmF3IHx8ICF0aGlzLmRvY1ZpZXcudXBkYXRlKHN0YXRlLmRvYywgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jVmlldy51cGRhdGVPdXRlckRlY28ob3V0ZXJEZWNvKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NWaWV3LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NWaWV3ID0gZG9jVmlld0Rlc2Moc3RhdGUuZG9jLCBvdXRlckRlY28sIGlubmVyRGVjbywgdGhpcy5kb20sIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hyb21lS2x1ZGdlICYmICghdGhpcy50cmFja1dyaXRlcyB8fCAhdGhpcy5kb20uY29udGFpbnModGhpcy50cmFja1dyaXRlcykpKVxuICAgICAgICAgICAgICAgICAgICBmb3JjZVNlbFVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXb3JrIGFyb3VuZCBmb3IgYW4gaXNzdWUgd2hlcmUgYW4gdXBkYXRlIGFycml2aW5nIHJpZ2h0IGJldHdlZW5cbiAgICAgICAgICAgIC8vIGEgRE9NIHNlbGVjdGlvbiBjaGFuZ2UgYW5kIHRoZSBcInNlbGVjdGlvbmNoYW5nZVwiIGV2ZW50IGZvciBpdFxuICAgICAgICAgICAgLy8gY2FuIGNhdXNlIGEgc3B1cmlvdXMgRE9NIHNlbGVjdGlvbiB1cGRhdGUsIGRpc3J1cHRpbmcgbW91c2VcbiAgICAgICAgICAgIC8vIGRyYWcgc2VsZWN0aW9uLlxuICAgICAgICAgICAgaWYgKGZvcmNlU2VsVXBkYXRlIHx8XG4gICAgICAgICAgICAgICAgISh0aGlzLmlucHV0Lm1vdXNlRG93biAmJiB0aGlzLmRvbU9ic2VydmVyLmN1cnJlbnRTZWxlY3Rpb24uZXEodGhpcy5kb21TZWxlY3Rpb25SYW5nZSgpKSAmJlxuICAgICAgICAgICAgICAgICAgICBhbmNob3JJblJpZ2h0UGxhY2UodGhpcykpKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uVG9ET00odGhpcywgZm9yY2VTZWxVcGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3luY05vZGVTZWxlY3Rpb24odGhpcywgc3RhdGUuc2VsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnNldEN1clNlbGVjdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlUGx1Z2luVmlld3MocHJldik7XG4gICAgICAgIGlmICgoKF9hID0gdGhpcy5kcmFnZ2luZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5vZGUpICYmICFwcmV2LmRvYy5lcShzdGF0ZS5kb2MpKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVEcmFnZ2VkTm9kZSh0aGlzLmRyYWdnaW5nLCBwcmV2KTtcbiAgICAgICAgaWYgKHNjcm9sbCA9PSBcInJlc2V0XCIpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tLnNjcm9sbFRvcCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2Nyb2xsID09IFwidG8gc2VsZWN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9TZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvbGRTY3JvbGxQb3MpIHtcbiAgICAgICAgICAgIHJlc2V0U2Nyb2xsUG9zKG9sZFNjcm9sbFBvcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzY3JvbGxUb1NlbGVjdGlvbigpIHtcbiAgICAgICAgbGV0IHN0YXJ0RE9NID0gdGhpcy5kb21TZWxlY3Rpb25SYW5nZSgpLmZvY3VzTm9kZTtcbiAgICAgICAgaWYgKCFzdGFydERPTSB8fCAhdGhpcy5kb20uY29udGFpbnMoc3RhcnRET00ubm9kZVR5cGUgPT0gMSA/IHN0YXJ0RE9NIDogc3RhcnRET00ucGFyZW50Tm9kZSkpIDtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zb21lUHJvcChcImhhbmRsZVNjcm9sbFRvU2VsZWN0aW9uXCIsIGYgPT4gZih0aGlzKSkpIDtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gdGhpcy5kb2NWaWV3LmRvbUFmdGVyUG9zKHRoaXMuc3RhdGUuc2VsZWN0aW9uLmZyb20pO1xuICAgICAgICAgICAgaWYgKHRhcmdldC5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgICAgIHNjcm9sbFJlY3RJbnRvVmlldyh0aGlzLCB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHN0YXJ0RE9NKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNjcm9sbFJlY3RJbnRvVmlldyh0aGlzLCB0aGlzLmNvb3Jkc0F0UG9zKHRoaXMuc3RhdGUuc2VsZWN0aW9uLmhlYWQsIDEpLCBzdGFydERPTSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveVBsdWdpblZpZXdzKCkge1xuICAgICAgICBsZXQgdmlldztcbiAgICAgICAgd2hpbGUgKHZpZXcgPSB0aGlzLnBsdWdpblZpZXdzLnBvcCgpKVxuICAgICAgICAgICAgaWYgKHZpZXcuZGVzdHJveSlcbiAgICAgICAgICAgICAgICB2aWV3LmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdXBkYXRlUGx1Z2luVmlld3MocHJldlN0YXRlKSB7XG4gICAgICAgIGlmICghcHJldlN0YXRlIHx8IHByZXZTdGF0ZS5wbHVnaW5zICE9IHRoaXMuc3RhdGUucGx1Z2lucyB8fCB0aGlzLmRpcmVjdFBsdWdpbnMgIT0gdGhpcy5wcmV2RGlyZWN0UGx1Z2lucykge1xuICAgICAgICAgICAgdGhpcy5wcmV2RGlyZWN0UGx1Z2lucyA9IHRoaXMuZGlyZWN0UGx1Z2lucztcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveVBsdWdpblZpZXdzKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGlyZWN0UGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBwbHVnaW4gPSB0aGlzLmRpcmVjdFBsdWdpbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5zcGVjLnZpZXcpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luVmlld3MucHVzaChwbHVnaW4uc3BlYy52aWV3KHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGF0ZS5wbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IHRoaXMuc3RhdGUucGx1Z2luc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luLnNwZWMudmlldylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW5WaWV3cy5wdXNoKHBsdWdpbi5zcGVjLnZpZXcodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBsdWdpblZpZXdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBsdWdpblZpZXcgPSB0aGlzLnBsdWdpblZpZXdzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW5WaWV3LnVwZGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luVmlldy51cGRhdGUodGhpcywgcHJldlN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVEcmFnZ2VkTm9kZShkcmFnZ2luZywgcHJldikge1xuICAgICAgICBsZXQgc2VsID0gZHJhZ2dpbmcubm9kZSwgZm91bmQgPSAtMTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZG9jLm5vZGVBdChzZWwuZnJvbSkgPT0gc2VsLm5vZGUpIHtcbiAgICAgICAgICAgIGZvdW5kID0gc2VsLmZyb207XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbW92ZWRQb3MgPSBzZWwuZnJvbSArICh0aGlzLnN0YXRlLmRvYy5jb250ZW50LnNpemUgLSBwcmV2LmRvYy5jb250ZW50LnNpemUpO1xuICAgICAgICAgICAgbGV0IG1vdmVkID0gbW92ZWRQb3MgPiAwICYmIHRoaXMuc3RhdGUuZG9jLm5vZGVBdChtb3ZlZFBvcyk7XG4gICAgICAgICAgICBpZiAobW92ZWQgPT0gc2VsLm5vZGUpXG4gICAgICAgICAgICAgICAgZm91bmQgPSBtb3ZlZFBvcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYWdnaW5nID0gbmV3IERyYWdnaW5nKGRyYWdnaW5nLnNsaWNlLCBkcmFnZ2luZy5tb3ZlLCBmb3VuZCA8IDAgPyB1bmRlZmluZWQgOiBOb2RlU2VsZWN0aW9uLmNyZWF0ZSh0aGlzLnN0YXRlLmRvYywgZm91bmQpKTtcbiAgICB9XG4gICAgc29tZVByb3AocHJvcE5hbWUsIGYpIHtcbiAgICAgICAgbGV0IHByb3AgPSB0aGlzLl9wcm9wcyAmJiB0aGlzLl9wcm9wc1twcm9wTmFtZV0sIHZhbHVlO1xuICAgICAgICBpZiAocHJvcCAhPSBudWxsICYmICh2YWx1ZSA9IGYgPyBmKHByb3ApIDogcHJvcCkpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kaXJlY3RQbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcHJvcCA9IHRoaXMuZGlyZWN0UGx1Z2luc1tpXS5wcm9wc1twcm9wTmFtZV07XG4gICAgICAgICAgICBpZiAocHJvcCAhPSBudWxsICYmICh2YWx1ZSA9IGYgPyBmKHByb3ApIDogcHJvcCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwbHVnaW5zID0gdGhpcy5zdGF0ZS5wbHVnaW5zO1xuICAgICAgICBpZiAocGx1Z2lucylcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBwcm9wID0gcGx1Z2luc1tpXS5wcm9wc1twcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgIT0gbnVsbCAmJiAodmFsdWUgPSBmID8gZihwcm9wKSA6IHByb3ApKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIFF1ZXJ5IHdoZXRoZXIgdGhlIHZpZXcgaGFzIGZvY3VzLlxuICAgICovXG4gICAgaGFzRm9jdXMoKSB7XG4gICAgICAgIC8vIFdvcmsgYXJvdW5kIElFIG5vdCBoYW5kbGluZyBmb2N1cyBjb3JyZWN0bHkgaWYgcmVzaXplIGhhbmRsZXMgYXJlIHNob3duLlxuICAgICAgICAvLyBJZiB0aGUgY3Vyc29yIGlzIGluc2lkZSBhbiBlbGVtZW50IHdpdGggcmVzaXplIGhhbmRsZXMsIGFjdGl2ZUVsZW1lbnRcbiAgICAgICAgLy8gd2lsbCBiZSB0aGF0IGVsZW1lbnQgaW5zdGVhZCBvZiB0aGlzLmRvbS5cbiAgICAgICAgaWYgKGllKSB7XG4gICAgICAgICAgICAvLyBJZiBhY3RpdmVFbGVtZW50IGlzIHdpdGhpbiB0aGlzLmRvbSwgYW5kIHRoZXJlIGFyZSBubyBvdGhlciBlbGVtZW50c1xuICAgICAgICAgICAgLy8gc2V0dGluZyBgY29udGVudGVkaXRhYmxlYCB0byBmYWxzZSBpbiBiZXR3ZWVuLCB0cmVhdCBpdCBhcyBmb2N1c2VkLlxuICAgICAgICAgICAgbGV0IG5vZGUgPSB0aGlzLnJvb3QuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIGlmIChub2RlID09IHRoaXMuZG9tKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKCFub2RlIHx8ICF0aGlzLmRvbS5jb250YWlucyhub2RlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAobm9kZSAmJiB0aGlzLmRvbSAhPSBub2RlICYmIHRoaXMuZG9tLmNvbnRhaW5zKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuY29udGVudEVkaXRhYmxlID09ICdmYWxzZScpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5hY3RpdmVFbGVtZW50ID09IHRoaXMuZG9tO1xuICAgIH1cbiAgICAvKipcbiAgICBGb2N1cyB0aGUgZWRpdG9yLlxuICAgICovXG4gICAgZm9jdXMoKSB7XG4gICAgICAgIHRoaXMuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICBpZiAodGhpcy5lZGl0YWJsZSlcbiAgICAgICAgICAgIGZvY3VzUHJldmVudFNjcm9sbCh0aGlzLmRvbSk7XG4gICAgICAgIHNlbGVjdGlvblRvRE9NKHRoaXMpO1xuICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgZG9jdW1lbnQgcm9vdCBpbiB3aGljaCB0aGUgZWRpdG9yIGV4aXN0cy4gVGhpcyB3aWxsXG4gICAgdXN1YWxseSBiZSB0aGUgdG9wLWxldmVsIGBkb2N1bWVudGAsIGJ1dCBtaWdodCBiZSBhIFtzaGFkb3dcbiAgICBET01dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1dlYl9Db21wb25lbnRzL1NoYWRvd19ET00pXG4gICAgcm9vdCBpZiB0aGUgZWRpdG9yIGlzIGluc2lkZSBvbmUuXG4gICAgKi9cbiAgICBnZXQgcm9vdCgpIHtcbiAgICAgICAgbGV0IGNhY2hlZCA9IHRoaXMuX3Jvb3Q7XG4gICAgICAgIGlmIChjYWNoZWQgPT0gbnVsbClcbiAgICAgICAgICAgIGZvciAobGV0IHNlYXJjaCA9IHRoaXMuZG9tLnBhcmVudE5vZGU7IHNlYXJjaDsgc2VhcmNoID0gc2VhcmNoLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VhcmNoLm5vZGVUeXBlID09IDkgfHwgKHNlYXJjaC5ub2RlVHlwZSA9PSAxMSAmJiBzZWFyY2guaG9zdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWFyY2guZ2V0U2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKHNlYXJjaCkuZ2V0U2VsZWN0aW9uID0gKCkgPT4gc2VhcmNoLm93bmVyRG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb290ID0gc2VhcmNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhY2hlZCB8fCBkb2N1bWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hlbiBhbiBleGlzdGluZyBlZGl0b3IgdmlldyBpcyBtb3ZlZCB0byBhIG5ldyBkb2N1bWVudCBvclxuICAgIHNoYWRvdyB0cmVlLCBjYWxsIHRoaXMgdG8gbWFrZSBpdCByZWNvbXB1dGUgaXRzIHJvb3QuXG4gICAgKi9cbiAgICB1cGRhdGVSb290KCkge1xuICAgICAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgR2l2ZW4gYSBwYWlyIG9mIHZpZXdwb3J0IGNvb3JkaW5hdGVzLCByZXR1cm4gdGhlIGRvY3VtZW50XG4gICAgcG9zaXRpb24gdGhhdCBjb3JyZXNwb25kcyB0byB0aGVtLiBNYXkgcmV0dXJuIG51bGwgaWYgdGhlIGdpdmVuXG4gICAgY29vcmRpbmF0ZXMgYXJlbid0IGluc2lkZSBvZiB0aGUgZWRpdG9yLiBXaGVuIGFuIG9iamVjdCBpc1xuICAgIHJldHVybmVkLCBpdHMgYHBvc2AgcHJvcGVydHkgaXMgdGhlIHBvc2l0aW9uIG5lYXJlc3QgdG8gdGhlXG4gICAgY29vcmRpbmF0ZXMsIGFuZCBpdHMgYGluc2lkZWAgcHJvcGVydHkgaG9sZHMgdGhlIHBvc2l0aW9uIG9mIHRoZVxuICAgIGlubmVyIG5vZGUgdGhhdCB0aGUgcG9zaXRpb24gZmFsbHMgaW5zaWRlIG9mLCBvciAtMSBpZiBpdCBpcyBhdFxuICAgIHRoZSB0b3AgbGV2ZWwsIG5vdCBpbiBhbnkgbm9kZS5cbiAgICAqL1xuICAgIHBvc0F0Q29vcmRzKGNvb3Jkcykge1xuICAgICAgICByZXR1cm4gcG9zQXRDb29yZHModGhpcywgY29vcmRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGUgdmlld3BvcnQgcmVjdGFuZ2xlIGF0IGEgZ2l2ZW4gZG9jdW1lbnQgcG9zaXRpb24uXG4gICAgYGxlZnRgIGFuZCBgcmlnaHRgIHdpbGwgYmUgdGhlIHNhbWUgbnVtYmVyLCBhcyB0aGlzIHJldHVybnMgYVxuICAgIGZsYXQgY3Vyc29yLWlzaCByZWN0YW5nbGUuIElmIHRoZSBwb3NpdGlvbiBpcyBiZXR3ZWVuIHR3byB0aGluZ3NcbiAgICB0aGF0IGFyZW4ndCBkaXJlY3RseSBhZGphY2VudCwgYHNpZGVgIGRldGVybWluZXMgd2hpY2ggZWxlbWVudFxuICAgIGlzIHVzZWQuIFdoZW4gPCAwLCB0aGUgZWxlbWVudCBiZWZvcmUgdGhlIHBvc2l0aW9uIGlzIHVzZWQsXG4gICAgb3RoZXJ3aXNlIHRoZSBlbGVtZW50IGFmdGVyLlxuICAgICovXG4gICAgY29vcmRzQXRQb3MocG9zLCBzaWRlID0gMSkge1xuICAgICAgICByZXR1cm4gY29vcmRzQXRQb3ModGhpcywgcG9zLCBzaWRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgRE9NIHBvc2l0aW9uIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIGdpdmVuIGRvY3VtZW50XG4gICAgcG9zaXRpb24uIFdoZW4gYHNpZGVgIGlzIG5lZ2F0aXZlLCBmaW5kIHRoZSBwb3NpdGlvbiBhcyBjbG9zZSBhc1xuICAgIHBvc3NpYmxlIHRvIHRoZSBjb250ZW50IGJlZm9yZSB0aGUgcG9zaXRpb24uIFdoZW4gcG9zaXRpdmUsXG4gICAgcHJlZmVyIHBvc2l0aW9ucyBjbG9zZSB0byB0aGUgY29udGVudCBhZnRlciB0aGUgcG9zaXRpb24uIFdoZW5cbiAgICB6ZXJvLCBwcmVmZXIgYXMgc2hhbGxvdyBhIHBvc2l0aW9uIGFzIHBvc3NpYmxlLlxuICAgIFxuICAgIE5vdGUgdGhhdCB5b3Ugc2hvdWxkICoqbm90KiogbXV0YXRlIHRoZSBlZGl0b3IncyBpbnRlcm5hbCBET00sXG4gICAgb25seSBpbnNwZWN0IGl0IChhbmQgZXZlbiB0aGF0IGlzIHVzdWFsbHkgbm90IG5lY2Vzc2FyeSkuXG4gICAgKi9cbiAgICBkb21BdFBvcyhwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY1ZpZXcuZG9tRnJvbVBvcyhwb3MsIHNpZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBET00gbm9kZSB0aGF0IHJlcHJlc2VudHMgdGhlIGRvY3VtZW50IG5vZGUgYWZ0ZXIgdGhlXG4gICAgZ2l2ZW4gcG9zaXRpb24uIE1heSByZXR1cm4gYG51bGxgIHdoZW4gdGhlIHBvc2l0aW9uIGRvZXNuJ3QgcG9pbnRcbiAgICBpbiBmcm9udCBvZiBhIG5vZGUgb3IgaWYgdGhlIG5vZGUgaXMgaW5zaWRlIGFuIG9wYXF1ZSBub2RlIHZpZXcuXG4gICAgXG4gICAgVGhpcyBpcyBpbnRlbmRlZCB0byBiZSBhYmxlIHRvIGNhbGwgdGhpbmdzIGxpa2VcbiAgICBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCBvbiB0aGF0IERPTSBub2RlLiBEbyAqKm5vdCoqIG11dGF0ZSB0aGVcbiAgICBlZGl0b3IgRE9NIGRpcmVjdGx5LCBvciBhZGQgc3R5bGluZyB0aGlzIHdheSwgc2luY2UgdGhhdCB3aWxsIGJlXG4gICAgaW1tZWRpYXRlbHkgb3ZlcnJpZGVuIGJ5IHRoZSBlZGl0b3IgYXMgaXQgcmVkcmF3cyB0aGUgbm9kZS5cbiAgICAqL1xuICAgIG5vZGVET00ocG9zKSB7XG4gICAgICAgIGxldCBkZXNjID0gdGhpcy5kb2NWaWV3LmRlc2NBdChwb3MpO1xuICAgICAgICByZXR1cm4gZGVzYyA/IGRlc2Mubm9kZURPTSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGRvY3VtZW50IHBvc2l0aW9uIHRoYXQgY29ycmVzcG9uZHMgdG8gYSBnaXZlbiBET01cbiAgICBwb3NpdGlvbi4gKFdoZW5ldmVyIHBvc3NpYmxlLCBpdCBpcyBwcmVmZXJhYmxlIHRvIGluc3BlY3QgdGhlXG4gICAgZG9jdW1lbnQgc3RydWN0dXJlIGRpcmVjdGx5LCByYXRoZXIgdGhhbiBwb2tpbmcgYXJvdW5kIGluIHRoZVxuICAgIERPTSwgYnV0IHNvbWV0aW1lc+KAlGZvciBleGFtcGxlIHdoZW4gaW50ZXJwcmV0aW5nIGFuIGV2ZW50XG4gICAgdGFyZ2V04oCUeW91IGRvbid0IGhhdmUgYSBjaG9pY2UuKVxuICAgIFxuICAgIFRoZSBgYmlhc2AgcGFyYW1ldGVyIGNhbiBiZSB1c2VkIHRvIGluZmx1ZW5jZSB3aGljaCBzaWRlIG9mIGEgRE9NXG4gICAgbm9kZSB0byB1c2Ugd2hlbiB0aGUgcG9zaXRpb24gaXMgaW5zaWRlIGEgbGVhZiBub2RlLlxuICAgICovXG4gICAgcG9zQXRET00obm9kZSwgb2Zmc2V0LCBiaWFzID0gLTEpIHtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMuZG9jVmlldy5wb3NGcm9tRE9NKG5vZGUsIG9mZnNldCwgYmlhcyk7XG4gICAgICAgIGlmIChwb3MgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRE9NIHBvc2l0aW9uIG5vdCBpbnNpZGUgdGhlIGVkaXRvclwiKTtcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCBvdXQgd2hldGhlciB0aGUgc2VsZWN0aW9uIGlzIGF0IHRoZSBlbmQgb2YgYSB0ZXh0YmxvY2sgd2hlblxuICAgIG1vdmluZyBpbiBhIGdpdmVuIGRpcmVjdGlvbi4gV2hlbiwgZm9yIGV4YW1wbGUsIGdpdmVuIGBcImxlZnRcImAsXG4gICAgaXQgd2lsbCByZXR1cm4gdHJ1ZSBpZiBtb3ZpbmcgbGVmdCBmcm9tIHRoZSBjdXJyZW50IGN1cnNvclxuICAgIHBvc2l0aW9uIHdvdWxkIGxlYXZlIHRoYXQgcG9zaXRpb24ncyBwYXJlbnQgdGV4dGJsb2NrLiBXaWxsIGFwcGx5XG4gICAgdG8gdGhlIHZpZXcncyBjdXJyZW50IHN0YXRlIGJ5IGRlZmF1bHQsIGJ1dCBpdCBpcyBwb3NzaWJsZSB0b1xuICAgIHBhc3MgYSBkaWZmZXJlbnQgc3RhdGUuXG4gICAgKi9cbiAgICBlbmRPZlRleHRibG9jayhkaXIsIHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBlbmRPZlRleHRibG9jayh0aGlzLCBzdGF0ZSB8fCB0aGlzLnN0YXRlLCBkaXIpO1xuICAgIH1cbiAgICAvKipcbiAgICBSdW4gdGhlIGVkaXRvcidzIHBhc3RlIGxvZ2ljIHdpdGggdGhlIGdpdmVuIEhUTUwgc3RyaW5nLiBUaGVcbiAgICBgZXZlbnRgLCBpZiBnaXZlbiwgd2lsbCBiZSBwYXNzZWQgdG8gdGhlXG4gICAgW2BoYW5kbGVQYXN0ZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkVkaXRvclByb3BzLmhhbmRsZVBhc3RlKSBob29rLlxuICAgICovXG4gICAgcGFzdGVIVE1MKGh0bWwsIGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBkb1Bhc3RlKHRoaXMsIFwiXCIsIGh0bWwsIGZhbHNlLCBldmVudCB8fCBuZXcgQ2xpcGJvYXJkRXZlbnQoXCJwYXN0ZVwiKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJ1biB0aGUgZWRpdG9yJ3MgcGFzdGUgbG9naWMgd2l0aCB0aGUgZ2l2ZW4gcGxhaW4tdGV4dCBpbnB1dC5cbiAgICAqL1xuICAgIHBhc3RlVGV4dCh0ZXh0LCBldmVudCkge1xuICAgICAgICByZXR1cm4gZG9QYXN0ZSh0aGlzLCB0ZXh0LCBudWxsLCB0cnVlLCBldmVudCB8fCBuZXcgQ2xpcGJvYXJkRXZlbnQoXCJwYXN0ZVwiKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFNlcmlhbGl6ZSB0aGUgZ2l2ZW4gc2xpY2UgYXMgaXQgd291bGQgYmUgaWYgaXQgd2FzIGNvcGllZCBmcm9tXG4gICAgdGhpcyBlZGl0b3IuIFJldHVybnMgYSBET00gZWxlbWVudCB0aGF0IGNvbnRhaW5zIGFcbiAgICByZXByZXNlbnRhdGlvbiBvZiB0aGUgc2xpY2UgYXMgaXRzIGNoaWxkcmVuLCBhIHRleHR1YWxcbiAgICByZXByZXNlbnRhdGlvbiwgYW5kIHRoZSB0cmFuc2Zvcm1lZCBzbGljZSAod2hpY2ggY2FuIGJlXG4gICAgZGlmZmVyZW50IGZyb20gdGhlIGdpdmVuIGlucHV0IGR1ZSB0byBob29rcyBsaWtlXG4gICAgW2B0cmFuc2Zvcm1Db3BpZWRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JQcm9wcy50cmFuc2Zvcm1Db3BpZWQpKS5cbiAgICAqL1xuICAgIHNlcmlhbGl6ZUZvckNsaXBib2FyZChzbGljZSkge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplRm9yQ2xpcGJvYXJkKHRoaXMsIHNsaWNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlcyB0aGUgZWRpdG9yIGZyb20gdGhlIERPTSBhbmQgZGVzdHJveXMgYWxsIFtub2RlXG4gICAgdmlld3NdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3Lk5vZGVWaWV3KS5cbiAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICghdGhpcy5kb2NWaWV3KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBkZXN0cm95SW5wdXQodGhpcyk7XG4gICAgICAgIHRoaXMuZGVzdHJveVBsdWdpblZpZXdzKCk7XG4gICAgICAgIGlmICh0aGlzLm1vdW50ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZG9jVmlldy51cGRhdGUodGhpcy5zdGF0ZS5kb2MsIFtdLCB2aWV3RGVjb3JhdGlvbnModGhpcyksIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5kb20udGV4dENvbnRlbnQgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZG9tLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9jVmlldy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZG9jVmlldyA9IG51bGw7XG4gICAgICAgIGNsZWFyUmV1c2VkUmFuZ2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhpcyBpcyB0cnVlIHdoZW4gdGhlIHZpZXcgaGFzIGJlZW5cbiAgICBbZGVzdHJveWVkXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRlc3Ryb3kpIChhbmQgdGh1cyBzaG91bGQgbm90IGJlXG4gICAgdXNlZCBhbnltb3JlKS5cbiAgICAqL1xuICAgIGdldCBpc0Rlc3Ryb3llZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jVmlldyA9PSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBVc2VkIGZvciB0ZXN0aW5nLlxuICAgICovXG4gICAgZGlzcGF0Y2hFdmVudChldmVudCkge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hFdmVudCh0aGlzLCBldmVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZG9tU2VsZWN0aW9uUmFuZ2UoKSB7XG4gICAgICAgIGxldCBzZWwgPSB0aGlzLmRvbVNlbGVjdGlvbigpO1xuICAgICAgICBpZiAoIXNlbClcbiAgICAgICAgICAgIHJldHVybiB7IGZvY3VzTm9kZTogbnVsbCwgZm9jdXNPZmZzZXQ6IDAsIGFuY2hvck5vZGU6IG51bGwsIGFuY2hvck9mZnNldDogMCB9O1xuICAgICAgICByZXR1cm4gc2FmYXJpICYmIHRoaXMucm9vdC5ub2RlVHlwZSA9PT0gMTEgJiZcbiAgICAgICAgICAgIGRlZXBBY3RpdmVFbGVtZW50KHRoaXMuZG9tLm93bmVyRG9jdW1lbnQpID09IHRoaXMuZG9tICYmIHNhZmFyaVNoYWRvd1NlbGVjdGlvblJhbmdlKHRoaXMsIHNlbCkgfHwgc2VsO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGRvbVNlbGVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5nZXRTZWxlY3Rpb24oKTtcbiAgICB9XG59XG5FZGl0b3JWaWV3LnByb3RvdHlwZS5kaXNwYXRjaCA9IGZ1bmN0aW9uICh0cikge1xuICAgIGxldCBkaXNwYXRjaFRyYW5zYWN0aW9uID0gdGhpcy5fcHJvcHMuZGlzcGF0Y2hUcmFuc2FjdGlvbjtcbiAgICBpZiAoZGlzcGF0Y2hUcmFuc2FjdGlvbilcbiAgICAgICAgZGlzcGF0Y2hUcmFuc2FjdGlvbi5jYWxsKHRoaXMsIHRyKTtcbiAgICBlbHNlXG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUodGhpcy5zdGF0ZS5hcHBseSh0cikpO1xufTtcbmZ1bmN0aW9uIGNvbXB1dGVEb2NEZWNvKHZpZXcpIHtcbiAgICBsZXQgYXR0cnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGF0dHJzLmNsYXNzID0gXCJQcm9zZU1pcnJvclwiO1xuICAgIGF0dHJzLmNvbnRlbnRlZGl0YWJsZSA9IFN0cmluZyh2aWV3LmVkaXRhYmxlKTtcbiAgICB2aWV3LnNvbWVQcm9wKFwiYXR0cmlidXRlc1wiLCB2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSh2aWV3LnN0YXRlKTtcbiAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgZm9yIChsZXQgYXR0ciBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChhdHRyID09IFwiY2xhc3NcIilcbiAgICAgICAgICAgICAgICAgICAgYXR0cnMuY2xhc3MgKz0gXCIgXCIgKyB2YWx1ZVthdHRyXTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhdHRyID09IFwic3R5bGVcIilcbiAgICAgICAgICAgICAgICAgICAgYXR0cnMuc3R5bGUgPSAoYXR0cnMuc3R5bGUgPyBhdHRycy5zdHlsZSArIFwiO1wiIDogXCJcIikgKyB2YWx1ZVthdHRyXTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghYXR0cnNbYXR0cl0gJiYgYXR0ciAhPSBcImNvbnRlbnRlZGl0YWJsZVwiICYmIGF0dHIgIT0gXCJub2RlTmFtZVwiKVxuICAgICAgICAgICAgICAgICAgICBhdHRyc1thdHRyXSA9IFN0cmluZyh2YWx1ZVthdHRyXSk7XG4gICAgICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFhdHRycy50cmFuc2xhdGUpXG4gICAgICAgIGF0dHJzLnRyYW5zbGF0ZSA9IFwibm9cIjtcbiAgICByZXR1cm4gW0RlY29yYXRpb24ubm9kZSgwLCB2aWV3LnN0YXRlLmRvYy5jb250ZW50LnNpemUsIGF0dHJzKV07XG59XG5mdW5jdGlvbiB1cGRhdGVDdXJzb3JXcmFwcGVyKHZpZXcpIHtcbiAgICBpZiAodmlldy5tYXJrQ3Vyc29yKSB7XG4gICAgICAgIGxldCBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgICBkb20uY2xhc3NOYW1lID0gXCJQcm9zZU1pcnJvci1zZXBhcmF0b3JcIjtcbiAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShcIm1hcmstcGxhY2Vob2xkZXJcIiwgXCJ0cnVlXCIpO1xuICAgICAgICBkb20uc2V0QXR0cmlidXRlKFwiYWx0XCIsIFwiXCIpO1xuICAgICAgICB2aWV3LmN1cnNvcldyYXBwZXIgPSB7IGRvbSwgZGVjbzogRGVjb3JhdGlvbi53aWRnZXQodmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSwgZG9tLCB7IHJhdzogdHJ1ZSwgbWFya3M6IHZpZXcubWFya0N1cnNvciB9KSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmlldy5jdXJzb3JXcmFwcGVyID0gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRFZGl0YWJsZSh2aWV3KSB7XG4gICAgcmV0dXJuICF2aWV3LnNvbWVQcm9wKFwiZWRpdGFibGVcIiwgdmFsdWUgPT4gdmFsdWUodmlldy5zdGF0ZSkgPT09IGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHNlbGVjdGlvbkNvbnRleHRDaGFuZ2VkKHNlbDEsIHNlbDIpIHtcbiAgICBsZXQgZGVwdGggPSBNYXRoLm1pbihzZWwxLiRhbmNob3Iuc2hhcmVkRGVwdGgoc2VsMS5oZWFkKSwgc2VsMi4kYW5jaG9yLnNoYXJlZERlcHRoKHNlbDIuaGVhZCkpO1xuICAgIHJldHVybiBzZWwxLiRhbmNob3Iuc3RhcnQoZGVwdGgpICE9IHNlbDIuJGFuY2hvci5zdGFydChkZXB0aCk7XG59XG5mdW5jdGlvbiBidWlsZE5vZGVWaWV3cyh2aWV3KSB7XG4gICAgbGV0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZnVuY3Rpb24gYWRkKG9iaikge1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIG9iailcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwgcHJvcCkpXG4gICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgIH1cbiAgICB2aWV3LnNvbWVQcm9wKFwibm9kZVZpZXdzXCIsIGFkZCk7XG4gICAgdmlldy5zb21lUHJvcChcIm1hcmtWaWV3c1wiLCBhZGQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjaGFuZ2VkTm9kZVZpZXdzKGEsIGIpIHtcbiAgICBsZXQgbkEgPSAwLCBuQiA9IDA7XG4gICAgZm9yIChsZXQgcHJvcCBpbiBhKSB7XG4gICAgICAgIGlmIChhW3Byb3BdICE9IGJbcHJvcF0pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbkErKztcbiAgICB9XG4gICAgZm9yIChsZXQgXyBpbiBiKVxuICAgICAgICBuQisrO1xuICAgIHJldHVybiBuQSAhPSBuQjtcbn1cbmZ1bmN0aW9uIGNoZWNrU3RhdGVDb21wb25lbnQocGx1Z2luKSB7XG4gICAgaWYgKHBsdWdpbi5zcGVjLnN0YXRlIHx8IHBsdWdpbi5zcGVjLmZpbHRlclRyYW5zYWN0aW9uIHx8IHBsdWdpbi5zcGVjLmFwcGVuZFRyYW5zYWN0aW9uKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlBsdWdpbnMgcGFzc2VkIGRpcmVjdGx5IHRvIHRoZSB2aWV3IG11c3Qgbm90IGhhdmUgYSBzdGF0ZSBjb21wb25lbnRcIik7XG59XG5cbmV4cG9ydCB7IERlY29yYXRpb24sIERlY29yYXRpb25TZXQsIEVkaXRvclZpZXcsIF9fZW5kQ29tcG9zaXRpb24sIF9fcGFyc2VGcm9tQ2xpcGJvYXJkIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/prosemirror-view/dist/index.js\n");

/***/ })

};
;